<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="VBAexpressions" script:language="StarBasic">&apos;@Exposed
Option Explicit
option Compatible
Option VBASupport 1
option ClassModule
Option Base 0
&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos; Copyright © 2024-2025 W. García
&apos; GPL-3.0 license | https://www.gnu.org/licenses/gpl-3.0.html/
&apos; https://github.com/ws-garcia
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;#
&apos; GENERAL INFO:
&apos; Class module developed to evaluate mathematical expressions using VBA strings. The
&apos; VBAexpressions class serves as an intermediate between the user interfaces and the main
&apos; VBA/custom functions exposed through it. The module can evaluate mathematical expressions
&apos; such as:
&apos;
&apos;            (a) 5*avg(2;abs(-3-7*tan(5));9)-12*pi-e+(7/sin(30)-4!)*min(cos(30);cos(150))
&apos;            (b) min(cos(sin(30))+2^2;1)
&apos;           *(c) GCD(1280;240;100;30*cos(0);10*DET({{sin(atn(1)*2); 0; 0}; {0; 2; 0}; {0; 0; 3}}))
&apos;
&apos; The main objective of the development of the class is to demonstrate that all mathematical
&apos; expressions can be evaluated computationally using an approach similar to the one we humans
&apos; use: divide the function into sub-expressions, create a symbolic string (lambda) to draw the
&apos; evaluation flow of the expression, split the sub-expressions into chunks of operations
&apos; (tokens) by tokenization, evaluate all the tokens.
&apos;
&apos; For example, the expressions given in (a), (b) and (c) will be translated into lambda strings:
&apos;           (a) 5*avg{6}-12*pi-e+{3}*min{2}
&apos;           (b) min{2}
&apos;          *(c) GCD{4}
&apos;
&apos;               *GCD and DET are user-defined functions (UDF).
&apos;
&apos; Allowed expressions must follow the following grammar:
&apos;
&apos; Expression    =     ([{&quot;(&quot;}]  SubExpr [{Operator [{&quot;(&quot;}] SubExpr [{&quot;)&quot;}]}] [{&quot;)&quot;}] | {[&quot;(&quot;] [&quot;{&quot;] List [{&quot;;&quot; List}] [&quot;}&quot;] [&quot;)&quot;]})
&apos; SubExpr       =     Token [{Operator Token}]
&apos; Token         =     [{Unary}] Argument [(Operator | Function) [&quot;(&quot;] [{Unary}] [Argument] [&quot;)&quot;]]
&apos; Argument      =     (List | Variable | Operand | Literal)
&apos; List          =     [&quot;{&quot;] [&quot;{&quot;] SubExpr [{&quot;;&quot; SubExpr}] [&quot;}&quot;] [&quot;}&quot;]
&apos; Unary         =     &quot;-&quot; | &quot;+&quot; | ~
&apos; Literal       =     (Operand | &quot;&apos;&quot;Alphabet&quot;&apos;&quot;)
&apos; Operand       =     ({Digit} [Decimal] [{Digit}] [&quot;E&quot;(&quot;-&quot; | &quot;+&quot;){Digit}] | (True | False))
&apos; Variable      =     Alphabet [{Decimal}] [{(Digit | Alphabet)}]
&apos; Alphabet      =     &quot;A-Z&quot; | &quot;a-z&quot;
&apos; Decimal       =     &quot;.&quot; | &quot;,&quot;
&apos; Digit = &quot;0-9&quot;
&apos; Operator      =     &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;\&quot; | &quot;^&quot; | &quot;%&quot; | &quot;!&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&lt;&gt;&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;=&quot; | &quot;$&quot; | &quot;&amp;&quot; | &quot;|&quot; | &quot;||&quot;
&apos; Function      =     &quot;abs&quot; | &quot;sin&quot; | &quot;cos&quot; | &quot;min&quot; |...|[UDF]
&apos;
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;#
&apos; ABOUT THE ORDER IN WHICH MATHEMATICAL EXPRESSIONS ARE EVALUATED:
&apos; VBA expressions uses the following precedence rules to evaluate mathematical expressions:
&apos;
&apos; 1. ()               Grouping: evaluates functions arguments as well.
&apos; 2. ! - +            Unary operators: exponentiation is the only operation that violates this. Ex.:
&apos;                     -2 ^ 2 = -4 | (-2) ^ 2 = 4.
&apos; 3. ^                Exponentiation: Although Excel and Matlab evaluate nested exponentiations from
&apos;                     left to right, Google, mathematicians and several modern programming languages,
&apos;                     such as Perl, Python and Ruby, evaluate this operation from right to left.
&apos;                     VBA expressions also evals in Python way: a^b^c = a^(b^c).
&apos; 4. * / %            Multiplication, division, modulo: from left to right.
&apos; 5. + -              Addition and subtraction: from left to right.
&apos; 6. &lt; &lt;= &lt;&gt; &gt;= = &gt; $ Comparison operators.
&apos; 7. ~                Logical negation.
&apos; 8. &amp;                Logical AND.
&apos; 9. ||               Logical XOR.
&apos; 10. |               Logical OR.
&apos;
&apos; Users can enter variables and substitute their values for the calculations. Variable names
&apos; must meet the following requirements:
&apos; 1. Start with a letter.
&apos; 2. End in a letter or number.
&apos;                               &quot;x.1&quot;, &quot;number1&quot;, &quot;value.a&quot; are valid variable names.
&apos; 3. A variable named &quot;A&quot; is distinct from another variable named &quot;a&quot;, since variables are
&apos;    case-sensitive. This rule is broken by the constant PI, since PI=Pi=pi=pI.
&apos; 4. The token &quot;E&quot; cannot be used as variable due this token is reserved for floating point
&apos;    computation. For example, the expression &quot;2.5pi+3.5e&quot; will be evaluated to ~17.3679680,
&apos;    but a expression like &quot;2.5pi+3.5E&quot; will return an error.
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;#
&apos; ABOUT USER-DEFINED FUNCTIONS (UDF):
&apos; Users can register custom modules to expose and use their functions for throght the
&apos; VBAcallBack.cls module. All UDFs must have a single Variant argument that will receive a
&apos; one-dimensional array of strings (one element for each function argument).
&apos;
&apos; VBA expressions can evaluate matrix functions whose arguments are given as vectors, using
&apos; a syntax like [Java](https://www.w3schools.com/java/java_arrays.asp). The following expression
&apos; will calculate the determinant (DET) of a matrix composed of 3 vectors with 3 elements each:
&apos;
&apos; DET({{sin(atn(1)*2); 0; 0}; {0; 2; 0}; {0; 0; 3}})
&apos;
&apos; If a user needs to evaluate an array function that accepts more than one argument, including
&apos; more than one array, all arrays must be passed surrounded by parentheses &quot;({...})&quot;.
&apos; For example, a call to a function that emule the SQL IN statement using an array and a reference
&apos; value can be written as follows:
&apos;
&apos;IN_(({{sin(atn(1)*2); 2; 3; 4; 5}});1)
&apos;
&apos; The above will pass this array of strings to the IN_ function:
&apos;
&apos; [{{1;2;3;4;5}}] [1]
&apos;
&apos; However, the array function needs to take care of creating arrays from a string, the ArrayFromString
&apos; method can be used for this purpose.
&apos;
&apos; For illustration pourposes, the UDFunctions.cls module has an implementation of the DET function
&apos; with a usage example of the array handle function. As well, the GCD function is implemented as demo.
&apos;
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos; CONSTANTS:
Private PI As Double
Private PID2 As Double
Private e As Double
Private Const op_plus As String = &quot;+&quot;
Private Const op_minus As String = &quot;-&quot;
Private Const op_mult As String = &quot;*&quot;
Private Const op_div As String = &quot;/&quot;
Private Const op_intDiv As String = &quot;\&quot;
Private Const op_Factorial As String = &quot;!&quot;
Private Const op_mod As String = &quot;%&quot;
Private Const op_power As String = &quot;^&quot;
Private Const op_equal As String = &quot;=&quot;
Private Const op_equal_ As String = &quot;==&quot;
Private Const op_inequality As String = &quot;&lt;&gt;&quot;
Private Const op_gt As String = &quot;&gt;&quot;
Private Const op_lt As String = &quot;&lt;&quot;
Private Const op_ltequal As String = &quot;&lt;=&quot;
Private Const op_gtequal As String = &quot;&gt;=&quot;
Private Const op_and As String = &quot;&amp;&quot;
Private Const op_or As String = &quot;|&quot;
Private Const op_xor As String = &quot;||&quot;
Private Const op_like As String = &quot;$&quot;
Private Const op_neg As String = &quot;~&quot;
Private Const op_AllItems As String = &quot;*+-/^%\=&lt;&gt;&amp;|$&quot;
Private Const op_AllNotUnaryItems As String = &quot;*/^%\=&lt;&gt;&amp;|$&quot;
Private Const d_lCurly As String = &quot;{&quot;
Private Const d_rCurly As String = &quot;}&quot;
Private Const d_lParenthesis As String = &quot;(&quot;
Private Const d_rParenthesis As String = &quot;)&quot;
Private Const d_lSquareB As String = &quot;[&quot;
Private Const d_rSquareB As String = &quot;]&quot;
Private Const d_Apostrophe As String = &quot;&apos;&quot;
Private Const d_Underscore As String = &quot;_&quot;
Private Const d_Space As String = &quot; &quot;
Private Const e_ValueError As String = &quot;#VALUE!&quot;
Private Const Tiny As Double = 1E-20
&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos; VARIABLES:
Private AscDecSymbol As Long
Private AssignedExpression As Boolean
Private BuildinFunctIDList As String
Private BuildinFunctNameList As String
Private ComputedTree As Boolean
Private EvalTree() As ClusterTree
Private ExprToEval As String
Private FunctionsId() As String
Private FunctionsName() As String
Private GeneratedTree As Boolean
Private IsUDFFunction As Boolean
Private LIndexConstruc(0 To 2) As String
Private P_DEC_SYMBOL As Long
Private P_DEGREES As Boolean
Private P_ERRORDESC As String
Private P_ERRTYPE As Long
Private P_EXPRESSION As String
Private P_ENFORCE_BOOLEAN As Boolean
Private P_FORMATRESULT As Boolean
Private P_GALLOPING_MODE As Boolean
Private P_RESULT As Variant
Private P_SCOPE As VBAexpressionsScope
Private P_SEPARATORCHAR As String
Private SubTreeData As Variant&apos;() As String
Private UserDefFunctions As ClusterBuffer
Private strVBA As VBAstrHelper
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos; QR DECOMPOSITION VARIABLES:
&apos;   /** Array for internal storage of decomposition.
&apos;   @serial internal array storage.
&apos;   */
Private QR() As Double
&apos;   /** Row and column dimensions.
&apos;   @serial column dimension.
&apos;   @serial row dimension.
&apos;   */
Private m As Long
Private n As Long
&apos;   /** Array for internal storage of diagonal of R.
&apos;   @serial diagonal of R.
&apos;   */
Private rDiag() As Double
&apos;   /** Array for internal storage of columns with signs to flip.
&apos;   @serial signs flip in R and Q outputs.
&apos;   */
Private signFlip() As Boolean
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos; ENUMERATIONS:
Public Enum OperatorToken
    otNull = 0
    otSum = 1                    &apos;+
    otDiff = 2                   &apos;-
    otMultiplication = 3         &apos;*
    otDivision = 4               &apos;/
    otIntDiv = 5                 &apos;\
    otPower = 6                  &apos;^
    otMod = 7                    &apos;%
    otEqual = 101                &apos;=
    otEqual_ = 102               &apos;==
    otNotEqual = 103             &apos;&lt;&gt;
    otGreaterThan = 104          &apos;&gt;
    otLessThan = 105             &apos;&lt;
    otGreaterThanOrEqual = 106   &apos;&gt;=
    otLessThanOrEqual = 107      &apos;&lt;=
    otLike = 108                 &apos;$
    otLogicalAND = 201           &apos;&amp;
    otLogicalOR = 202            &apos;|
    otLogicalXOR = 203           &apos;||
End Enum
Public Enum ExpressionErrors
    errNone = 0
    errUnbalancedBrackets = 1
    errSyntaxError = 2
    errEvalError = 3
    errVariableNotAssigned = 4
    errMissingArgsOrTooManyArgs = 5
End Enum
Public Enum enumDecimalSymbol
    dsDot = 0
    dsComma = 1
End Enum
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;TYPES
Type Argument
    DefString As String
    FactorialIn As Boolean
    funcName As String
    FunctionIn As Boolean
    Implicit As Boolean
    LinkedIndex As Long
    LinkedVar As Long
    NegationFlagOn As Boolean
    Operand As String
    UDFFunctionIn As Boolean
End Type

Type ClusterBuffer
    Capacity As Long
    aindex As Long
    Storage As Variant &apos;() As ClusterItem
End Type

Type ClusterItem
    aindex As Long
    aName As String
    value As String
    Assigned As Boolean
    value2 As Variant &apos;Array representation for the value
    IsArray As Boolean
End Type

Type ClusterTree
    Capacity As Long
    ClusterArrBounds As Variant&apos;() As Long   &apos;Stores the number of rows and columns
    CompArrCluster As Boolean
    CompCluster As Boolean
    EvalResult As String
    aindex As Long
    resulstMap As String
    Storage As Variant &apos;() As token
End Type

Type token
    Arg1 As Argument
    Arg2 As Argument
    ConstantToken As Boolean
    DefString As String
    EvalResult As String
    Logical As Boolean
    OperationToken As Long
End Type

Type TokenInfo
    OperationToken As Long
    OperatorLen As Long
    Position As Long
    LogicalToken As Boolean
End Type

&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Initializes this instance.
&apos;&apos;&apos; &lt;/summary&gt;
Private Sub Class_Initialize()
    Set strVBA = New VBAstrHelper
    AssignedExpression = False
    pi = 4 * Atn(1)
    PID2 = pi / 2
    e = Exp(1)
    P_SEPARATORCHAR = &quot;;&quot;
    P_DEC_SYMBOL = dsDot
    AscDecSymbol = 46
    P_GALLOPING_MODE = False
    P_FORMATRESULT = False
    BuildinFunctIDList = &quot;abs;floor;achisq;asin;acos;aerf;afishf;agauss;asc;anorm;atn;astudt;array;avg;beta.dist&quot; &amp; _
                            &quot;;bisector;betainv;ceil;chisq;cholesky;cholinverse;cholsolve;chr;circumcircle;cos;choose;circletang;date;dateadd;datediff&quot; &amp; _
                            &quot;;datepart;dateserial;datevalue;day;ddb;det;distance;erf;exp;fishf;fit;format;fv;fzero&quot; &amp; _
                            &quot;;gamma;gammaln;gauss;get;getfromlist;hour;ibeta;iff;incenter;incircle;instr;inverse;ipmt;irr;lcase;left;len;linesintersect;log;lgn&quot; &amp; _
                            &quot;;ln;lsqrsolve;ludecomp;lusolve;max;mid;min;minute;mirr;mlr;mmult;mneg;mround&quot; &amp; _
                            &quot;;msum;mtranspose;month;monthname;norm;now;nper;npv;parallel;percent;perpendicular;pmt;ppmt;pow;pv&quot; &amp; _
                            &quot;;qr;rate;rem;replace;right;round;sgn;sin;sln;solve;sqr;sqrt;sum;studt;switch&quot; &amp; _
                            &quot;;syd;tan;timeserial;timevalue;tinv;tinv_1t;tinv_2t;trim;ucase;weekday&quot; &amp; _
                            &quot;;weekdayname;year&quot;
    BuildinFunctNameList = &quot;Absolute;aFloor;ACHISQ;ArcSin;ArcCos;AERF;AFISHF;AGAUSS;ASCII;ANORM;ArcTan&quot; &amp; _
                            &quot;;ASTUDT;strArray;Average;Beta_Distribution;Bisector;BETAINV;aCeiling;CHISQ;CholeskyDec;CholeskyInverseMatrix&quot; &amp; _
                            &quot;;CholeskySolve;ASCIIchr;Circumcircle;Cosin;aChoose;CircleTangents;aDate;aDateAdd;aDateDiff;aDatePart;aDateSerial&quot; &amp; _
                            &quot;;aDateValue;aDay;aDDB;MatrixDeterminant;Distance;ERF;ExpEuler;FISHF;CurveFit&quot; &amp; _
                            &quot;;aFormat;aFV;FunctionZero;Gamma;GammaLN;GAUSS;GET;GetFromList;aHour;iBETA;aIff;Incenter;Incircle;aInstr;InverseMatrix&quot; &amp; _
                            &quot;;aIPMT;aIRR;LowerCase;aLeft;aLen;LinesIntersect;Logarithm;LgN;LN;LSQRsolve;LUdecomposition&quot; &amp; _
                            &quot;;LUSolveLinearSystem;Max;Middle;Min;aMinute;aMIRR;MultiLinearReg;MatrixMult&quot; &amp; _
                            &quot;;MatrixNegation;MatrixRound;MatrixSum;MatrixTranspose;aMonth;aMonthName;NORM&quot; &amp; _
                            &quot;;aNow;aNPER;aNPV;ParallelLine;Percent;PerpendicularLine;aPMT;aPPMT;Power;aPV;QRdecomposition;aRATE;REM&quot; &amp; _
                            &quot;;aReplace;aRight;ROUND;Sign;Sine;aSLN;SolveLinearSystem;SquareRoot;SquareRoot;SUM&quot; &amp; _
                            &quot;;STUDT;aSwitch;aSYD;Tangent;aTimeSerial;aTimeValue;TINV;TINV_1T;TINV_2T;aTrim&quot; &amp; _
                            &quot;;aUcase;aWweekDay;aWeekDayName;aYear&quot;
    FunctionsId() = Split(BuildinFunctIDList, &quot;;&quot;)
    FunctionsName() = Split(BuildinFunctNameList, &quot;;&quot;)
    Set P_SCOPE = New VBAexpressionsScope
    P_ENFORCE_BOOLEAN = False
    InitCBbuffer UserDefFunctions
    &apos;@--------------------------------------------------------------------
    &apos; Populate linked index constructor
    LIndexConstruc(0) = d_lSquareB
    LIndexConstruc(2) = d_rSquareB
    &apos;@--------------------------------------------------------------------
    &apos; Populate building UDFs
    Dim UDFnames() As Variant
    UDFnames() = Array(&quot;GCD&quot;, &quot;Concat&quot;)
    DeclareUDF UDFnames, &quot;UserDefFunctions&quot;                 &apos; Declare the Greatest Common Divisor and the string concatenation
                                                            &apos; functions defined in the UDfunctions class module.
                                                            &apos; This need an instance in the VBAcallBack class module.
    &apos;@--------------------------------------------------------------------
    &apos; Initialize error messages
    InitializeErrHandler
End Sub

&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos; PROPERTIES:


&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets the constants collection. By default this is pre-populated with PI and e.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get Constants() As Collection
    Set Constants = P_SCOPE.Constants
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets a string with the variables values used for the last evaluation.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get CurrentVariables() As String
    CurrentVariables = P_SCOPE.CurrentVariables
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets a string with the variables values used for the last evaluation.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get CurrentVarValues() As String
    CurrentVarValues = P_SCOPE.CurrentVarValues
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets or sets the decimal symbol. The allowed options are
&apos;&apos;&apos;     the dot or comma, if another character is specified
&apos;&apos;&apos;     dot will be used which is the default value.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get DecimalSymbol() As String
    Select Case P_DEC_SYMBOL
        Case 0
            DecimalSymbol = &quot;.&quot;
        Case 1
            DecimalSymbol = &quot;,&quot;
    End Select
End Property

Public Property Let DecimalSymbol(aValue As String)
    If strVBA.LenB2(aValue) &gt; 2 Then
        P_DEC_SYMBOL = 0
    Else
        Dim tmpLng As Long
        
        tmpLng = AscW(aValue)
        If tmpLng = 44 Or tmpLng = 46 Then
            AscDecSymbol = tmpLng
            If tmpLng = 46 Then
                P_DEC_SYMBOL = 0
            Else
                P_DEC_SYMBOL = 1
            End If
        End If
    End If
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets or sets the behaviour when calculating trigonometric functions. If True, the program
&apos;&apos;&apos;     will assume argument passed in degrees for all trigonometric functions.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get Degrees() As Boolean
    Degrees = P_DEGREES
End Property

Public Property Let Degrees(aValue As Boolean)
    P_DEGREES = aValue
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the last error message generated.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get ErrorDesc() As String
    ErrorDesc = P_ERRORDESC
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the type of the last error message generated.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get ErrorType() As ExpressionErrors
    ErrorType = P_ERRTYPE
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Sets/gets the scope for the current expression.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get EvalScope() As Object
    Set EvalScope = P_SCOPE
End Property

Public Property Set EvalScope(aObject As VBAexpressionsScope)
    Set P_SCOPE = aObject
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the math expression to be evaluated.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get expression() As String
    expression = P_EXPRESSION
End Property

Public Property Get EnforceBoolean() As Boolean
    EnforceBoolean = P_ENFORCE_BOOLEAN
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     When True, a False is returned on evaluation errors.
&apos;&apos;&apos;     This can be useful when evaluating piecewise functions.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Let EnforceBoolean(aValue As Boolean)
    P_ENFORCE_BOOLEAN = aValue
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Indicates if the results will be converted to standard VBA strings
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get FormatResult() As Boolean
    FormatResult = P_FORMATRESULT
End Property

Public Property Let FormatResult(aValue As Boolean)
    P_FORMATRESULT = aValue
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets or sets the evaluation in galloping mode. When set
&apos;&apos;&apos;     to True, the evaluator will discriminate constant tokens
&apos;&apos;&apos;     from variable tokens.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get GallopingMode() As Boolean
    GallopingMode = P_GALLOPING_MODE
End Property

Public Property Let GallopingMode(aValue As Boolean)
    P_GALLOPING_MODE = aValue
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets the parsed status of the actual expression.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get ReadyToEval() As Boolean
    ReadyToEval = GeneratedTree
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets the result for latest evaluated expression.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get Result() As String
    If P_FORMATRESULT Then
        Result = FormatLiteralString(CStr(P_RESULT), True)
    Else
        Result = P_RESULT
    End If
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets or sets the character used as functions argumnets, array elements, separator. By
&apos;&apos;&apos;     default the char used is the semicolon &quot;;&quot;.
&apos;&apos;&apos; &lt;/summary&gt;
Public Property Get SeparatorChar() As String
    SeparatorChar = P_SEPARATORCHAR
End Property

Public Property Let SeparatorChar(aValue As String)
    If strVBA.LenB2(aValue) = 2 Then
        Select Case AscW(aValue)
            Case 44, 46 &apos;Reject reserved decimal symbols
            Case Else
                P_SEPARATORCHAR = aValue
        End Select
    End If
End Property

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets or sets the current value from/to the given variable.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;Public Property Get VarValue(aVarName As String) As String
Public Function GetVarValue(aVarName As String) As String
    GetVarValue = P_SCOPE.GetVarValue(aVarName)
End Function

&apos;Public Property Let VarValue(aVarName As String, aVarValue As String)
Public Sub LetVarValue(aVarName As String, aVarValue As String)
    If GeneratedTree Then
        P_SCOPE.LetVarValue(aVarName, aVarValue)
    End If
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets or sets the current value from an instance for the given variable.
&apos;&apos;&apos;     If &apos;aVarKey&apos; is numeric, the argument is treated as an index.
&apos;&apos;&apos;
&apos;&apos;&apos;     NOTE: this version use Variant data type to handle arrays.
&apos;&apos;&apos;     The string array representation is retrieved as usual if the
&apos;&apos;&apos;     parameter &quot;treatAsArray&quot; is set to False, an array is returned
&apos;&apos;&apos;     otherwise.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;Public Property Get VarValue2(aVarKey As Variant, treatAsArray As Boolean) As Variant
Public Function GetVarValue2(aVarKey As Variant, treatAsArray As Boolean) As Variant
    GetVarValue2 = P_SCOPE.GetVarValue2(aVarKey, treatAsArray)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets or sets the current value from/to the given variable.
&apos;&apos;&apos;     If &apos;aVarKey&apos; is numeric, the argument is treated as an index.
&apos;&apos;&apos;
&apos;&apos;&apos;     NOTE: this version use variant data type to handle arrays.
&apos;&apos;&apos;     The array string is stored as usual, but a conversion is
&apos;&apos;&apos;     also perfomed to allocate an array created by parsing the
&apos;&apos;&apos;     given string when the parameter &quot;treatAsArray&quot; is set to True.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;Public Property Let VarValue2(aVarKey As Variant, treatAsArray As Boolean, aVarValue As Variant)
Public Sub LetVarValue2(aVarKey As Variant, treatAsArray As Boolean, aVarValue As Variant)
    P_SCOPE.LetVarValue2(aVarKey, treatAsArray, aVarValue)
End Sub

&apos;#
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
&apos; METHODS:
Private Function Absolute(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    Absolute = CStr(Abs(CDbl(expression)))
    Exit Function
err_Handler:
    Absolute = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function aCeiling(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    aCeiling = CStr(Ceiling(CDbl(expression)))
    Exit Function
err_Handler:
    aCeiling = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the inverse of CHISQ function
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;probability.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt;Degrees of freedom.&lt;/param&gt;
Private Function ACHISQ(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = ACHISQ_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    ACHISQ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    ACHISQ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ACHISQ_(p As Double, n As Double) As Double
    Dim v As Double, dv As Double, x As Double
    
    v = 0.5: dv = 0.5: x = 0
    Do While (dv &gt; 0.000000000000001)
        x = 1 / v - 1: dv = dv / 2
        If (CHISQ_(x, n) &gt; p) Then
            v = v - dv
        Else
            v = v + dv
        End If
    Loop
    ACHISQ_ = x
End Function

Public Sub AddConstant(aValue As String, aKey As String)
    P_SCOPE.AddConstant aValue, aKey
End Sub

Private Sub AddExponentialPredictors(ByRef x() As Double, ByRef pExponents() As Long)
    Dim i As Long
    Dim j As Long
    Dim UB As Long
    Dim UB2 As Long
    Dim tmpData() As Double
    
    UB = UBound(x)
    UB2 = UBound(x, 2)
    tmpData = x
    For i = 0 To UBound(pExponents)
        If pExponents(i) &gt; 1 Then &apos;Only not lineal degrees
            UB2 = UB2 + 1
            ReDim Preserve tmpData(0 To UB, 0 To UB2)
            For j = 0 To UB
                tmpData(j, UB2) = x(j, 0) ^ pExponents(i)
            Next j
        End If
    Next i
    x = tmpData
End Sub

Private Sub AddIntersectionCol(ByRef x() As Double)
    Dim i As Long
    Dim j As Long
    Dim UB As Long
    Dim UB2 As Long
    
    UB = UBound(x)
    UB2 = UBound(x, 2)
    ReDim Preserve x(0 To UB, 0 To UB2 + 1)
    For i = 0 To UB
        For j = UB2 To 0 Step -1
            x(i, j + 1) = x(i, j)
            If j = 0 Then
                x(i, j) = 1
            End If
        Next j
    Next i
End Sub

Private Sub AddPredictorsRelations(ByRef x() As Double, ByRef PredInteractions As Variant)
    Dim i As Long
    Dim j As Long
    Dim UB As Long
    Dim UB2 As Long
    Dim idx1 As Long
    Dim idx2 As Long
    Dim tmpPredict() As String
    Dim tmpData() As Double
    
    UB = UBound(x)
    UB2 = UBound(x, 2)
    tmpData = x
    For i = 0 To UBound(PredInteractions)
        tmpPredict = Split(PredInteractions(i), op_mult)
        idx1 = CLng(strVBA.MidB(tmpPredict(LBound(tmpPredict)), 3))
        idx2 = CLng(strVBA.MidB(tmpPredict(LBound(tmpPredict) + 1), 3))
        UB2 = UB2 + 1
        ReDim Preserve tmpData(0 To UB, 0 To UB2)
        For j = 0 To UB
            tmpData(j, UB2) = x(j, idx1) * x(j, idx2)
        Next j
    Next i
    x = tmpData
End Sub

Private Sub AddToMap(aValue As Long, aTarget As ClusterTree)
    If aTarget.resulstMap = vbNullString Then
        aTarget.resulstMap = CStr(aValue)
    Else
        aTarget.resulstMap = aTarget.resulstMap &amp; P_SEPARATORCHAR &amp; aValue
    End If
End Sub

Private Sub AddVariable(ByRef variable As String, ByRef aKey As String)
    P_SCOPE.AddVariable variable, aKey
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the inverse of ERF function
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;probability.&lt;/param&gt;
Private Function AERF(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = AERF_( _
                            CDbl(tmpData(LB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    AERF = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    AERF = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function AERF_(p As Double) As Double
    AERF_ = AGAUSS_(p / 2 + 0.5) / Sqr(2)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the inverse of FISHF function
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;P-value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n1&quot;&gt;Degrees of freedom 1.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n2&quot;&gt;Degrees of freedom 2.&lt;/param&gt;
Private Function AFISHF(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = AFISHF_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(LB + 1)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    AFISHF = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    AFISHF = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function AFISHF_(p As Double, N1 As Double, N2 As Double) As Double
    Dim v As Double, dv As Double, f As Double
    
    v = 0.5: dv = 0.5: f = 0
    Do While (dv &gt; 0.000000000000001)
        f = 1 / v - 1: dv = dv / 2
        If (FISHF_(f, N1, N2) &gt; p) Then
             v = v - dv
        Else
            v = v + dv
        End If
    Loop
    AFISHF_ = f
End Function

Private Function aFloor(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    aFloor = CStr(Floor(CDbl(expression)))
    Exit Function
err_Handler:
    aFloor = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the inverse of GAUSS function
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;probability.&lt;/param&gt;
Private Function AGAUSS(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = AGAUSS_( _
                            CDbl(tmpData(LB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    AGAUSS = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    AGAUSS = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function AGAUSS_(p As Double) As Double
    If (p &gt; 0.5) Then
        AGAUSS_ = Sqr(ACHISQ_(2 * (1 - p), 1))
    Else
        AGAUSS_ = -Sqr(ACHISQ_(2 * p, 1))
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an array with two points that defines the bisector of
&apos;&apos;&apos;     the segment or angle, depending on whether two or three points
&apos;&apos;&apos;     are passed as input. The arguments must satisfy
&apos;&apos;&apos;
&apos;&apos;&apos;             To compute segment bisector: {{Ax;Ay}};{{Bx;By}}
&apos;&apos;&apos;             To compute angle bisector: {{Ax;Ay}};{{Bx;By}};{{Cx;Cy}}
&apos;&apos;&apos;
&apos;&apos;&apos;     where B=(Bx,By) is a the angle&apos;s vertex for angular bisection.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointA&quot;&gt;First point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointB&quot;&gt;Second point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointC&quot;&gt;Third point.&lt;/param&gt;
Private Function AngleSegmentBisector(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Variant
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = SegmentBisector_(ToDblArray(ArrayFromString(tmpData(LB))), _
                                    ToDblArray(ArrayFromString(tmpData(UB))))
        Case 3
            tmpEval = AngleBisector_(ToDblArray(ArrayFromString(tmpData(LB))), _
                                    ToDblArray(ArrayFromString(tmpData(LB + 1))), _
                                    ToDblArray(ArrayFromString(tmpData(UB))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    If IsArray(tmpEval) Then
        AngleSegmentBisector = ArrayToString(tmpEval)
    Else
        AngleSegmentBisector = tmpEval
    End If
    Erase tmpData
    Exit Function
err_Handler:
    AngleSegmentBisector = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function AngleBisector_(PointA() As Double, PointB() As Double, PointC() As Double) As Variant
    Dim Ax As Double, Ay As Double
    Dim Bx As Double, By As Double
    Dim Cx As Double, Cy As Double
    Dim ux As Double, uy As Double
    Dim vx As Double, vy As Double
    Dim nu As Double, nv As Double
    Dim uhatx As Double, uhaty As Double
    Dim vhatx As Double, vhaty As Double
    Dim dx As Double, dy As Double
    Dim nd As Double
    Dim result2D(0 To 1, 0 To 1) As Double
    
    Ax = PointA(0)
    Ay = PointA(1)
    Bx = PointB(0)
    By = PointB(1)
    Cx = PointC(0)
    Cy = PointC(1)
    &apos;Vector BA and BC
    ux = Ax - Bx
    uy = Ay - By
    vx = Cx - Bx
    vy = Cy - By
    &apos;Lenghts
    nu = Sqr(ux * ux + uy * uy)
    nv = Sqr(vx * vx + vy * vy)
    If nu = 0 Or nv = 0 Then
        &apos;Collinear points
        err.Raise vbObjectError + 513, , _
            &quot;One of the segments BA or BC has zero lenght.&quot;
        AngleBisector_ = e_ValueError
        Exit Function
    End If
    &apos;Unit vectors
    uhatx = ux / nu
    uhaty = uy / nu
    vhatx = vx / nv
    vhaty = vy / nv
    &apos;Sum to get bisector direction (not yet unit)
    dx = uhatx + vhatx
    dy = uhaty + vhaty
    &apos;Normalize direction
    nd = Sqr(dx * dx + dy * dy)
    If nd = 0 Then
        err.Raise vbObjectError + 514, , _
            &quot;Points are collinear and opposite; internal bisector is undefined&quot;
        AngleBisector_ = e_ValueError
        Exit Function
    End If
    dx = dx / nd
    dy = dy / nd
    &apos;Return B and D = B + (dx,dy)
    result2D(0, 0) = Bx: result2D(0, 1) = By
    result2D(1, 0) = Bx + dx: result2D(1, 1) = By + dy
    AngleBisector_ = result2D
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the inverse of NORM function
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;probability.&lt;/param&gt;
Private Function anorm(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ANORM_( _
                            CDbl(tmpData(LB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    anorm = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    anorm = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ANORM_(p) As Double
    Dim v As Double, dv As Double, z As Double
    v = 0.5: dv = 0.5: z = 0
    Do While (dv &gt; 0.000000000000001)
        z = 1 / v - 1: dv = dv / 2
        If (NORM_(z) &gt; p) Then
             v = v - dv
        Else
            v = v + dv
        End If
    Loop
    ANORM_ = z
End Function

Private Sub AppendToBuffer(ByRef aBuffer As ClusterTree, ByRef aToken As token)
	aBuffer.aindex = aBuffer.aindex + 1
    If aBuffer.aindex = aBuffer.Capacity Then ExpandBuffer(aBuffer)
    Set aBuffer.Storage(aBuffer.aindex) = aToken
End Sub

Private Sub AppendToCBbuffer(ByRef aBuffer As ClusterBuffer, ByRef ItemName As String, Optional ByRef ItemValue As String = vbNullString)
	aBuffer.aindex = aBuffer.aindex + 1
    If aBuffer.aindex = aBuffer.Capacity Then ExpandBuffer(aBuffer)
    aBuffer.Storage(aBuffer.aindex).aindex = aBuffer.aindex
    aBuffer.Storage(aBuffer.aindex).Assigned = (ItemValue &lt;&gt; vbNullString)
    aBuffer.Storage(aBuffer.aindex).aName = ItemName
    aBuffer.Storage(aBuffer.aindex).value = ItemValue
End Sub

Private Function ApplyLawOfSigns(ByRef expression As String) As String
    Dim tmpResult As String
    
    tmpResult = expression
    Do While tmpResult Like &quot;*[+-][+-]*&quot;
        SignSubstitution tmpResult, &quot;+-&quot;, op_minus
        SignSubstitution tmpResult, &quot;-+&quot;, op_minus
        SignSubstitution tmpResult, &quot;++&quot;, op_plus
        SignSubstitution tmpResult, &quot;--&quot;, op_plus
    Loop
    ApplyLawOfSigns = tmpResult
End Function

Private Function ArcCos(ByRef expression As String, ByRef fName As String) As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = CDbl(expression)
    tmpEval = Atn(-tmpEval / Sqr(-tmpEval * tmpEval + 1)) + 2 * Atn(1)
    If P_DEGREES Then
        tmpEval = tmpEval * 180 / pi
    End If
    ArcCos = CStr(tmpEval)
    Exit Function
err_Handler:
    ArcCos = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ArcSin(ByRef expression As String, ByRef fName As String) As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = CDbl(expression)
    tmpEval = Atn(tmpEval / Sqr(-tmpEval * tmpEval + 1))
    If P_DEGREES Then
        tmpEval = tmpEval * 180 / pi
    End If
    ArcSin = CStr(tmpEval)
    Exit Function
err_Handler:
    ArcSin = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ArcTan(ByRef expression As String, ByRef fName As String) As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = CDbl(expression)
    tmpEval = Atn(tmpEval)
    If P_DEGREES Then
        tmpEval = tmpEval * 180 / pi
    End If
    ArcTan = CStr(tmpEval)
    Exit Function
err_Handler:
    ArcTan = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the remainder of n/d division
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt;Dividend.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;d&quot;&gt;Divisor.&lt;/param&gt;
Private Function aREM(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = REM_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    aREM = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    aREM = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function aROUND(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ROUND_( _
                            CDbl(tmpData(LB)) _
                            )
        Case 2
            tmpEval = ROUND_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    aROUND = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    aROUND = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Turns a like Java array string ({{*};{*}}) into a 1D  or 2D VBA array with n rows and m columns.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;StrArray&quot;&gt;The string definition used to create the array.&lt;/param&gt;
Public Function ArrayFromString(ByRef strArray As String) As Variant
    Dim aIndex As Long
    Dim arrCapacity As Long
    Dim boolOpenArray As Boolean
    Dim curChar As String
    Dim i As Long, j As Long
    Dim NumCols As Long
    Dim NumRows As Long
    Dim OneDarr As Boolean
    Dim OutStrArray() As String
    Dim OpenCBrackets As Long
    Dim StrCopy As String
    Dim StrLen As Long
    Dim tmpStr() As Variant
    Dim VectorEndPos As Long
    Dim VectorStartPos As Long
    Dim inputIs2D As Boolean
    
    StrCopy = ReconstructLiteralStrings(strArray, Join$(Split(strArray, d_Space), vbNullString))
    StrLen = strVBA.LenB2(StrCopy)
    If strVBA.MidB(StrCopy, 1, 4) &lt;&gt; &quot;{{&quot; Then &apos;Missed &quot;{&quot; from input
        Exit Function
    End If
    If strVBA.MidB(StrCopy, StrLen - 3) &lt;&gt; &quot;}}&quot; Then &apos;Missed &quot;}&quot; from input
        Exit Function
    End If
    i = 1
    aIndex = -1
    arrCapacity = 128
    ReDim tmpStr(0 To arrCapacity - 1)
    Do
        curChar = strVBA.MidB(StrCopy, i, 2)
        If curChar = d_lCurly Then
            OpenCBrackets = OpenCBrackets + 1
            If (OpenCBrackets And 1) = 0 Then &apos;Takes care of array syntax
                VectorStartPos = i + 2
            End If
        Else
            If curChar = d_rCurly Then
                OpenCBrackets = OpenCBrackets - 1
                If (OpenCBrackets And 1) Then &apos;End of vector
                    VectorEndPos = i
                    aIndex = aIndex + 1
                    If aIndex &gt; arrCapacity Then
                        arrCapacity = arrCapacity * 2
                        ReDim Preserve tmpStr(0 To arrCapacity - 1)
                    End If
                    tmpStr(aIndex) = Split(strVBA.MidB(StrCopy, VectorStartPos, _
                                        VectorEndPos - VectorStartPos), P_SEPARATORCHAR)
                End If
            End If
        End If
        boolOpenArray = (OpenCBrackets &gt; 0)
        i = i + 2
    Loop While boolOpenArray Or (i &lt;= StrLen)
    NumRows = aIndex
    NumCols = UBound(tmpStr(aIndex))
    inputIs2D = (strArray Like &quot;{{*}&quot; &amp; P_SEPARATORCHAR &amp; &quot;{*}*}&quot;)
    OneDarr = (NumRows = 0) And Not inputIs2D
    If OneDarr Then
        ReDim OutStrArray(0 To NumCols)
       	For j = 0 To NumCols
        	OutStrArray(j) = tmpStr(0)(j)
       	Next j
    Else &apos;2D array
        ReDim OutStrArray(0 To NumRows, 0 To NumCols)
        For i = 0 To NumRows
        	For j = 0 To NumCols
                OutStrArray(i, j) = tmpStr(i)(j)
        	Next j
    	Next i
    End If
    ArrayFromString = OutStrArray
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Turns a like Java array string ({{*};{*}}) into VBA jagged array with n rows.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;StrArray&quot;&gt;The string definition used to create the array.&lt;/param&gt;
Public Function ArrayFromString2(ByRef strArray As String) As Variant
    Dim aIndex As Long
    Dim arrCapacity As Long
    Dim boolOpenArray As Boolean
    Dim curChar As String
    Dim i As Long
    Dim JaggedArrFlag As Boolean
    Dim NumRows As Long
    Dim StrCopy As String
    Dim StrLen As Long
    Dim tmpStr() As Variant
    Dim VectorEndPos As Long
    Dim VectorStartPos As Long
    Dim OpenCBrackets As Long
    
    StrCopy = ReconstructLiteralStrings(strArray, Join$(Split(strArray, d_Space), vbNullString))
    StrLen = strVBA.LenB2(StrCopy)
    If strVBA.MidB(StrCopy, 1, 4) &lt;&gt; &quot;{{&quot; Then &apos;Missed &quot;{&quot; from input
        Exit Function
    End If
    If strVBA.MidB(StrCopy, StrLen - 3) &lt;&gt; &quot;}}&quot; Then &apos;Missed &quot;}&quot; from input
        Exit Function
    End If
    i = 1
    aIndex = -1
    arrCapacity = 128
    ReDim tmpStr(0 To arrCapacity - 1)
    Do
        curChar = strVBA.MidB(StrCopy, i, 2)
        If curChar = d_lCurly Then
            OpenCBrackets = OpenCBrackets + 1
            If Not JaggedArrFlag Then
                JaggedArrFlag = (OpenCBrackets &gt; 2)
            End If
            If (OpenCBrackets And 1) = 0 Then &apos;Takes care of array syntax
                VectorStartPos = i + 2
            End If
        Else
            If curChar = d_rCurly Then
                OpenCBrackets = OpenCBrackets - 1
                If (OpenCBrackets And 1) Then &apos;End of vector
                    If Not JaggedArrFlag Then
                        VectorEndPos = i
                    Else
                        VectorStartPos = VectorStartPos - 2
                        VectorEndPos = i + 2
                    End If
                    aIndex = aIndex + 1
                    If aIndex &gt; arrCapacity Then
                        arrCapacity = arrCapacity * 2
                        ReDim Preserve tmpStr(0 To arrCapacity - 1)
                    End If
                    If boolOpenArray And Not JaggedArrFlag Then
                        tmpStr(aIndex) = Split(strVBA.MidB(StrCopy, VectorStartPos, _
                                        VectorEndPos - VectorStartPos), P_SEPARATORCHAR)
                    Else
                        If JaggedArrFlag Then
                            tmpStr(aIndex) = ArrayFromString2(strVBA.MidB(StrCopy, VectorStartPos, _
                                                        VectorEndPos - VectorStartPos))
                            JaggedArrFlag = False
                        End If
                    End If
                End If
            End If
        End If
        boolOpenArray = (OpenCBrackets &gt; 0)
        i = i + 2
    Loop While boolOpenArray Or (i &lt;= StrLen)
    NumRows = aIndex
    ReDim Preserve tmpStr(0 To aIndex)
    ArrayFromString2 = tmpStr
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Turns a two dimensional array into a one dimensional array.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;InputArray&quot;&gt;The array to operate.&lt;/param&gt;
Private Function ArraySTR1DFrom2DArr(ByRef InputArray() As String) As Variant
    Dim i As Long, LB As Long, UB As Long
    Dim j As Long, LB2 As Long, UB2 As Long
    Dim tmpData() As String
    
    LB = LBound(InputArray)
    UB = UBound(InputArray)
    LB2 = LBound(InputArray, 2)
    UB2 = UBound(InputArray, 2)
    ReDim tmpData(0 To (UB - LB + 1) * (UB2 - LB2 + 1) - 1)
    For i = LB To UB
        For j = LB2 To UB2
            tmpData(i * (UB2 - LB2 + 1) + j) = InputArray(i, j)
        Next j
    Next i
    ArraySTR1DFrom2DArr = tmpData
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Turns a mxn array into a like Java array string ({{*};{*}}).
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;InputArray&quot;&gt;The array to operate.&lt;/param&gt;
Public Function ArrayToString(ByRef InputArray As Variant) As String
    Dim i As Long, LB As Long, UB As Long
    Dim j As Long, LB2 As Long, UB2 As Long
    Dim tmpData As String, MultiDimArr As Boolean
    Dim isJaggedArray As Boolean
    
    If IsArray(InputArray) Then
        LB = LBound(InputArray)
        UB = UBound(InputArray)
        MultiDimArr = Is2Darray(InputArray)
        If MultiDimArr Then
            LB2 = LBound(InputArray, 2)
            UB2 = UBound(InputArray, 2)
        Else
            isJaggedArray = IsArray(InputArray(LB))
            If Not isJaggedArray Then
                LB2 = LB
                UB2 = UB
                UB = LB
            End If
        End If
        For i = LB To UB
            If isJaggedArray And IsTwiceJaggedArr(InputArray, i) Then
                If i = LB Then
                    tmpData = ArrayToString(InputArray(i))
                Else
                    tmpData = tmpData &amp; ArrayToString(InputArray(i))
                End If
            Else
                If isJaggedArray Then
                    LB2 = LBound(InputArray(i))
                    UB2 = UBound(InputArray(i))
                End If
                For j = LB2 To UB2
                    If j = LB2 Then
                        tmpData = tmpData &amp; d_lCurly &amp; GetArrItm(InputArray, MultiDimArr, isJaggedArray, i, j)
                    Else
                        tmpData = tmpData &amp; P_SEPARATORCHAR &amp; GetArrItm(InputArray, MultiDimArr, isJaggedArray, i, j)
                    End If
                    If j = UB2 Then
                        tmpData = tmpData &amp; d_rCurly
                    End If
                Next j
            End If
            If i &lt; UB Then
                tmpData = tmpData &amp; P_SEPARATORCHAR
            End If
        Next i
        ArrayToString = d_lCurly &amp; tmpData &amp; d_rCurly
    End If
End Function

Private Function Array_(ByRef expression As String, ByRef fName As String) As String
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    Dim iCounter As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    tmpEval = tmpData(iCounter)
    For iCounter = LB + 1 To UB
        tmpEval = tmpEval &amp; P_SEPARATORCHAR &amp; tmpData(iCounter)
    Next iCounter
    Array_ = d_lCurly &amp; tmpEval &amp; d_rCurly
    Exit Function
err_Handler:
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Asc_(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    Asc_ = CStr(AscW(FormatLiteralString(expression, True)))
    Exit Function
err_Handler:
    Asc_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the inverse of STUDT function
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;probability.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt;Degrees of freedom.&lt;/param&gt;
Private Function ASTUDT(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = ASTUDT_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    ASTUDT = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    ASTUDT = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ASTUDT_(p As Double, n As Double) As Double
    Dim v As Double, dv As Double, t As Double
    
    v = 0.5: dv = 0.5: t = 0
    Do While (dv &gt; 0.000000000000001)
        t = 1 / v - 1: dv = dv / 2
        If (STUDT_(t, n) &gt; p) Then
            v = v - dv
        Else
            v = v + dv
        End If
    Loop
    ASTUDT_ = t
End Function

Private Function average(ByRef expression As String, ByRef fName As String) As String
    Dim g As Long
    Dim tmpData() As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = 0
    tmpData() = SplitArgs(expression)
    For g = LBound(tmpData) To UBound(tmpData)
        tmpEval = tmpEval + CDbl(tmpData(g))
    Next g
    tmpEval = tmpEval / (UBound(tmpData) - LBound(tmpData) + 1)
    average = CStr(tmpEval): Erase tmpData
    Exit Function
err_Handler:
    average = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function betacf(x As Double, A As Double, B As Double) As Double
    Dim fpmin As Double
    Dim m As Long
    Dim M2 As Long
    Dim aa As Double, c As Double
    Dim d As Double, del As Double
    Dim h As Double, qab As Double
    Dim qam As Double, qap As Double
    
    fpmin = 1E-30
    m = 1

&apos;   // These q&apos;s will be used in factors that occur in the coefficients
    qab = A + B: qap = A + 1: qam = A - 1
    c = 1: d = 1 - qab * x / qap
    If Abs(d) &lt; fpmin Then d = fpmin
    d = 1 / d
    h = d
    Do While m &lt;= 100
        M2 = 2 * m
        aa = m * (B - m) * x / ((qam + M2) * (A + M2))
&apos;       // One step (the even one) of the recurrence
        d = 1 + aa * d
        If Abs(d) &lt; fpmin Then d = fpmin
        c = 1 + aa / c
        If Abs(c) &lt; fpmin Then c = fpmin
        d = 1 / d: h = h * d * c
        aa = -(A + m) * (qab + m) * x / ((A + M2) * (qap + M2))
&apos;       // Next step of the recurrence (the odd one)
        d = 1 + aa * d
        If Abs(d) &lt; fpmin Then d = fpmin
        c = 1 + aa / c
        If Abs(c) &lt; fpmin Then c = fpmin
        d = 1 / d: del = d * c
        h = h * del
        If Abs(del - 1#) &lt; 0.0000003 Then Exit Do
        m = m + 1
    Loop
    betacf = h
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the inverse cumulative beta inverse probability distribution function.
&apos;&apos;&apos;     That is, if probability = BETADIST(x,...), BETAINV(probability,...) = x.
&apos;&apos;&apos;     The cumulative beta distribution can be used in project planning to determine
&apos;&apos;&apos;     likely completion times given a variability and an expected completion time.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;Probability.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;a&quot;&gt;Shape parameter alpha.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;b&quot;&gt;Shape parameter beta.&lt;/param&gt;
Private Function BETAINV(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = BETAINV_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(LB + 1)), _
                            CDbl(tmpData(UB)))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    BETAINV = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    BETAINV = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function BETAINV_(p As Double, A As Double, B As Double) As Double
    Const EPS As Double = 0.00000001
    Dim aL As Double
    Dim a1, b1 As Double
    Dim j As Long
    Dim lna As Double, lnb As Double
    Dim pp As Double, t As Double
    Dim u As Double, err As Double
    Dim x As Double, h As Double
    Dim w As Double, afac As Double
    
    a1 = A - 1: b1 = B - 1
    j = 0
    If p &lt;= 0 Then
        BETAINV_ = 0
        Exit Function
    End If
    If p &gt;= 1 Then
        BETAINV_ = 1
        Exit Function
    End If
    If A &gt;= 1 And B &gt;= 1 Then
        If p &lt; 0.5 Then
            pp = p
        Else
            pp = 1 - p
        End If
        t = Sqr(-2 * Log(pp))
        x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t
        If p &lt; 0.5 Then x = -x
        aL = (x * x - 3) / 6
        h = 2 / (1 / (2 * A - 1) + 1 / (2 * B - 1))
        w = (x * Sqr(aL + h) / h) - (1 / (2 * B - 1) - 1 / (2 * A - 1)) * _
            (aL + 5 / 6 - 2 / (3 * h))
        x = A / (A + B * Exp(2 * w))
    Else
        lna = Log(A / (A + B)): lnb = Log(B / (A + B))
        t = Exp(A * lna) / A: u = Exp(B * lnb) / B
        w = t + u
        If p &lt; t / w Then
            x = (A * w * p) ^ (1 / A)
        Else
            x = 1 - ((B * w * (1 - p)) ^ (1 / B))
        End If
    End If
    afac = -GAMMALN_(A) - GAMMALN_(B) + GAMMALN_(A + B)
    Do While j &lt; 10
        If x = 0 Or x = 1 Then BETAINV_ = x: Exit Function
        err = iBETA_(x, A, B) - p
        t = Exp(a1 * Log(x) + b1 * Log(1 - x) + afac)
        u = err / t
        t = u / (1 - 0.5 * MIN_(1, u * (a1 / x - b1 / (1 - x))))
        x = x - t
        If x &lt;= 0 Then x = 0.5 * (x + t)
        If x &gt;= 1 Then x = 0.5 * (x + t + 1)
        If Abs(t) &lt; EPS * x And j &gt; 0 Then Exit Do
        j = j + 1
    Loop
    BETAINV_ = x
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the beta distribution.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;x&quot;&gt;The value between A and B at which to evaluate the function.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;alpha&quot;&gt;Shape parameter alpha.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;beta&quot;&gt;Shape parameter beta.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;Cumulative&quot;&gt;
&apos;&apos;&apos;     A logical value that determines the form of the function. If cumulative is TRUE,
&apos;&apos;&apos;     BETADIST returns the cumulative distribution function; if FALSE, it returns
&apos;&apos;&apos;     the probability density function (PDF).
&apos;&apos;&apos; &lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;A&quot;&gt;Optional. A lower bound to the interval of x.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;B&quot;&gt;Optional. An upper bound to the interval of x.&lt;/param&gt;
Private Function BETADIST(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 4
            tmpEval = BETAPDF_EXCEL( _
                                CDbl(tmpData(LB)), _
                                CDbl(tmpData(LB + 1)), _
                                CDbl(tmpData(LB + 2)), _
                                CBool(tmpData(LB + 3)), _
                                0, 1)
        Case 6
            tmpEval = BETAPDF_EXCEL( _
                                CDbl(tmpData(LB)), _
                                CDbl(tmpData(LB + 1)), _
                                CDbl(tmpData(LB + 2)), _
                                CBool(tmpData(LB + 3)), _
                                CDbl(tmpData(LB + 4)), _
                                CDbl(tmpData(UB)))
        Case Else
            tmpEval = e_ValueError
            BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    BETADIST = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    BETADIST = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function BETALN_(x As Double, y As Double) As Double
    BETALN_ = GAMMALN_(x) + GAMMALN_(y) - GAMMALN_(x + y)
End Function

Private Function BETAPDF_(x As Double, Alpha As Double, Beta As Double) As Double
    BETAPDF_ = Exp((Alpha - 1) * Log(x) + (Beta - 1) * Log(1 - x) - BETALN_(Alpha, Beta))
End Function

Private Function BETAPDF_EXCEL(x As Double, Alpha As Double, _
                                    Beta As Double, Cumulative As Boolean, _
                                    Lower_Bound As Double, _
                                    Upper_Bound As Double) As Variant
    Dim z As Double
    Dim range_ As Double
    
    If Upper_Bound &gt; Lower_Bound Then
        If x &gt; Lower_Bound And x &lt; Upper_Bound Then
            range_ = (Upper_Bound - Lower_Bound)
            z = (x - Lower_Bound) / range_
            If Cumulative Then
                BETAPDF_EXCEL = iBETA_(z, Alpha, Beta)
            Else
                BETAPDF_EXCEL = BETAPDF_(z, Alpha, Beta) / range_
            End If
        Else
            If x = Lower_Bound Or x = Upper_Bound Then
                If Cumulative Then
                    If x = Upper_Bound Then
                        BETAPDF_EXCEL = 1
                    Else
                        BETAPDF_EXCEL = 0
                    End If
                Else
                    BETAPDF_EXCEL = 0
                End If
            Else
                BETAPDF_EXCEL = &quot;#NUM!&quot;
            End If
        End If
    Else
        BETAPDF_EXCEL = &quot;#NUM!&quot;
    End If
End Function

Private Sub BottomLevelEval(ByRef aToken As token)
    On Error GoTo BLevelEval_errHanlder
    If aToken.OperationToken &lt; 100 Then &apos;Arithmetic operators
        Select Case aToken.OperationToken
            Case otSum
                aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) _
                                    + CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
            Case otDiff
                aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) - _
                                    CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
            Case otMultiplication
                aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) * _
                                    CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
            Case otDivision
                aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) / _
                                    CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
            Case otPower
                Dim kFctr As Double
                If AscW(aToken.Arg1.DefString) = 45 Then
                    kFctr = -1
                Else
                    kFctr = 1
                End If
                aToken.EvalResult = kFctr * CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) ^ _
                                            CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
            Case otMod
                aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) Mod _
                                    CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
            Case otIntDiv
                aToken.EvalResult = Floor(CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) / _
                                    CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn))
            Case Else
                If aToken.Logical Then
                    If aToken.Arg1.NegationFlagOn Then
                        If AscW(aToken.Arg1.Operand) &lt;&gt; 126 Then &apos;&quot;~&quot;
                            aToken.EvalResult = CBool(CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn))
                        Else
                            aToken.EvalResult = CBool(strVBA.MidB(CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn), 3))
                        End If
                    Else
                        aToken.EvalResult = CBool(CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn))
                    End If
                Else
                    aToken.EvalResult = aToken.Arg1.Operand
                End If
        End Select
    Else
        If aToken.OperationToken &lt; 200 Then &apos;Comparison operators
            Select Case aToken.OperationToken
                Case otEqual, otEqual_
                    aToken.EvalResult = (CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) = _
                                        CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn))
                Case otNotEqual
                    aToken.EvalResult = (CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) &lt;&gt; _
                                        CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn))
                Case otGreaterThan
                    aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) &gt; _
                                        CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
                Case otLessThan
                    aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) &lt; _
                                        CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
                Case otGreaterThanOrEqual
                    aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) &gt;= _
                                        CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
                Case otLessThanOrEqual
                    aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) &lt;= _
                                        CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
                Case otLike
                    aToken.EvalResult = CastOPtype(aToken.Arg1.Operand, aToken.Arg1.NegationFlagOn) Like _
                                        CastOPtype(aToken.Arg2.Operand, aToken.Arg2.NegationFlagOn)
            End Select
        Else &apos;Logical operators
            Dim tmpBooleans() As Boolean
            Select Case aToken.OperationToken
                Case otLogicalAND
                    tmpBooleans() = GetLogicalNeg(aToken)
                    aToken.EvalResult = tmpBooleans(0) And tmpBooleans(1)
                Case otLogicalOR
                    tmpBooleans() = GetLogicalNeg(aToken)
                    aToken.EvalResult = tmpBooleans(0) Or tmpBooleans(1)
                Case Else
                    tmpBooleans() = GetLogicalNeg(aToken)
                    aToken.EvalResult = tmpBooleans(0) Xor tmpBooleans(1)
            End Select
        End If
    End If
    EvalResultSwithc False, aToken
Exit Sub
BLevelEval_errHanlder:
    EvalResultSwithc True, aToken
End Sub
Private Sub EvalResultSwithc(exitedWithErr As Boolean, ByRef aToken As token)
    If exitedWithErr Or aToken.EvalResult = e_ValueError Then
        If P_ENFORCE_BOOLEAN Then
            aToken.EvalResult = False
        End If
    End If
End Sub
Private Sub BuildErrMessage(ErrorType As ExpressionErrors, Optional AditionalContext As String)
    P_ERRTYPE = ErrorType
    Select Case P_ERRTYPE
        Case Is = errUnbalancedBrackets
            P_ERRORDESC = &quot;The expression cannot be evaluated due to unbalanced parenthesis count. &quot; &amp; AditionalContext
        Case Is = errSyntaxError
            P_ERRORDESC = &quot;The expression cannot be evaluated due to a syntax error. &quot; &amp; AditionalContext
        Case Is = errEvalError
            P_ERRORDESC = &quot;An error occurred while trying to evaluate the expression. &quot; &amp; AditionalContext
        Case Is = errVariableNotAssigned
            P_ERRORDESC = &quot;The expression cannot be evaluated due to the existence of variables without assigned values. &quot; &amp; AditionalContext
        Case Is = errMissingArgsOrTooManyArgs
            P_ERRORDESC = &quot;Arguments count differ from predefined one.  &quot; &amp; AditionalContext
    End Select
End Sub

Private Function callback(ByRef sClassName As String) As Object
    Dim cbObject As Object
	
	Set cbObject = New VBAcallBack
    Set callback = CallByName(cbObject, sClassName, VbGet)
End Function

Private Function CastCase(ByRef expression As String) As String
    If Not NotIsPI(expression) Then
        CastCase = LCase$(expression)     &apos;Case insensitive for PI
    Else
        CastCase = expression
    End If
End Function

Private Function CastOPtype(ByRef strOperand As String, ByRef Negate As Boolean) As Variant
    If strOperand &lt;&gt; vbNullString Then
        Dim OpAscw As Long
        OpAscw = AscW(strOperand)
        Select Case OpAscw
            Case 48 To 57, 43, 45, AscDecSymbol
                CastOPtype = CDbl(strOperand)
            Case Else
                If IsLiteralString(strOperand) Then &apos;Literal strings like [&apos;string&apos;]
                    CastOPtype = FormatLiteralString(strOperand)
                Else
                    If Not Negate Then
                        CastOPtype = -1 * CBool(strOperand)
                    Else
                        CastOPtype = -1 * (Not CBool(strOperand))
                    End If
                End If
        End Select
    Else
        CastOPtype = strOperand
    End If
End Function

Private Function Ceiling(ByRef value As Double) As Double
    Dim tmpResult As Double
    
    tmpResult = Fix(value)
    Ceiling = tmpResult - ((value &lt;&gt; tmpResult) And (value &gt; 0))
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an array with the coordinates for the center
&apos;&apos;&apos;     and the radius for circle circumscribed by given triangle.
&apos;&apos;&apos;     The result is the circle that passes through the three
&apos;&apos;&apos;     given points.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointA&quot;&gt;First point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointB&quot;&gt;Second point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointC&quot;&gt;Third point.&lt;/param&gt;
Private Function Circumcircle(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Variant
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = Circumcircle_(ToDblArray(ArrayFromString(tmpData(LB))), _
                                    ToDblArray(ArrayFromString(tmpData(LB + 1))), _
                                    ToDblArray(ArrayFromString(tmpData(UB))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    If IsArray(tmpEval) Then
        Circumcircle = ArrayToString(tmpEval)
    Else
        Circumcircle = tmpEval
    End If
    Erase tmpData
    Exit Function
err_Handler:
    Circumcircle = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Circumcircle_(PointA() As Double, PointB() As Double, PointC() As Double) As Variant
    Dim hk() As Double
    Dim intersectP() As Double
    Dim result2D(0 To 1, 0 To 1) As Double
    Dim Radius As Double
    
    hk = ToDblArray(LinesIntersection( _
                                SegmentBisector_(PointA, PointB), _
                                SegmentBisector_(PointB, PointC) _
                            ) _
                        )
    Radius = Distance_(hk, PointA)
    result2D(0, 0) = hk(0): result2D(0, 1) = hk(1)
    result2D(1, 0) = Radius: result2D(1, 1) = Radius
    Circumcircle_ = result2D
End Function

Private Function CheckArgument(ByRef ArgDefStr As String, ByRef IsFactorial As Boolean) As Boolean
    Dim tmpResult As Boolean
    
    tmpResult = Not OPsymbolInArgument(ArgDefStr, PatternToCheckOn(ArgDefStr))
    If tmpResult Then
        If Not IsFactorial Then     &apos;Check missplaced op_Factorial
            tmpResult = (strVBA.InStrB(1, ArgDefStr, op_Factorial) = 0)
            If tmpResult Then
                If strVBA.LenB2(ArgDefStr) = 2 Then
                    tmpResult = Not ArgDefStr = op_plus And Not ArgDefStr = op_minus
                End If
            End If
        End If
    End If
    CheckArgument = tmpResult
End Function

Private Function CheckVarValues() As Boolean
    If AssignedExpression Then
        CheckVarValues = P_SCOPE.DefinedScope
    Else
        CheckVarValues = True
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the one-tailed (right-tail) probability value for a chi-square test
&apos;&apos;&apos;     (i.e., the area under the chi-square distribution from the chi-square value
&apos;&apos;&apos;     to positive infinity), given the chi-square value and the degrees of freedom.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;x&quot;&gt;Chi-square value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt;Degrees of freedom.&lt;/param&gt;
Private Function CHISQ(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = CHISQ_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    CHISQ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    CHISQ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function CHISQ_(x As Double, n As Double) As Double
    Dim q As Double
    Dim p As Double
    Dim k As Double
    Dim t As Double
    Dim A As Double
    
    If (x &gt; 1000 Or n &gt; 1000) Then
        q = NORM_((((x / n) ^ (1 / 3)) + 2 / (9 * n) - 1) / Sqr(2 / (9 * n))) / 2
        If (x &gt; n) Then
            CHISQ_ = q: Exit Function
        Else
            CHISQ_ = 1 - q: Exit Function
        End If
    End If
    p = Exp(-0.5 * x)
    If (REM_(n, 2) = 1) Then
        p = p * Sqr(2 * x / pi)
    End If
    k = n
    Do While (k &gt;= 2)
        p = p * x / k: k = k - 2
    Loop
    t = p
    A = n
    Do While (t &gt; 0.000000000000001 * p)
        A = A + 2
        t = t * x / A: p = p + t
    Loop
    CHISQ_ = 1 - p
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Given a positive-definite symmetric square matrix A[0..n-1][0..n-1], construct
&apos;&apos;&apos;     and store its Cholesky decomposition, A = L.LT. The result is the lower triangular
&apos;&apos;&apos;     matrix L.
&apos;&apos;&apos;
&apos;&apos;&apos;     NOTE: el() Stores the decomposition.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function Cholesky(ByRef A() As Double, ByRef el() As Double) As Variant
    Dim n As Long   &apos;Rows
    Dim m As Long   &apos;Columns
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim pSum As Double
    
    n = UBound(A) - LBound(A) + 1
    m = UBound(A, 2) - LBound(A, 2) + 1
    If m &lt;&gt; n Then Exit Function &apos;need square matrix
    el = A
    For i = 0 To n - 1
        For j = i To n - 1
            pSum = el(i, j)
            k = i - 1
            Do While k &gt;= 0
                pSum = pSum - el(i, k) * el(j, k)
                k = k - 1
            Loop
            If i = j Then &apos;Check diagonal elements
                If pSum &lt;= 0 Then &apos;A, with rounding errors, is not positive-definite.
                    Erase el &apos;Cholesky failed. Test for not initialized array needed.
                    Exit Function
                End If
                el(i, i) = Sqr(pSum)
            Else
                el(j, i) = pSum / el(i, i)
            End If
        Next j
    Next i
    For i = 0 To n - 1
        For j = 0 To i - 1
            el(j, i) = 0
        Next j
    Next i
    Cholesky = el
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Given a positive-definite symmetric square matrix A[0..n-1][0..n-1], construct
&apos;&apos;&apos;     and store its Cholesky decomposition, A = L.LT. The result is the lower triangular
&apos;&apos;&apos;     matrix L.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function CholeskyDecomposition(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            Dim aArray() As Double
            Dim cholDec() As Double
            
            aArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            Cholesky aArray(), cholDec
            If IsArrayAllocated(cholDec) Then
                tmpEval = ArrayToString(cholDec)
            Else
                tmpEval = e_ValueError
                BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; _
                                &quot;: the give matrix is not positive-definite symmetric.&quot; &amp; d_rCurly
                Exit Function &apos;Error computing Decomposition
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    CholeskyDecomposition = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    CholeskyDecomposition = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the inverse of a matrix by Cholesky decomposition
&apos;&apos;&apos; &lt;/summary&gt;
Private Function CholeskyInverseMatrix(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            Dim aArray() As Double
            Dim cholDec() As Double
            
            aArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            Cholesky aArray(), cholDec
            If IsArrayAllocated(cholDec) Then
                tmpEval = ArrayToString(CholeskyInverseMatrix_(cholDec))
            Else
                tmpEval = e_ValueError
                BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; _
                                &quot;: the give matrix is not positive-definite symmetric.&quot; &amp; d_rCurly
                Exit Function &apos;Error computing Decomposition
            End If
        Case Else
            tmpEval = e_ValueError
            BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    CholeskyInverseMatrix = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    CholeskyInverseMatrix = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Sets ainv[0..n-1][0..n-1] to the matrix inverse of A, the matrix whose Cholesky
&apos;&apos;&apos;     decomposition has been stored.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function CholeskyInverseMatrix_(ByRef el() As Double) As Variant
    Dim n As Long
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim pSum As Double
    Dim ainv() As Double
    
    n = UBound(el) - LBound(el) + 1
    ReDim ainv(0 To n - 1, 0 To n - 1)
    For i = 0 To n - 1
        For j = 0 To i
            pSum = IIf(i = j, 1, 0)
            For k = i - 1 To j Step -1
                pSum = pSum - el(i, k) * ainv(j, k)
            Next k
            ainv(j, i) = pSum / el(i, i)
        Next j
    Next i
    For i = n - 1 To 0 Step -1
        For j = 0 To i
            pSum = IIf(i &lt; j, 0, ainv(j, i))
            For k = i + 1 To n - 1
                pSum = pSum - el(k, i) * ainv(j, k)
            Next k
            ainv(i, j) = pSum / el(i, i)
            ainv(j, i) = ainv(i, j)
        Next j
    Next i
    CholeskyInverseMatrix_ = ainv
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Solves the linear system AX = B using Cholesky decomposition. The function
&apos;&apos;&apos;     requires that the &lt;expression&gt; argument be composed of the following:
&apos;&apos;&apos;                     1-) An array in text form containing the coefficients of all equations.
&apos;&apos;&apos;                     2-) An one dimentional array containing the name of each variable
&apos;&apos;&apos;                         (the first name will be applied to the first column of coefficients,
&apos;&apos;&apos;                         the second name to the second column and so on).
&apos;&apos;&apos;                     3-) An one dimentional array containing the right-hand side of each equation,
&apos;&apos;&apos;                         (the first name will be applied to the first column of coefficients,
&apos;&apos;&apos;                         the second name to the second column and so on).
&apos;&apos;&apos;                     4-) A True or False parameter to decide when to include the variable names
&apos;&apos;&apos;                         in the result set.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function CholeskySolve(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3, 4
            Dim aArray() As Double
            Dim eqCount As Long
            Dim iCounter As Long
            Dim includeNames As Boolean
            Dim mLB As Long
            Dim mUB As Long
            Dim NamesArray() As String
            Dim xArray() As Double
            Dim bArray() As Double
            Dim tmpElement As String
            Dim cholDec() As Double
            
            aArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            bArray() = ToDblArray(ArrayFromString(tmpData(LB + 2)))
            mLB = LBound(aArray)
            mUB = UBound(aArray)
            
            eqCount = mUB - mLB + 1
            Cholesky aArray(), cholDec
            If IsArrayAllocated(cholDec) Then
                CholeskySolve_ cholDec, bArray, xArray
            Else
                Exit Function &apos;Error computing Decomposition
            End If
            If argsCount = 4 Then
                NamesArray() = ArrayFromString(tmpData(LB + 1))
                includeNames = CBool(tmpData(UB))
            End If
            For iCounter = mLB To mUB
                If iCounter &gt; mLB Then
                    tmpEval = tmpEval &amp; P_SEPARATORCHAR &amp; d_Space
                End If
                If includeNames Then
                    tmpElement = FormatLiteralString(NamesArray(iCounter)) _
                                &amp; d_Space &amp; op_equal &amp; d_Space _
                                &amp; xArray(iCounter)
                Else
                    tmpElement = xArray(iCounter)
                End If
                tmpEval = tmpEval &amp; tmpElement
            Next iCounter
            If Not includeNames Then
                tmpEval = d_lCurly &amp; d_lCurly &amp; tmpEval &amp; d_rCurly &amp; d_rCurly
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    CholeskySolve = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    CholeskySolve = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Solves the set of n linear equations A.x = b, where a is
&apos;&apos;&apos;     a positive-definite symmetric matrix. whose Cholesky
&apos;&apos;&apos;     decomposition has been stored. b[0..n-1] is input as the right-hand
&apos;&apos;&apos;     side vector. The solution vector is returned in x[0..n-1].
&apos;&apos;&apos;     NOTE: el() Stores the decomposition.
&apos;&apos;&apos; &lt;/summary&gt;
Private Sub CholeskySolve_(ByRef el() As Double, ByRef B() As Double, ByRef x() As Double)
    Dim i As Long
    Dim k As Long
    Dim pSum As Double
    Dim n As Long
    Dim e As Long
    
    n = UBound(el) - LBound(el) + 1
    e = UBound(B) - LBound(B) + 1
    If e &lt;&gt; n Then Exit Sub &apos;bad lengths in Cholesky
    ReDim x(0 To n - 1)
    For i = 0 To n - 1 &apos;Solve L.y = b, storing y in x.
        pSum = B(i)
        k = i - 1
        Do While k &gt;= 0
            pSum = pSum - el(i, k) * x(k)
            k = k - 1
        Loop
        x(i) = pSum / el(i, i)
    Next i
    For i = n - 1 To 0 Step -1 &apos;Solve LT.x = y
        pSum = x(i)
        k = i + 1
        Do While k &lt; n
            pSum = pSum - el(k, i) * x(k)
            k = k + 1
        Loop
        x(i) = pSum / el(i, i)
    Next i
End Sub

Private Function Choose(ByRef expression As String, ByRef fName As String) As String
    Dim LB As Long
    Dim UB As Long
    Dim tmpData() As String
    Dim aindex As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    aindex = Fix(CDbl(tmpData(LB))) + LB
    If aindex &gt; LB And (aindex &lt;= UB) Then
        Choose = tmpData(aindex)
    Else
        Choose = e_ValueError
    End If
    Exit Function
err_Handler:
    Choose = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Chr_(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    Chr_ = ToLiteralString(ChrW(CLng(expression))) &apos;Expected numeric value
    Exit Function
err_Handler:
    Chr_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the mean for the given column from a 2D array
&apos;&apos;&apos;     NOTE: PolyFit helper
&apos;&apos;&apos; &lt;/summary&gt;
Private Function ColumnAvg(vArr() As Double, Optional colIndex As Long) As Double
    Dim i As Long
    Dim n As Long
    Dim TDflag As Boolean
    Dim tmpResult As Double
    
    n = UBound(vArr) - LBound(vArr) + 1
    TDflag = Is2Darray(vArr)
    For i = 0 To n - 1
        If TDflag Then
            tmpResult = tmpResult + vArr(i, colIndex) / n
        Else
            tmpResult = tmpResult + vArr(i) / n
        End If
    Next i
    ColumnAvg = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Traverses and evaluates the current parse tree.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function Compute() As String
    Dim B As Long
    Dim t As Long
    Dim i As Long
    Dim OperationIndex As Long
    Dim BaseIndex As Long
    Dim SkipToken As Boolean
    
    BaseIndex = UBound(SubTreeData) + 1
    For B = LBound(EvalTree) To UBound(EvalTree)              &apos;Loop all subexpressions
        OperationIndex = BaseIndex
        For t = 0 To EvalTree(B).aindex                         &apos;Loop all tokens
            OperationIndex = OperationIndex + 1
            If P_GALLOPING_MODE Then
                SkipToken = EvalTree(B).Storage(t).ConstantToken And _
                            EvalTree(B).Storage(t).EvalResult &lt;&gt; vbNullString
            Else
                SkipToken = False
            End If
            If Not SkipToken Then &apos;Gallop
                GetOperands EvalTree(B).Storage(t), EvalTree(B), BaseIndex
                BottomLevelEval EvalTree(B).Storage(t)
            End If
        Next t
        If Not EvalTree(B).CompCluster Then
            EvalTree(B).EvalResult = EvalTree(B).Storage(t - 1).EvalResult
        Else            &apos;The ClusterTree contains a composite function args as expression
            Dim tmpResult() As String
            tmpResult() = Split(EvalTree(B).resulstMap, P_SEPARATORCHAR)
            &apos;@--------------------------------------------------------------------
            &apos; Loop all sub-expression tokens results
            For i = LBound(tmpResult) To UBound(tmpResult)
                tmpResult(i) = EvalTree(B).Storage(CLng(tmpResult(i))).EvalResult
            Next i
            If Not EvalTree(B).CompArrCluster Then   &apos;Function Argument
                EvalTree(B).EvalResult = Join$(tmpResult, P_SEPARATORCHAR)
            Else        &apos;Array function Argument
                EvalTree(B).EvalResult = JoinArrFunctArg(tmpResult, EvalTree(B).ClusterArrBounds)
            End If
        End If
    Next B
    Compute = EvalTree(B - 1).EvalResult
    ComputedTree = True
End Function

Private Function Cosin(ByRef expression As String, ByRef fName As String) As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = CDbl(expression)
    If P_DEGREES Then
        tmpEval = tmpEval * pi / 180
    End If
    Cosin = CStr(Cos(tmpEval))
    Exit Function
err_Handler:
    Cosin = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function InLiteralGap(ByRef expression As String, parenthesisPos As Long) As Boolean
    Dim literalStrGap() As Long
    Dim foundLiteralStrGap As Boolean
    Dim tmpBool As Boolean
    ReDim literalStrGap(0 To 1)
    
    Do
        literalStrGap() = GetLiteralStringGap(literalStrGap(1) + 1, expression)
        foundLiteralStrGap = (literalStrGap(0) &gt; 0 And literalStrGap(1) &gt; 0)
        tmpBool = (parenthesisPos &gt; 2 * literalStrGap(0) And parenthesisPos &lt; 2 * literalStrGap(1))
    Loop While foundLiteralStrGap And Not tmpBool
    InLiteralGap = tmpBool
End Function

Private Function CountParentheses(ByRef expression As String, ByRef ParenthesisChar As String) As Long
    Dim tmpResult As Long
    Dim SearchIndex As Long
    Dim OpenedClosedP As Long

    OpenedClosedP = strVBA.InStrB(1, expression, ParenthesisChar)
    Do While OpenedClosedP
        If Not InLiteralGap(expression, OpenedClosedP) Then
            tmpResult = tmpResult + 1
        End If
        SearchIndex = OpenedClosedP + 2
        OpenedClosedP = strVBA.InStrB(SearchIndex, expression, ParenthesisChar)
    Loop
    CountParentheses = tmpResult
End Function

Public Function Create(ByRef aExpression As Variant, Optional resetScope As Boolean = True) As Object
    If aExpression &lt;&gt; vbNullString Then
        ExprToEval = FormatEntry(CStr(aExpression))
        If (ExprToEval &lt;&gt; FormatEntry(P_EXPRESSION)) Then
            P_EXPRESSION = aExpression
            If resetScope Then
                VariablesInit(ExprToEval)
            Else
                ParseVariables(ExprToEval)
            End If
            ExprToEval = ReconstructLiteralStrings(P_EXPRESSION, _
                                SBracketsNotationToNominal(ReplaceImpliedMult(ExprToEval)))
            Parse(ExprToEval)
        End If
        AssignedExpression = True
    End If
    Set Create = Me
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Creates a curve string representation from solver coefficients
&apos;&apos;&apos;     NOTE: PolyFit helper
&apos;&apos;&apos; &lt;/summary&gt;
Private Function CurveString(ByRef SolverResult As Variant, cOption As Long) As String
    Select Case cOption
        Case 2 &apos;Exponential [y = a*e^(b*x)]
            CurveString = CStr(Round(SolverResult(0, 0), 4)) &amp; op_mult &amp; &quot;e&quot; &amp; op_power &amp; _
                            d_lParenthesis &amp; Round(SolverResult(1, 0), 4) &amp; op_mult &amp; &quot;x&quot; &amp; d_rParenthesis
        Case 3 &apos;Exponential [y = a*b^x]
            CurveString = CStr(Round(SolverResult(0, 0), 4)) &amp; op_mult &amp; _
                            d_lParenthesis &amp; Round(SolverResult(1, 0), 4) &amp; op_power &amp; &quot;x&quot; &amp; d_rParenthesis
        Case 4 &apos;Power [y = a*x^b]
            CurveString = CStr(Round(SolverResult(0, 0), 4)) &amp; op_mult &amp; &quot;x&quot; &amp; op_power &amp; Round(SolverResult(1, 0), 4)
        Case 5 &apos;Logarithmic [y = a*ln(x) + b]
            Dim sepChr As String
            If SolverResult(0, 0) &gt; 0 Then
                sepChr = op_plus
            End If
            CurveString = CStr(Round(SolverResult(1, 0), 4)) &amp; op_mult &amp; &quot;ln(x)&quot; &amp; sepChr &amp; _
                                Round(SolverResult(0, 0), 4)
    End Select
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes linearization for linear like functions
&apos;&apos;&apos;     NOTE: CurveFit helper
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;samplesArr&quot;&gt;Data sample containing the observations pairs (x,y).&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;cOption&quot;&gt;Curve type ID.&lt;/param&gt;
Private Function DataLinearization(ByRef samplesArr() As Double, cOption As Long) As Variant
    Dim i As Long
    Dim LB As Long
    Dim UB As Long
    Dim LB2 As Long
    Dim UB2 As Long
    Dim tmpResult() As Double
    
    LB = LBound(samplesArr)
    UB = UBound(samplesArr)
    LB2 = LBound(samplesArr, 2)
    UB2 = UBound(samplesArr, 2)
    ReDim tmpResult(LB To UB, LB2 To UB2)
    For i = LB To UB
        Select Case cOption
            Case 2, 3 &apos;Exponential [y = a*e^(b*x) or y = a*b^x]
                tmpResult(i, 1) = Log10(samplesArr(i, 1))
                tmpResult(i, 0) = samplesArr(i, 0)
            Case 4 &apos;Power [y = a*x^b]
                tmpResult(i, 1) = Log10(samplesArr(i, 1))
                tmpResult(i, 0) = Log10(samplesArr(i, 0))
            Case 5 &apos;Logarithmic [y = a*ln(x) + b]
                tmpResult(i, 1) = samplesArr(i, 1)
                tmpResult(i, 0) = Log(samplesArr(i, 0)) &apos;LN
        End Select
    Next i
    DataLinearization = tmpResult
End Function

Private Function DateAdd_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = ToLiteralString(DateAdd( _
                                FormatLiteralString(tmpData(LB), True), _
                                CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                                FormatLiteralString(tmpData(UB), True) _
                                ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    DateAdd_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    DateAdd_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function DateDiff_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = DateDiff( _
                                FormatLiteralString(tmpData(LB), True), _
                                FormatLiteralString(tmpData(LB + 1), True), _
                                FormatLiteralString(tmpData(UB), True) _
                                )
        Case 4
            tmpEval = DateDiff( _
                                FormatLiteralString(tmpData(LB), True), _
                                FormatLiteralString(tmpData(LB + 1), True), _
                                FormatLiteralString(tmpData(LB + 2), True), _
                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                )
        Case 5
            tmpEval = DateDiff( _
                                FormatLiteralString(tmpData(LB), True), _
                                FormatLiteralString(tmpData(LB + 1), True), _
                                FormatLiteralString(tmpData(LB + 2), True), _
                                CLng(FormatLiteralString(tmpData(LB + 3), True)), _
                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    DateDiff_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    DateDiff_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function DatePart_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = DatePart( _
                                FormatLiteralString(tmpData(LB), True), _
                                FormatLiteralString(tmpData(UB), True) _
                                )
        Case 3
            tmpEval = DatePart( _
                                FormatLiteralString(tmpData(LB), True), _
                                FormatLiteralString(tmpData(LB + 1), True), _
                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                )
        Case 4
            tmpEval = DatePart( _
                                FormatLiteralString(tmpData(LB), True), _
                                FormatLiteralString(tmpData(LB + 1), True), _
                                CLng(FormatLiteralString(tmpData(LB + 2), True)), _
                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    DatePart_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    DatePart_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function DateSerial_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = ToLiteralString(DateSerial( _
                                CLng(FormatLiteralString(tmpData(LB), True)), _
                                CLng(FormatLiteralString(tmpData(LB + 1), True)), _
                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    DateSerial_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    DateSerial_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function DateValue_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ToLiteralString(DateValue( _
                                FormatLiteralString(tmpData(LB), True) _
                                ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    DateValue_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    DateValue_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Date_(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    If expression &lt;&gt; vbNullString Then
        Date_ = ToLiteralString(Date)
    End If
    Exit Function
err_Handler:
    Date_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Day_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = Day( _
                            FormatLiteralString(tmpData(LB), True) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Day_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Day_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function DDB_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 4
            tmpEval = DDB(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = DDB(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    DDB_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    DDB_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Public Sub DeclareUDF(ByRef UDFname As Variant, Optional ByRef UDFlib As String = &quot;UserDefFunctions&quot;)
    If IsArray(UDFname) Then
        Dim i As Long
        For i = LBound(UDFname) To UBound(UDFname)
            StoreUDF UserDefFunctions, CStr(UDFname(i)), UDFlib    &apos;The Value member points to the function library
        Next i
    Else
        StoreUDF UserDefFunctions, CStr(UDFname), UDFlib
    End If
End Sub

Private Function DefineIRRfunction(ByRef strArray() As String) As String
    Dim arrLB As Long
    Dim idx As Long
    Dim tmpResult As String
    
    arrLB = LBound(strArray)
    tmpResult = strArray(arrLB)
    For idx = arrLB + 1 To UBound(strArray)
        tmpResult = tmpResult &amp; op_plus &amp; _
                    &quot;(&quot; &amp; FormatLiteralString(strArray(idx), True) _
                    &amp; op_div &amp; &quot;(1+iRate)&quot; &amp; op_power &amp; idx - arrLB &amp; &quot;)&quot;
    Next idx
    DefineIRRfunction = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the determinant for the given matrix
&apos;&apos;&apos; &lt;/summary&gt;
Private Function Determinant(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            Dim aArray() As Double
            Dim pivotingIdx() As Long
            Dim d As Double             &apos;Interchages parity
            Dim i As Long
            
            aArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            LUdecomp aArray(), pivotingIdx, d
            For i = LBound(aArray) To UBound(aArray)
                d = d * aArray(i, i)
            Next i
            tmpEval = d
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Determinant = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Determinant = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the distance between two given points.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Point1&quot;&gt;Array of coordinates in format {{x1;y1}}.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;Point2&quot;&gt;Array of coordinates in format {{x2;y2}}.&lt;/param&gt;
Private Function Distance(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = Distance_(ToDblArray(ArrayFromString(tmpData(LB))), ToDblArray(ArrayFromString(tmpData(UB))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Distance = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Distance = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Distance_(Point1() As Double, Point2() As Double) As Double
    Distance_ = ((Point2(0) - Point1(0)) ^ 2 + (Point2(1) - Point1(1)) ^ 2) ^ 0.5
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Finds for constant sub-expressions
&apos;&apos;&apos; &lt;/summary&gt;
Private Sub DetermineKtokens()
    Dim BaseIndex As Long
    Dim B As Long, t As Long
    
    BaseIndex = UBound(SubTreeData) + 1
    For B = LBound(EvalTree) To UBound(EvalTree)              &apos;Loop all subexpressions
        For t = 0 To EvalTree(B).aindex                         &apos;Loop all tokens
            EvalTree(B).Storage(t).ConstantToken = IsConstantToken( _
                                                    EvalTree(B).Storage(t), EvalTree(B), BaseIndex _
                                                    )
        Next t
    Next B
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the value of the error function (i.e., the area under the
&apos;&apos;&apos;     error function from 0 to x), given the limit of integration x. The
&apos;&apos;&apos;     error function is also known as the Gauss error function.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;x&quot;&gt;Limit of integration.&lt;/param&gt;
Private Function ERF(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ERF_( _
                            CDbl(tmpData(LB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    ERF = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    ERF = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ERF_(x As Double) As Double
    If (x &lt; 0) Then
        ERF_ = (2 * (GAUSS_(Sqr(2) * x) + 0.5) - 1) &apos;Use CDF function over GAUSS value
    Else
        ERF_ = (1 - 2 * (GAUSS_(-Sqr(2) * x) + 0.5))
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Evaluates a math expression.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;ValuesToEvalIn&quot;&gt;The values to use for eval the parse tree.&lt;/param&gt;
&apos;@DefaultMember
Public Function Eval(Optional ByRef ValuesToEvalWith As String = vbNullString) As String
    If Not AssignedExpression Then
        Exit Function
    Else
        If GeneratedTree Then
            InitializeErrHandler
            If ValuesToEvalWith &lt;&gt; vbNullString Then
                VariableAssignment ValuesToEvalWith
            End If
            If Not ComputedTree Then
                If Not CheckVarValues Then &apos;Only eval if each variables has its value
                    BuildErrMessage errVariableNotAssigned, &quot;The values of the current variables are: &quot; &amp; CurrentVarValues()
                    Exit Function
                End If
            End If
            On Error GoTo Eval_errHandler
            P_RESULT = Compute()
        End If
    End If
    If P_FORMATRESULT Then &apos;Format: trim [&apos;] chars
        Eval = FormatLiteralString(CStr(P_RESULT), True)
    Else
        Eval = P_RESULT
    End If
    Exit Function
Eval_errHandler:
    P_RESULT = vbNullString
    Eval = P_RESULT
    BuildErrMessage errEvalError, err.Description &amp; &quot;.&quot;
End Function

Private Function EvalFunction(ByRef Argument As String, ByRef FunctionName As String, Optional IsUDF As Boolean = False) As String
    On Error GoTo EvalFunction_errHandler
    If Not IsUDF Then
        Select Case FunctionName
            Case &quot;Absolute&quot;
                EvalFunction = Absolute(Argument, FunctionName)
            Case &quot;ACHISQ&quot;
                EvalFunction = ACHISQ(Argument, FunctionName)
            Case &quot;AERF&quot;
                EvalFunction = AERF(Argument, FunctionName)
            Case &quot;AGAUSS&quot;
                EvalFunction = AGAUSS(Argument, FunctionName)
            Case &quot;AFISHF&quot;
                EvalFunction = AFISHF(Argument, FunctionName)
            Case &quot;ANORM&quot;
                EvalFunction = anorm(Argument, FunctionName)
            Case &quot;ArcSin&quot;
                EvalFunction = ArcSin(Argument, FunctionName)
            Case &quot;ArcCos&quot;
                EvalFunction = ArcCos(Argument, FunctionName)
            Case &quot;ArcTan&quot;
                EvalFunction = ArcTan(Argument, FunctionName)
            Case &quot;ASTUDT&quot;
                EvalFunction = ASTUDT(Argument, FunctionName)
            Case &quot;strArray&quot;
                EvalFunction = Array_(Argument, FunctionName)
            Case &quot;ASCII&quot;
                EvalFunction = Asc_(Argument, FunctionName)
            Case &quot;Average&quot;
                EvalFunction = average(Argument, FunctionName)
            Case &quot;Beta_Distribution&quot;
            	EvalFunction = BETADIST(Argument, FunctionName)
            Case &quot;BETAINV&quot;
                EvalFunction = BETAINV(Argument, FunctionName)
            Case &quot;Bisector&quot;
            	EvalFunction = AngleSegmentBisector(Argument, FunctionName)
            Case &quot;Circumcircle&quot;
            	EvalFunction = Circumcircle(Argument, FunctionName)
            Case &quot;CircleTangents&quot;
            	EvalFunction = CircleTangents(Argument, FunctionName)
            Case &quot;Cosin&quot;
                EvalFunction = Cosin(Argument, FunctionName)
            Case &quot;CHISQ&quot;
                EvalFunction = CHISQ(Argument, FunctionName)
            Case &quot;CholeskyDec&quot;
                EvalFunction = CholeskyDecomposition(Argument, FunctionName)
            Case &quot;CholeskyInverseMatrix&quot;
                EvalFunction = CholeskyInverseMatrix(Argument, FunctionName)
            Case &quot;CholeskySolve&quot;
                EvalFunction = CholeskySolve(Argument, FunctionName)
            Case &quot;aChoose&quot;
                EvalFunction = Choose(Argument, FunctionName)
            Case &quot;ASCIIchr&quot;
                EvalFunction = Chr_(Argument, FunctionName)
            Case &quot;aCeiling&quot;
                EvalFunction = aCeiling(Argument, FunctionName)
            Case &quot;aDate&quot;
                EvalFunction = Date_(Argument, FunctionName)
            Case &quot;aDateAdd&quot;
                EvalFunction = DateAdd_(Argument, FunctionName)
            Case &quot;aDateDiff&quot;
                EvalFunction = DateDiff_(Argument, FunctionName)
            Case &quot;aDatePart&quot;
                EvalFunction = DatePart_(Argument, FunctionName)
            Case &quot;aDateSerial&quot;
                EvalFunction = DateSerial_(Argument, FunctionName)
            Case &quot;aDateValue&quot;
                EvalFunction = DateValue_(Argument, FunctionName)
            Case &quot;aDay&quot;
                EvalFunction = Day_(Argument, FunctionName)
            Case &quot;aDDB&quot;
                EvalFunction = DDB_(Argument, FunctionName)
            Case &quot;Distance&quot;
            	EvalFunction = Distance(Argument, FunctionName)
            Case &quot;MatrixDeterminant&quot;
                EvalFunction = Determinant(Argument, FunctionName)
            Case &quot;ERF&quot;
                EvalFunction = ERF(Argument, FunctionName)
            Case &quot;ExpEuler&quot;
                EvalFunction = ExpEuler(Argument, FunctionName)
            Case &quot;FISHF&quot;
                EvalFunction = FISHF(Argument, FunctionName)
            Case &quot;CurveFit&quot;
                EvalFunction = Fit(Argument, FunctionName)
            Case &quot;aFloor&quot;
                EvalFunction = aFloor(Argument, FunctionName)
            Case &quot;aFormat&quot;
                EvalFunction = Format_(Argument, FunctionName)
            Case &quot;aFV&quot;
                EvalFunction = FV_(Argument, FunctionName)
            Case &quot;FunctionZero&quot;
                EvalFunction = Zero(Argument, FunctionName)
            Case &quot;Gamma&quot;
                EvalFunction = tGamma(Argument, FunctionName)
            Case &quot;GammaLN&quot;
                EvalFunction = GAMMALN(Argument, FunctionName)
            Case &quot;GAUSS&quot;
                EvalFunction = GAUSS(Argument, FunctionName)
            Case &quot;GET&quot;
                EvalFunction = GETS(Argument, FunctionName)
            Case &quot;GetFromList&quot;
            	EvalFunction = GetFromList(Argument, FunctionName)
            Case &quot;aHour&quot;
                EvalFunction = Hour_(Argument, FunctionName)
            Case &quot;iBETA&quot;
                EvalFunction = iBETA(Argument, FunctionName)
            Case &quot;aIff&quot;
                EvalFunction = Iff_(Argument, FunctionName)
            Case &quot;Incenter&quot;
            	EvalFunction = Incenter(Argument, FunctionName)
            Case &quot;Incircle&quot;
            	EvalFunction = Incircle(Argument, FunctionName)
            Case &quot;aInstr&quot;
                EvalFunction = InStr_(Argument, FunctionName)
            Case &quot;InverseMatrix&quot;
                EvalFunction = InverseMatrix(Argument, FunctionName)
            Case &quot;aIPMT&quot;
                EvalFunction = IPMT_(Argument, FunctionName)
            Case &quot;aIRR&quot;
                EvalFunction = IRR_(Argument, FunctionName)
            Case &quot;aLeft&quot;
                EvalFunction = Left_(Argument, FunctionName)
            Case &quot;aLen&quot;
                EvalFunction = Len_(Argument, FunctionName)
            Case &quot;LowerCase&quot;
                EvalFunction = LCase_(Argument, FunctionName)
            Case &quot;LinesIntersect&quot;
            	EvalFunction = LinesIntersect(Argument, FunctionName)
            Case &quot;Logarithm&quot;
                EvalFunction = Logarithm(Argument, FunctionName)
            Case &quot;LgN&quot;
                EvalFunction = LgN(Argument, FunctionName)
            Case &quot;LUdecomposition&quot;
                EvalFunction = LUdecomposition(Argument, FunctionName)
            Case &quot;LUSolveLinearSystem&quot;
                EvalFunction = LUsolve(Argument, FunctionName)
            Case &quot;LN&quot;
                EvalFunction = LN(Argument, FunctionName)
            Case &quot;LSQRsolve&quot;
                EvalFunction = LSQRsolve(Argument, FunctionName)
            Case &quot;Max&quot;
                EvalFunction = Max(Argument, FunctionName)
            Case &quot;Middle&quot;
                EvalFunction = Mid_(Argument, FunctionName)
            Case &quot;Min&quot;
                EvalFunction = Min(Argument, FunctionName)
            Case &quot;aMinute&quot;
                EvalFunction = Minute_(Argument, FunctionName)
            Case &quot;aMIRR&quot;
                EvalFunction = MIRR_(Argument, FunctionName)
            Case &quot;MatrixMult&quot;
                EvalFunction = MMult(Argument, FunctionName)
            Case &quot;MultiLinearReg&quot;
                EvalFunction = MLR(Argument, FunctionName)
            Case &quot;MatrixNegation&quot;
                EvalFunction = MNEG(Argument, FunctionName)
            Case &quot;MatrixRound&quot;
                EvalFunction = MROUND(Argument, FunctionName)
            Case &quot;MatrixSum&quot;
                EvalFunction = MSum(Argument, FunctionName)
            Case &quot;MatrixTranspose&quot;
                EvalFunction = MTranspose(Argument, FunctionName)
            Case &quot;aMonthName&quot;
                EvalFunction = MonthName_(Argument, FunctionName)
            Case &quot;aMonth&quot;
                EvalFunction = Month_(Argument, FunctionName)
            Case &quot;NORM&quot;
                EvalFunction = NORM(Argument, FunctionName)
            Case &quot;aNow&quot;
                EvalFunction = Now_(Argument, FunctionName)
            Case &quot;aNPER&quot;
                EvalFunction = NPER_(Argument, FunctionName)
            Case &quot;aNPV&quot;
                EvalFunction = NPV_(Argument, FunctionName)
            Case &quot;ParallelLine&quot;
            	EvalFunction = ParallelLine(Argument, FunctionName)
            Case &quot;Percent&quot;
                EvalFunction = Percent(Argument, FunctionName)
            Case &quot;PerpendicularLine&quot;
            	EvalFunction = PerpendicularLine(Argument, FunctionName)
            Case &quot;aPMT&quot;
                EvalFunction = PMT_(Argument, FunctionName)
            Case &quot;aPPMT&quot;
                EvalFunction = PPMT_(Argument, FunctionName)
            Case &quot;Power&quot;
                EvalFunction = Power(Argument, FunctionName)
            Case &quot;aPV&quot;
                EvalFunction = PV_(Argument, FunctionName)
            Case &quot;QRdecomposition&quot;
                EvalFunction = QRdec(Argument, FunctionName)
            Case &quot;aRATE&quot;
                EvalFunction = RATE_(Argument, FunctionName)
            Case &quot;REM&quot;
                EvalFunction = aREM(Argument, FunctionName)
            Case &quot;aReplace&quot;
                EvalFunction = Replace_(Argument, FunctionName)
            Case &quot;aRight&quot;
                EvalFunction = Right_(Argument, FunctionName)
            Case &quot;ROUND&quot;
                EvalFunction = aROUND(Argument, FunctionName)
            Case &quot;Sign&quot;
                EvalFunction = Sign(Argument, FunctionName)
            Case &quot;Sine&quot;
                EvalFunction = Sine(Argument, FunctionName)
            Case &quot;SolveLinearSystem&quot;
                EvalFunction = solve(Argument, FunctionName)
            Case &quot;aSLN&quot;
                EvalFunction = SLN_(Argument, FunctionName)
            Case &quot;SquareRoot&quot;
                EvalFunction = SquareRoot(Argument, FunctionName)
            Case &quot;SUM&quot;
                EvalFunction = SUM(Argument, FunctionName)
            Case &quot;Tangent&quot;
                EvalFunction = Tangent(Argument, FunctionName)
            Case &quot;STUDT&quot;
                EvalFunction = STUDT(Argument, FunctionName)
            Case &quot;aSwitch&quot;
                EvalFunction = Switch_(Argument, FunctionName)
            Case &quot;aSYD&quot;
                EvalFunction = SYD_(Argument, FunctionName)
            Case &quot;aTimeSerial&quot;
                EvalFunction = TimeSerial_(Argument, FunctionName)
            Case &quot;aTimeValue&quot;
                EvalFunction = TimeValue_(Argument, FunctionName)
            Case &quot;TINV&quot;
                EvalFunction = TINV(Argument, FunctionName)
            Case &quot;TINV_1T&quot;
                EvalFunction = TINV_1T(Argument, FunctionName)
            Case &quot;TINV_2T&quot;
                EvalFunction = TINV_2T(Argument, FunctionName)
            Case &quot;aTrim&quot;
                EvalFunction = Trim_(Argument, FunctionName)
            Case &quot;aUcase&quot;
                EvalFunction = UCase_(Argument, FunctionName)
            Case &quot;aWweekDay&quot;
                EvalFunction = WeekDay_(Argument, FunctionName)
            Case &quot;aWeekDayName&quot;
                EvalFunction = WeekDayName_(Argument, FunctionName)
            Case &quot;aYear&quot;
                EvalFunction = Year_(Argument, FunctionName)
            Case Else &apos;Try to overload variable
                EvalFunction = OverLoadVarName(Argument, FunctionName)
        End Select
    Else
        EvalFunction = EvalUDF(FunctionName, Argument)
    End If
    Exit Function
EvalFunction_errHandler:
    If Not P_ENFORCE_BOOLEAN Then
        EvalFunction = e_ValueError
    Else
        EvalFunction = False
    End If
End Function

Private Function EvalUDF(ByRef UDFname As String, ByRef expression As String) As String
    Dim args As Variant
    Dim tmpEval As String
    Dim UDFidx As Long
    
    UDFidx = GetCBItemIdx(UserDefFunctions, UDFname)
    If UDFidx &gt; -1 Then     &apos;Only declared functions are called
        args = SplitArgs(expression) &apos;Pass a string array to UDF functions
        tmpEval = CallByName(callback(UserDefFunctions.Storage(UDFidx).value), UDFname, VbMethod, args)
        EvalUDF = tmpEval
    End If
End Function

Private Sub ExpandBuffer(ByRef aBuffer As ClusterTree)
    Dim tmpBuffer() As token
	
	aBuffer.Capacity = 2 * (aBuffer.Capacity + 1)
	tmpBuffer = aBuffer.Storage
    ReDim Preserve tmpBuffer(0 To aBuffer.Capacity - 1)
    aBuffer.Storage = tmpBuffer
End Sub

Private Sub ExpandCBbuffer(ByRef aBuffer As ClusterBuffer)
    Dim tmpBuffer() As ClusterItem
	
	aBuffer.Capacity = 2 * (aBuffer.Capacity + 1)
	tmpBuffer = aBuffer.Storage
    ReDim Preserve tmpBuffer(0 To aBuffer.Capacity - 1)
    aBuffer.Storage = tmpBuffer
End Sub

Private Sub ExpandCompositeArg(ByRef outBuffer As ClusterTree, ByRef tmpReplacement As String, _
                            ByRef ExpCopy As String, ByRef tmpArgs() As String, _
                            ByRef taIcounter As Long, ByRef OperationIndex As Long)
    outBuffer.ClusterArrBounds = SplitArrBranch(ExpCopy, tmpArgs)
    If outBuffer.ClusterArrBounds(0) &lt;&gt; -1 Then  &apos;Splitting argument success
        For taIcounter = LBound(tmpArgs) To UBound(tmpArgs)
            GetRootedTree tmpArgs(taIcounter), tmpReplacement, OperationIndex, outBuffer
            AddToMap outBuffer.aindex, outBuffer
        Next taIcounter
        outBuffer.CompCluster = True
        outBuffer.CompArrCluster = True
    Else
        &apos;Todo: Code here for trap error of missing {} in a composite array input
    End If
End Sub

Private Function ExpEuler(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    ExpEuler = CStr(Exp(CDbl(expression)))
    Exit Function
err_Handler:
    ExpEuler = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes factorial by recursion.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt;Value to compute the factorial from.&lt;/param&gt;
Private Function FACT(n As Double) As Double
    Dim r As Double
    Dim pA As Double, pB As Double
    Dim pC As Double, pD As Double
    
    If n = 0 Or n = 1 Then
        FACT = 1: Exit Function
    End If
    If n &lt; 0 Then
        FACT = FACT(n + 1) / (n + 1): Exit Function
    End If
    If n &gt; 1 Then
        FACT = n * FACT(n - 1): Exit Function
    End If
    If n &lt; 0.5 Then
        r = n
    Else
        r = 1 - n
    End If
    pA = -0.009634403818022 + r * (0.007285315490429 + r * -0.001331461501875)
    pB = 0.1665389907228 + r * (-0.042197630554869 + r * pA)
    pC = -0.655878067489187 + r * (-0.042002698827786 + r * pB)
    pD = 0.577215664819072 + r * pC
    r = 1 / (1 + r * pD)
    If n &gt; 0.5 Then
        r = (n * (1 - n) * pi) / (r * Sin(pi * n))
    End If
    FACT = r
End Function

Private Function Factorial(ByRef expression As String) As String
    On Error GoTo err_Handler
    Factorial = CStr(FACT(CDbl(expression)))
    Exit Function
err_Handler:
    Factorial = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; &quot;Factorial&quot; &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Sub FillTokenArgProps(ByRef TokenArg As Argument, Optional OnlySetIndexes As Boolean = False)
    If Not OnlySetIndexes Then
        TokenArg.NegationFlagOn = (strVBA.InStrB(1, TokenArg.DefString, op_neg) = 1) &apos;~*
        TokenArg.funcName = GetFunctionName(TokenArg.DefString)
        TokenArg.UDFFunctionIn = IsUDFFunction
        TokenArg.FunctionIn = (TokenArg.funcName &lt;&gt; vbNullString) _
                                Or TokenArg.UDFFunctionIn
        TokenArg.LinkedIndex = GetIndex(TokenArg.DefString)
        If Not TokenArg.NegationFlagOn Then
            TokenArg.LinkedVar = P_SCOPE.VarIndex(CastCase(TokenArg.DefString))
        Else
            TokenArg.LinkedVar = P_SCOPE.VarIndex(CastCase(strVBA.MidB(TokenArg.DefString, 3)))
        End If
        TokenArg.Implicit = (TokenArg.LinkedIndex &gt;= 0)
        TokenArg.FactorialIn = (strVBA.InStrB(1, TokenArg.DefString, op_Factorial) = strVBA.LenB2(TokenArg.DefString) - 1)
    Else
        TokenArg.LinkedIndex = -1
        TokenArg.LinkedVar = -1
    End If
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the probability value of an F-test, given the F-value,
&apos;&apos;&apos;     numerator degrees of freedom, and denominator degrees of freedom.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;f&quot;&gt;F-value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n1&quot;&gt;Degrees of freedom 1.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n2&quot;&gt;Degrees of freedom 2.&lt;/param&gt;
Private Function FISHF(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = FISHF_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(LB + 1)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    FISHF = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    FISHF = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function FISHF_(f As Double, N1 As Double, N2 As Double) As Double
    Dim x As Double, th As Double
    Dim A As Double, sth As Double
    Dim cth As Double, c As Double
    Dim k As Double
    
    x = N2 / (N1 * f + N2)
    If (REM_(N1, 2) = 0) Then
        FISHF_ = STATCOM(1 - x, N2, N1 + N2 - 4, N2 - 2) * (x ^ (N2 / 2))
        Exit Function
    End If
    If REM_(N2, 2) = 0 Then
        FISHF_ = 1 - STATCOM(x, N1, N1 + N2 - 4, N1 - 2) * ((1 - x) ^ (N1 / 2))
        Exit Function
    End If
    th = Atn(Sqr(N1 * f / N2))
    A = th / PID2: sth = Sin(th): cth = Cos(th)
    If (N2 &gt; 1) Then
        A = A + sth * cth * STATCOM(cth * cth, 2, N2 - 3, -1) / PID2
    End If
    If (N1 = 1) Then FISHF_ = 1 - A: Exit Function
    c = 4 * STATCOM(sth * sth, N2 + 1, N1 + N2 - 4, N2 - 2) * sth * (cth ^ N2) / pi
    If (N2 = 1) Then FISHF_ = 1 - A + c / 2: Exit Function
    k = 2
    Do While (k &lt;= (N2 - 1) / 2)
        c = c * k / (k - 0.5)
        k = k + 1
    Loop
    FISHF_ = 1 - A + c
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Performs a least squares regression curve fitting. The methods requires that the &lt;expression&gt;
&apos;&apos;&apos;     argument be composed of the following:
&apos;&apos;&apos;                     1-) An array in text form containing the observations pairs.
&apos;&apos;&apos;                     2-) An integer value representing the fitting curve type:
&apos;&apos;&apos;                             1 --&gt; Polynomial [y = a + b*x + c*x^2 +...+ m*x^n]
&apos;&apos;&apos;                             2 --&gt; Exponential [y = a*e^(b*x)]
&apos;&apos;&apos;                             3 --&gt; Exponential [y = a*b^x]
&apos;&apos;&apos;                             4 --&gt; Power [y = a*x^b]
&apos;&apos;&apos;                             5 --&gt; Logarithmic [y = a*ln(x) + b]
&apos;&apos;&apos;                     3-) An optional integer value representing the polynomial degree
&apos;&apos;&apos;                         only if Polynomial fitting option is selected
&apos;&apos;&apos;
&apos;&apos;&apos;     The returned value is an like Java array with the form {{POLYNOMIAL};{R-squared VALUE}}
&apos;&apos;&apos; &lt;/summary&gt;
Private Function Fit(ByRef expression As String, ByRef fName As String) As String
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    Dim argsCount As Long
    Dim ObservatiosnArray() As Double
    Dim fittingOption As Long
    Dim pDegree As Long
    Dim fittedPolynomial As String
    Dim solverCoeff As Variant
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            ObservatiosnArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            fittingOption = CLng(tmpData(UB))
            If fittingOption = 1 Then &apos;Fit straight line [y = a + bx]
                pDegree = fittingOption
                fittedPolynomial = PolyFit_(ObservatiosnArray, pDegree)
                tmpEval = d_lCurly &amp; _
                        d_lCurly &amp; fittedPolynomial &amp; d_rCurly &amp; P_SEPARATORCHAR &amp; _
                        d_lCurly &amp; CStr(GoodnessOfFit_(fittedPolynomial, ObservatiosnArray)) &amp; d_rCurly &amp; _
                        d_rCurly
            Else
                solverCoeff = PolyFit_(DataLinearization(ObservatiosnArray, fittingOption), 1, False)
                Select Case fittingOption
                    Case 2 &apos;Exponential [y = a*e^(b*x)]
                        solverCoeff(0, 0) = 10 ^ solverCoeff(0, 0) &apos;antilog_10 (A)
                        solverCoeff(1, 0) = solverCoeff(1, 0) / Log10(Exp(1)) &apos;B/log10(e)
                    Case 3 &apos;Exponential [y = a*b^x]
                        solverCoeff(0, 0) = 10 ^ solverCoeff(0, 0) &apos;antilog_10 (A)
                        solverCoeff(1, 0) = 10 ^ solverCoeff(1, 0) &apos;antilog_10 (B)
                    Case 4 &apos;Power [y = a*x^b]
                        solverCoeff(0, 0) = 10 ^ solverCoeff(0, 0) &apos;antilog_10 (A)
                End Select
                fittedPolynomial = CurveString(solverCoeff, fittingOption)
                tmpEval = d_lCurly &amp; _
                            d_lCurly &amp; fittedPolynomial &amp; d_rCurly &amp; P_SEPARATORCHAR &amp; _
                            d_lCurly &amp; CStr(GoodnessOfFit_(fittedPolynomial, ObservatiosnArray)) &amp; d_rCurly &amp; _
                            d_rCurly
            End If
        Case 3 &apos;polynomial fitting
            fittingOption = CLng(tmpData(LB + 1))
            If fittingOption = 1 Then &apos;Polynomial fitting
                ObservatiosnArray() = ToDblArray(ArrayFromString(tmpData(LB)))
                pDegree = CLng(tmpData(UB))
                fittedPolynomial = PolyFit_(ObservatiosnArray, pDegree)
                tmpEval = d_lCurly &amp; _
                        d_lCurly &amp; fittedPolynomial &amp; d_rCurly &amp; P_SEPARATORCHAR &amp; _
                        d_lCurly &amp; CStr(GoodnessOfFit_(fittedPolynomial, ObservatiosnArray)) &amp; d_rCurly &amp; _
                        d_rCurly
            Else
                tmpEval = e_ValueError
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Fit = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Fit = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Floor(ByRef value As Double) As Double
    Dim tmpResult As Double
    
    tmpResult = Fix(value)
    Floor = tmpResult + ((value &lt;&gt; tmpResult) And (value &lt; 0))
End Function

Private Function FormatEntry(expression As String) As String
    FormatEntry = Replace( _
                            RemoveDupNegation( _
                                ApplyLawOfSigns( _
                                ReconstructLiteralStrings( _
                                expression, Join$(Split(expression, d_Space), vbNullString)))), _
                            &quot;()&quot;, &quot;(&apos;&apos;)&quot;)
End Function

Private Function FormatLiteralString(ByRef aString As String, _
                                        Optional AutoCheckFormating As Boolean = False) As String
    If Not AutoCheckFormating Then
        FormatLiteralString = strVBA.MidB(aString, 3, strVBA.LenB2(aString) - 4)
    Else
        If IsLiteralString(aString) Then
            FormatLiteralString = strVBA.MidB(aString, 3, strVBA.LenB2(aString) - 4)
        Else
            FormatLiteralString = aString
        End If
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Turns predictros literal names to X1;X2;X3 format.
&apos;&apos;&apos;     If there are duplicates, an error will occur.
&apos;&apos;&apos;     The replacement will carry reordering to enforce
&apos;&apos;&apos;     i&lt;=j in all interactions X{i}:X{j}.
&apos;&apos;&apos;
&apos;&apos;&apos;     Usage example:
&apos;&apos;&apos;                     ReplaceNamedPredictors(&quot;&apos;Height;Width&apos;&quot;,&quot;&apos;Height:Width&apos;&quot;)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;strPredictorsNames&quot;&gt;
&apos;&apos;&apos;     The full list of predictors names in &apos;$;$;$&apos; format.
&apos;&apos;&apos;     Here the $ symbol denotre a valid string name
&apos;&apos;&apos; &lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;strPredictorsInterList&quot;&gt;
&apos;&apos;&apos;     A list of predictors relations with the syntax &apos;$#:$#;$#:$#&apos;
&apos;&apos;&apos;     The # symbol denotes relative position of the predictor $ in the
&apos;&apos;&apos;     model.
&apos;&apos;&apos; &lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;namedToNominal&quot;&gt; If True, the named predictors are turned
&apos;&apos;&apos;&apos;    to its nominal representation
&apos;&apos;&apos; &lt;/param&gt;
Private Function FormatNamedPredictors(ByRef strPredictorsNames As String, _
                                        ByRef strPredictorsInterList As String, _
                                        Optional namedToNominal As Boolean = True) As String
    Dim tmpData() As String
    Dim tmpResult As String
    Dim savedPredNames() As String
    Dim s As Long
    Dim n As Long
    Dim i As Long
    
    &apos;Split predictors names
    tmpData = Split(FormatLiteralString(strPredictorsNames, True), P_SEPARATORCHAR)
    n = UBound(tmpData) - LBound(tmpData) + 1
    ReDim savedPredNames(0 To n - 1)
    Do While i &lt; n
        If tmpData(i) &lt;&gt; vbNullString Then
            If Not IsSavedPredictorName(tmpData(i), savedPredNames) Then
                savedPredNames(s) = tmpData(i)
                s = s + 1
            Else &apos;Duplicate predictor name
                Exit Function
            End If
        End If
        i = i + 1
    Loop
    tmpResult = strPredictorsInterList
    For i = 0 To s - 1
        If namedToNominal Then
            tmpResult = Replace(tmpResult, savedPredNames(i), &quot;X&quot; &amp; CStr(i + 1))
        Else
            tmpResult = Replace(tmpResult, &quot;X&quot; &amp; CStr(i + 1), savedPredNames(i))
        End If
    Next i
    Erase tmpData, savedPredNames
    If namedToNominal Then
        FormatNamedPredictors = FormatNumeredInteractions(tmpResult)
    Else
        FormatNamedPredictors = tmpResult
    End If
End Function

Private Function FormatNumeredInteractions(ByRef strPredictorsInterList As String) As String
    Dim i As Long
    Dim n As Long
    Dim e As Long
    Dim f As Long
    Dim u As String
    Dim v As String
    Dim tmpElem As String
    Dim tmpData() As String
    Dim tmpPredict() As String
    
    tmpData = Split(FormatLiteralString(strPredictorsInterList, True), P_SEPARATORCHAR)
    n = UBound(tmpData) - LBound(tmpData) + 1
    For i = 0 To n - 1
        If Not (tmpData(i) Like &quot;[Xx]*#:[Xx]*#&quot;) Then Exit Function
        tmpPredict = Split(tmpData(i), ChrW(58))
        u = strVBA.MidB(tmpPredict(0), 3)
        v = strVBA.MidB(tmpPredict(1), 3)
        If Not IsNumeric(u) Or Not IsNumeric(v) Then Exit Function
        e = CLng(strVBA.MidB(tmpPredict(0), 3))
        f = CLng(v)
        If e &gt; f Then
            tmpElem = tmpPredict(0)
            tmpPredict(0) = tmpPredict(1)
            tmpPredict(1) = tmpElem
            tmpData(i) = Join(tmpPredict, ChrW(58))
        End If
    Next i
    FormatNumeredInteractions = ToLiteralString(Join(tmpData, P_SEPARATORCHAR))
End Function

Private Function Format_(ByRef expression As String, ByRef fName As String) As String
     Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ToLiteralString(tmpData(LB))
        Case 2
            tmpEval = ToLiteralString( _
                                        Format( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                FormatLiteralString(tmpData(UB), True) _
                                                ) _
                                    )
        Case 3
            tmpEval = ToLiteralString( _
                                        Format( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                FormatLiteralString(tmpData(LB + 1), True), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case 4
            tmpEval = ToLiteralString( _
                                        Format( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                FormatLiteralString(tmpData(LB + 1), True), _
                                                CLng(FormatLiteralString(tmpData(LB + 2), True)), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Format_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Format_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function FV_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = FV(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 4
            tmpEval = FV(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = FV(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CLng((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    FV_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    FV_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Finds a zero of a univariate function ussing a modified bisection method.
&apos;&apos;&apos;     aFunction must be a continuous function f(x) for the interval a &lt;= x &lt;= b.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;aFunction&quot;&gt;Inline function.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;a&quot;&gt;Leftmost interval value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;b&quot;&gt;Rightmost interval value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;IncludeVarNames&quot;&gt;Include variable name in result.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;epsilon&quot;&gt;Tolerance (relative error limit).&lt;/param&gt;
Private Function fZeroMBM(ByRef aFunction As String, ByVal A As Double, _
                        ByVal B As Double, Optional includeVarNames As Boolean = True, _
                        Optional epsilon As Double = 0.0000000001) As String
    Dim absFC As Double, absFD As Double
    Dim aZero As Double
    Dim c As Double, d As Double   &apos;Intermediate points |a---:c:----:d:---b|
    Dim evalCounter As Long
    Dim fa As Double, fb As Double
    Dim fc As Double, fd As Double
    Dim fEvalHelper As Object
    Dim i As Long
    Dim k As Double
    Dim segmentLen As Double
    Dim tmpFzeroEval As Double
    Dim tmpResult As Double
    Dim tmpVar() As String
    Dim toleranceFlag As Boolean
    Dim varCounter As Long
    Dim varIdx As Long
    Dim varLB As Long
    
    On Error GoTo fZeroMBM_errHandler
    If A &gt; B Then Exit Function
    Set fEvalHelper = New VBAexpressions
    aZero = 10 * epsilon
    With fEvalHelper
        .Create aFunction
        tmpVar() = Split(.CurrentVariables, &quot;; &quot;)
        varLB = LBound(tmpVar)
        If UBound(tmpVar) - varLB &gt; 0 Then  &apos;Reject multivariate functions
            For i = varLB To UBound(tmpVar)
                If Not IsConstant(tmpVar(i)) Then
                    varCounter = varCounter + 1
                    varIdx = i
                End If
            Next i
            If varCounter &gt; 1 Then
                fZeroMBM = e_ValueError
                Exit Function
            End If
        End If
        k = 0
        &apos;Evaluate the function at a, b
        .LetVarValue(tmpVar(varIdx), A)
        fa = CDbl(.Eval): evalCounter = evalCounter + 1
        .LetVarValue(tmpVar(varIdx), B)
        fb = CDbl(.Eval): evalCounter = evalCounter + 1
        Do
            &apos;Divide the interval into three segments, assumes a &lt; b
            segmentLen = (B - A) / 3
            c = A + segmentLen
            d = B - segmentLen
            &apos;Evaluate the function at c, d
            .LetVarValue(tmpVar(varIdx), c)
            fc = CDbl(.Eval): evalCounter = evalCounter + 1
            .LetVarValue(tmpVar(varIdx), d)
            fd = CDbl(.Eval): evalCounter = evalCounter + 1
            If fc = 0 Or fd = 0 Then
                Exit Do
            End If
            If fa * fc &lt; 0 Then &apos;Root in interval a-c
                B = c
                fb = fc
            ElseIf fc * fd &lt; 0 Then
                A = c
                fa = fc
                B = d
                fb = fd
            ElseIf fd * fb &lt; 0 Then
                A = d
                fa = fd
            Else        &apos;The interval does not satisfy the condition fa*fb&lt;0.
                fZeroMBM = e_ValueError
                GoTo fZeroMBM_terminate
            End If
            absFC = Abs(fc)
            absFD = Abs(fd)
            If absFC &lt; absFD Then
                toleranceFlag = (absFC &gt; epsilon) &apos;: Debug.Print c
            Else
                toleranceFlag = (absFD &gt; epsilon) &apos;: Debug.Print d
            End If
            k = k + 1
        Loop While toleranceFlag And k &lt; 100
        If absFC &lt; absFD Then
            tmpResult = c
            tmpFzeroEval = fc
        Else
            tmpResult = d
            tmpFzeroEval = fd
        End If
        .LetVarValue(tmpVar(varIdx), tmpResult)
        If Round(tmpFzeroEval, Len(CStr(1 / aZero)) - 1) = 0 Then
            If includeVarNames Then
                fZeroMBM = ToLiteralString(.CurrentVarValues)
            Else
                fZeroMBM = tmpResult
            End If
        Else
            fZeroMBM = e_ValueError
        End If
    End With
fZeroMBM_terminate:
    Set fEvalHelper = Nothing
    Exit Function
fZeroMBM_errHandler:
    fZeroMBM = e_ValueError
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Finds a zero of a univariate function ussing a modified regula falsi method.
&apos;&apos;&apos;     aFunction must be a continuous function f(x) for the interval a &lt;= x &lt;= b.
&apos;&apos;&apos;     Credits: A NeamvonK [https://www.ajouronline.com/index.php/AJAS/article/view/2982]
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;aFunction&quot;&gt;Inline function.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;a&quot;&gt;Leftmost interval value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;b&quot;&gt;Rightmost interval value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;epsilon&quot;&gt;Tolerance (relative error limit).&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;IncludeVarNames&quot;&gt;Include variable name in result.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;printDebugINFO&quot;&gt;Print information like iteraction count.&lt;/param&gt;
Private Function fZeroMRF(ByRef aFunction As String, ByVal A As Double, _
                        ByVal B As Double, Optional epsilon As Double = 0.0000000001, _
                        Optional includeVarNames As Boolean = True, _
                        Optional printDebugINFO As Boolean = False) As String
    Dim aZero As Double
    Dim c As Double, d As Double
    Dim evalCounter As Long
    Dim fa As Double, fb As Double
    Dim fc As Double, fd As Double
    Dim fEvalHelper As Object
    Dim i As Long
    Dim k As Double, CK As Double
    Dim tmpVar() As String
    Dim toleranceFlag As Boolean
    Dim varCounter As Long
    Dim varIdx As Long
    Dim varLB As Long
    
    On Error GoTo fZeroMRF_errHandler
    If A &gt; B Then Exit Function
    Set fEvalHelper = New VBAexpressions
    aZero = 10 * epsilon
    With fEvalHelper
        .Create aFunction
        tmpVar() = Split(.CurrentVariables, &quot;; &quot;)
        varLB = LBound(tmpVar)
        If UBound(tmpVar) - varLB &gt; 0 Then  &apos;Reject multivariate functions
            For i = varLB To UBound(tmpVar)
                If Not IsConstant(tmpVar(i)) Then
                    varCounter = varCounter + 1
                    varIdx = i
                End If
            Next i
            If varCounter &gt; 1 Then
                fZeroMRF = e_ValueError
                Exit Function
            End If
        End If
        k = 0
        Do
            &apos;Evaluate the function at a, b
            .LetVarValue(tmpVar(varIdx), A)
            fa = CDbl(.Eval): evalCounter = evalCounter + 1
            .LetVarValue(tmpVar(varIdx), B)
            fb = CDbl(.Eval): evalCounter = evalCounter + 1
            &apos;Compute approximation point of the root
            c = (A * fb - B * fa) / (fb - fa)
            &apos;Evaluate the function at approximation
            .LetVarValue(tmpVar(varIdx), c)
            fc = CDbl(.Eval): evalCounter = evalCounter + 1
            If fa * fc &lt; 0 Then &apos;Root in interval a-c
                &apos;Projection
                CK = Abs(2 * fc / (B - c))
                d = ((1 + CK) * A * fb - B * fa) / ((1 + CK) * fb - fa)
                &apos;Evaluate the function at projection
                .LetVarValue(tmpVar(varIdx), d)
                fd = CDbl(.Eval): evalCounter = evalCounter + 1
                If fd * fa &lt; 0 Then
                    B = d
                Else
                    B = c
                    A = d
                End If
            ElseIf fa * fc &gt; 0 Then
                CK = Abs(0.5 * fc / (B - c))
                d = ((1 + CK) * B * fa - A * fb) / ((1 + CK) * fa - fb)
                .LetVarValue(tmpVar(varIdx), d)
                fd = CDbl(.Eval): evalCounter = evalCounter + 1
                If fd * fa &gt; 0 Then
                    A = d
                Else
                    A = c
                    B = d
                End If
            End If
            toleranceFlag = (Abs(fd) &gt; epsilon)
            k = k + 1
        Loop While toleranceFlag And k &lt; 100
        If Round(fd, Len(CStr(1 / aZero)) - 1) = 0 Then
            If includeVarNames Then
                fZeroMRF = .CurrentVarValues
            Else
                fZeroMRF = d
            End If
        Else
            fZeroMRF = e_ValueError
        End If
    End With
fZeroMRF_terminate:
    Set fEvalHelper = Nothing
    If printDebugINFO Then
        &apos;Debug.Print &quot;fZeroMRF: &quot; &amp; vbCrLf &amp; vbTab &amp; vbTab &amp; &quot;Evaluations:&quot;; evalCounter; &quot;; Iteractions:&quot;; k
    End If
    Exit Function
fZeroMRF_errHandler:
    fZeroMRF = e_ValueError
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the value GAMMA of x from factorial function.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;x&quot;&gt;Value to compute the GAMMA function from.&lt;/param&gt;
Private Function GAMMA(x As Double) As Variant
    GAMMA = FACT(x - 1)
End Function

Private Function GAMMALN(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    GAMMALN = GAMMALN_(CDbl(expression))
    Exit Function
err_Handler:
    GAMMALN = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the natural logarithm of the gamma function.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;x&quot;&gt;Value to compute the GAMMALN function from.&lt;/param&gt;
Private Function GAMMALN_(x As Double) As Double
    Dim j As Long
    Dim cof As Variant
    Dim ser As Double
    Dim xx As Double, y As Double
    Dim tmp As Double

    cof = Array(76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 0.1208650973866179E-2, -0.5395239384953E-5)
    ser = 1.00000000019001
    y = x: xx = x
    tmp = x + 5.5
    tmp = tmp - (xx + 0.5) * Log(tmp)
    For j = LBound(cof) To UBound(cof)
        y = y + 1
        ser = ser + cof(j) / (y)
    Next j
    GAMMALN_ = Log(2.506628274631 * ser / xx) - tmp
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the probability that a member of a standard normal population
&apos;&apos;&apos;     will fall between the mean and z standard deviations from the mean.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html) with adjustment specified in
&apos;&apos;&apos;     https://support.microsoft.com/en-us/office/gauss-function-069f1b4e-7dee-4d6a-a71f-4b69044a6b33
&apos;&apos;&apos;     The result is 0.5 off from the cumulative distribution function (CDF) for the standard normal
&apos;&apos;&apos;     given the upper limit of integration z. So CDF (mean:=0, sd:=1, z) = GAUSS(z) + 0.5
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;z&quot;&gt;Standard deviations from the mean.&lt;/param&gt;
Private Function GAUSS(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = GAUSS_( _
                            CDbl(tmpData(LB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    GAUSS = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    GAUSS = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function GAUSS_(z As Double) As Double
    If (z &lt; 0) Then
        If (z &lt; -10) Then
            GAUSS_ = 0
        Else
            GAUSS_ = CHISQ_(z * z, 1) / 2
        End If
    Else
        If (z &gt; 10) Then
            GAUSS_ = 1
        Else
            GAUSS_ = 1 - CHISQ_(z * z, 1) / 2
        End If
    End If
    GAUSS_ = GAUSS_ - 0.5
End Function

Private Function get2DimArrayCopy(ByRef bArray() As Double) As Variant
    Dim tmpResult() As Double
    Dim isArray2D As Boolean
    Dim colDim As Long
    Dim i As Long, j As Long
    Dim LB As Long, UB As Long
    Dim LB2 As Long, UB2 As Long
    
    isArray2D = Is2Darray(bArray)
    UB = UBound(bArray)
    LB = LBound(bArray)
    If isArray2D Then
        UB2 = UBound(bArray, 2)
        LB2 = LBound(bArray, 2)
        colDim = UB2 - LB2
    End If
    ReDim tmpResult(0 To UB - LB, 0 To colDim)
    If isArray2D Then
        For i = LB To UB
            For j = LB2 To UB2
                tmpResult(0 + i - LB, 0 + j - LB2) = bArray(i, j)
            Next j
        Next i
    Else
        For i = LB To UB
            tmpResult(0 + i - LB, 0) = bArray(i)
        Next i
    End If
    get2DimArrayCopy = tmpResult
End Function

Private Function GetArithOpInfo(ByRef expression As String) As TokenInfo
    Dim PowerSymbolPos As Long
    Dim MultSymbolPos As Long
    Dim ModSymbolPos As Long
    Dim DivSymbolPos As Long
    Dim IntDivSymbolPos As Long
    Dim AddSymbolPos As Long
    Dim SubtSymbolPos As Long
    Dim tmpPos As Long
    Dim tmpStr As String
    Dim tmpTestChr As String
    Dim tmpResult As TokenInfo
    
    Set tmpResult = New TokenInfo
    PowerSymbolPos = GetPowerSymbolPos(expression)
    If PowerSymbolPos Then                              &apos;Powers first
        tmpResult.Position = PowerSymbolPos
        tmpResult.OperationToken = otPower
        tmpResult.OperatorLen = strVBA.LenB2(op_power)
    Else
        MultSymbolPos = GetOPeratorSymbolPos(expression, op_mult)
        DivSymbolPos = GetOPeratorSymbolPos(expression, op_div)
        IntDivSymbolPos = GetOPeratorSymbolPos(expression, op_intDiv)
        ModSymbolPos = GetOPeratorSymbolPos(expression, op_mod)
        If NonZero(MultSymbolPos, DivSymbolPos, ModSymbolPos, IntDivSymbolPos) Then
            tmpResult.Position = MinNonZero(MultSymbolPos, DivSymbolPos, ModSymbolPos, IntDivSymbolPos)    &apos;Priority to the first operator
            Select Case tmpResult.Position
                Case MultSymbolPos
                    tmpResult.OperationToken = otMultiplication
                    tmpResult.OperatorLen = strVBA.LenB2(op_mult)
                Case DivSymbolPos
                    tmpResult.OperationToken = otDivision
                    tmpResult.OperatorLen = strVBA.LenB2(op_div)
                Case IntDivSymbolPos
                    tmpResult.OperationToken = otIntDiv
                    tmpResult.OperatorLen = strVBA.LenB2(op_intDiv)
                Case Else
                    tmpResult.OperationToken = otMod
                    tmpResult.OperatorLen = strVBA.LenB2(op_mod)
            End Select
        Else                                               &apos;Addition and subtraction
            AddSymbolPos = GetOPeratorSymbolPos(expression, op_plus)
            If AddSymbolPos = 1 Then                       &apos;Unary symbol
                AddSymbolPos = GetOPeratorSymbolPos(expression, op_plus, AddSymbolPos + 2)
            End If
            If AddSymbolPos Then
                tmpPos = AddSymbolPos - 2
                Do While tmpPos &gt;= 1 And AddSymbolPos &gt; 0  &apos;Skip symbol in functions like [{func+arg}]
                    tmpTestChr = strVBA.MidB(expression, tmpPos, 2)
                    If IsLetter(tmpTestChr) Then
                        Do
                            tmpPos = tmpPos - 2
                            If tmpPos = 1 Then
                                Exit Do
                            Else
                                If tmpPos &lt; 1 Then
                                    tmpPos = 1
                                    Exit Do
                                End If
                            End If
                            tmpTestChr = strVBA.MidB(expression, tmpPos, 2)
                        Loop While IsLetter(tmpTestChr)
                        If tmpPos &gt; 1 Then
                            tmpPos = tmpPos + 2
                        End If
                        tmpStr = strVBA.MidB(expression, tmpPos, AddSymbolPos - tmpPos)
                        If GetFunctionName(tmpStr) &lt;&gt; vbNullString Or tmpStr = &quot;E&quot; Then
                            AddSymbolPos = GetOPeratorSymbolPos(expression, op_plus, AddSymbolPos + 2)
                        Else
                            Exit Do
                        End If
                    Else
                        Exit Do
                    End If
                Loop
            End If
            SubtSymbolPos = GetOPeratorSymbolPos(expression, op_minus)
            If SubtSymbolPos = 1 Then
                SubtSymbolPos = GetOPeratorSymbolPos(expression, op_minus, SubtSymbolPos + 2)
            End If
            If SubtSymbolPos Then
                tmpPos = SubtSymbolPos - 2
                Do While tmpPos &gt;= 1 And SubtSymbolPos &gt; 0 &apos;Skip symbol in functions like [{func-arg}]
                    tmpTestChr = strVBA.MidB(expression, tmpPos, 2)
                    If IsLetter(tmpTestChr) Then
                        Do
                            tmpPos = tmpPos - 2
                            If tmpPos = 1 Then
                                Exit Do
                            Else
                                If tmpPos &lt; 1 Then
                                    tmpPos = 1
                                    Exit Do
                                End If
                            End If
                            tmpTestChr = strVBA.MidB(expression, tmpPos, 2)
                        Loop While IsLetter(tmpTestChr)
                        If tmpPos &gt; 1 Then
                            tmpPos = tmpPos + 2
                        End If
                        tmpStr = strVBA.MidB(expression, tmpPos, SubtSymbolPos - tmpPos)
                        If GetFunctionName(tmpStr) &lt;&gt; vbNullString Or tmpStr = &quot;E&quot; Then
                            SubtSymbolPos = GetOPeratorSymbolPos(expression, op_minus, SubtSymbolPos + 2)
                        Else
                            Exit Do
                        End If
                    Else
                        Exit Do
                    End If
                Loop
            End If
            If NonZero(AddSymbolPos, SubtSymbolPos) Then
                tmpResult.Position = MinNonZero(AddSymbolPos, SubtSymbolPos)     &apos;Priority to the first operator
                Select Case tmpResult.Position
                    Case AddSymbolPos
                        tmpResult.OperationToken = otSum
                        tmpResult.OperatorLen = strVBA.LenB2(op_plus)
                    Case Else
                        tmpResult.OperationToken = otDiff
                        tmpResult.OperatorLen = strVBA.LenB2(op_minus)
                End Select
            Else                        &apos;Missing opetaration symbol.
                tmpResult.Position = -1        &apos;Return a out of bound value
            End If
        End If
    End If
    Set GetArithOpInfo = tmpResult 
End Function

Private Function GetArrItm(ByRef arr As Variant, ByRef MultiDimArr As Boolean, _
                            ByRef JaggedArray As Boolean, ByRef IdxDim1 As Long, _
                            ByRef IdxDim2 As Long) As String
    If MultiDimArr Then
        GetArrItm = CStr(arr(IdxDim1, IdxDim2))
    Else
        If JaggedArray Then
            GetArrItm = CStr(arr(IdxDim1)(IdxDim2))
        Else
            GetArrItm = CStr(arr(IdxDim2))
        End If
    End If
End Function

Private Function GetCBItemIdx(ByRef cbBuffer As ClusterBuffer, ByRef ItemName As String) As Long
    Dim i As Long
    Dim tmpResult As Boolean
    Dim tmpItemName As String
    
    If strVBA.LenB2(ItemName) Then
        Select Case AscW(ItemName)
            Case 43, 45 &apos;Unary expression
                tmpItemName = strVBA.MidB(ItemName, 3)
            Case Else
                tmpItemName = ItemName
        End Select
        If cbBuffer.aindex &gt; -1 Then
            i = 0
            Do
                tmpResult = (cbBuffer.Storage(i).aName = tmpItemName)
                i = i + 1
            Loop While i &lt;= cbBuffer.aindex And Not tmpResult
        End If
        If tmpResult Then
            GetCBItemIdx = i - 1
        Else
            GetCBItemIdx = -1
        End If
    Else
        GetCBItemIdx = -1
    End If
End Function

Private Function GetEvalToken(ByRef expression As String) As token
    Dim TokenStart As Long
    Dim TokenEnd As Long
    Dim TokenDet As TokenInfo
    Dim tmpArgs() As String
    Dim tmpResult As token
    
    Set tmpResult = New token 
    Set TokenDet = GetTokenInfo(expression)
    If TokenDet.Position &gt; 2 Then
        &apos;@--------------------------------------------------------------------
        &apos; Delimit token
        GetTokenStart expression, TokenDet.Position, TokenStart
        GetTokenEnd expression, TokenDet.Position, TokenDet.OperatorLen, TokenEnd
        tmpResult.DefString = strVBA.MidB(expression, TokenStart, TokenEnd - TokenStart + 2)
        tmpResult.OperationToken = TokenDet.OperationToken
        SplitToken tmpResult.DefString, tmpArgs, tmpResult.OperationToken
        tmpResult.Logical = TokenDet.LogicalToken
        &apos;@--------------------------------------------------------------------
        &apos; Define arguments
        tmpResult.Arg1.DefString = tmpArgs(LBound(tmpArgs))
        tmpResult.Arg2.DefString = tmpArgs(UBound(tmpArgs))
        &apos;@--------------------------------------------------------------------
        &apos; Fill arguments data
        FillTokenArgProps tmpResult.Arg1
        FillTokenArgProps tmpResult.Arg2
    Else            &apos;Retun values
        tmpResult.DefString = expression
        tmpResult.OperationToken = otNull
        tmpResult.Logical = TokenDet.LogicalToken
        &apos;@--------------------------------------------------------------------
        &apos; Define argument
        tmpResult.Arg1.DefString = expression
        &apos;@--------------------------------------------------------------------
        &apos; Fill argument data
        FillTokenArgProps tmpResult.Arg1
        FillTokenArgProps tmpResult.Arg2, True
    End If
    Set GetEvalToken = tmpResult
End Function

Private Function GetFunctionName(ByRef expression As String) As String
    Dim EFjCounter As Long
    Dim GFNbool As Boolean
    Dim ExpCopy As String
    Dim tmpPos As Long
    
    ExpCopy = Replace(Replace( _
        						LCase$(expression),d_lSquareB,d_lCurly,1), _
        						d_rSquareB,d_rCurly,1) &apos;Bypass LO Basic LIKE OP limitation 
    For EFjCounter = LBound(FunctionsId) To UBound(FunctionsId)
        tmpPos = strVBA.InStrB(1, ExpCopy, FunctionsId(EFjCounter))
        If tmpPos Then
        	If ExpCopy = FunctionsId(EFjCounter) Or _
                    (ExpCopy Like (FunctionsId(EFjCounter) &amp; &quot;{*}&quot;)) Then
                GFNbool = ValidFuntionName(ExpCopy, FunctionsId(EFjCounter), tmpPos)
                If GFNbool Then
                    Exit For
                End If
            End If
        End If
    Next EFjCounter
    If GFNbool Then
        GetFunctionName = FunctionsName(EFjCounter)
        IsUDFFunction = False
    Else &apos;Check for UDFs
        Dim i As Long
        For i = 0 To UserDefFunctions.aindex
            tmpPos = strVBA.InStrB(1, ExpCopy, UserDefFunctions.Storage(i).aName)
            If tmpPos Then
            	If ExpCopy = UserDefFunctions.Storage(I).aname Or _
                        (ExpCopy Like (UserDefFunctions.Storage(I).aname &amp; &quot;{*}&quot;)) Then
                    GFNbool = ValidFuntionName(ExpCopy, UserDefFunctions.Storage(I).aname, tmpPos)
                    If GFNbool Then
                        Exit For
                    End If
                End If
            End If
        Next i
        IsUDFFunction = GFNbool
        If GFNbool Then
            GetFunctionName = UserDefFunctions.Storage(i).aName
        Else
            If (ExpCopy Like &quot;[A-Za-z]*{*}&quot;) Then &apos;Not defined function bypass
                tmpPos = strVBA.InStrB(1, expression, d_lSquareB)
                GetFunctionName = strVBA.MidB(expression, 1, tmpPos - 1)
            End If
        End If
    End If
End Function

Private Function GetIndex(ByRef SubstStr As String) As Long
    Dim InitPos As Long
    Dim EndPos As Long
    
    InitPos = strVBA.InStrB(1, SubstStr, d_lSquareB)
    If InitPos Then
        EndPos = strVBA.InStrB(1, SubstStr, d_rSquareB)
        If EndPos Then
            GetIndex = strVBA.MidB(SubstStr, InitPos + 2, EndPos - InitPos - 2)
        Else
            GetIndex = -1
        End If
    Else
        GetIndex = -1
    End If
End Function

Private Function GetLCOpInfo(ByRef expression As String) As TokenInfo
    Dim NotEqualSymbolPos As Long
    Dim GreatterOrEqualSymbolPos As Long
    Dim LessOrEqualSymbolPos As Long
    Dim EqualSymbolPos As Long
    Dim EqualSymbolPos_ As Long
    Dim LessThanSymbolPos As Long
    Dim GreatterThanSymbolPos As Long
    Dim LogANDSymbolPos As Long
    Dim LogORSymbolPos As Long
    Dim LogXORSymbolPos As Long
    Dim LikeSymbolPos As Long
    Dim testChar As String
    Dim testChar2 As String
    Dim tmpResult As TokenInfo
    
    Set tmpResult = New TokenInfo
    &apos;@--------------------------------------------------------------------
    &apos; Comparisons first
    Do &apos;Discard false positives
        EqualSymbolPos = GetOPeratorSymbolPos(expression, op_equal, EqualSymbolPos + 1)
        If EqualSymbolPos &gt; 2 Then
            testChar = strVBA.MidB(expression, EqualSymbolPos - 2, 2)
            testChar2 = strVBA.MidB(expression, EqualSymbolPos + 2, 2) &apos;Check ahead for &quot;==&quot;
        Else
            testChar = vbNullString
            testChar2 = vbNullString
        End If
    Loop While EqualSymbolPos &gt; 0 And ((testChar Like &quot;[&lt;&gt;=]&quot;) Or (testChar2 = op_equal))
    EqualSymbolPos_ = GetOPeratorSymbolPos(expression, op_equal_)
    NotEqualSymbolPos = GetOPeratorSymbolPos(expression, op_inequality)
    Do
        GreatterThanSymbolPos = GetOPeratorSymbolPos(expression, op_gt, GreatterThanSymbolPos + 1)
        If GreatterThanSymbolPos Then
            testChar = strVBA.MidB(expression, GreatterThanSymbolPos + 2, 2)
        Else
            testChar = vbNullString
        End If
    Loop While GreatterThanSymbolPos &gt; 0 And testChar = op_equal
    Do
        LessThanSymbolPos = GetOPeratorSymbolPos(expression, op_lt, LessThanSymbolPos + 1)
        If LessThanSymbolPos Then
            testChar = strVBA.MidB(expression, LessThanSymbolPos + 2, 2)
        Else
            testChar = vbNullString
        End If
    Loop While LessThanSymbolPos &gt; 0 And testChar = op_equal
    GreatterOrEqualSymbolPos = GetOPeratorSymbolPos(expression, op_gtequal)
    LessOrEqualSymbolPos = GetOPeratorSymbolPos(expression, op_ltequal)
    LikeSymbolPos = strVBA.InStrB(LessThanSymbolPos + 1, expression, op_like)
    If NonZero(EqualSymbolPos, EqualSymbolPos_, NotEqualSymbolPos, GreatterThanSymbolPos, _
                LessThanSymbolPos, GreatterOrEqualSymbolPos, LessOrEqualSymbolPos, LikeSymbolPos) Then
        tmpResult.Position = MinNonZero(EqualSymbolPos, EqualSymbolPos_, NotEqualSymbolPos, GreatterThanSymbolPos, _
                                    LessThanSymbolPos, GreatterOrEqualSymbolPos, LessOrEqualSymbolPos, _
                                    LikeSymbolPos)                                                         &apos;Priority to the first operator
        Select Case tmpResult.Position
            Case EqualSymbolPos
                tmpResult.OperationToken = otEqual
                tmpResult.OperatorLen = strVBA.LenB2(op_equal)
            Case EqualSymbolPos_
                tmpResult.OperationToken = otEqual_
                tmpResult.OperatorLen = strVBA.LenB2(op_equal_)
            Case NotEqualSymbolPos
                tmpResult.OperationToken = otNotEqual
                tmpResult.OperatorLen = strVBA.LenB2(op_inequality)
            Case GreatterThanSymbolPos
                tmpResult.OperationToken = otGreaterThan
                tmpResult.OperatorLen = strVBA.LenB2(op_gt)
            Case LessThanSymbolPos
                tmpResult.OperationToken = otLessThan
                tmpResult.OperatorLen = strVBA.LenB2(op_lt)
            Case GreatterOrEqualSymbolPos
                tmpResult.OperationToken = otGreaterThanOrEqual
                tmpResult.OperatorLen = strVBA.LenB2(op_gtequal)
            Case LessOrEqualSymbolPos
                tmpResult.OperationToken = otLessThanOrEqual
                tmpResult.OperatorLen = strVBA.LenB2(op_ltequal)
            Case LikeSymbolPos
                tmpResult.OperationToken = otLike
                tmpResult.OperatorLen = strVBA.LenB2(op_like)
            End Select
        &apos;@--------------------------------------------------------------------
        &apos; LogicalOperators
        Else
            &apos;@--------------------------------------------------------------------
            &apos; Check the expression giving higher precedence to AND, XOR
            LogANDSymbolPos = GetOPeratorSymbolPos(expression, op_and, LogANDSymbolPos + 1)
            If NonZero(LogANDSymbolPos) Then
                tmpResult.Position = LogANDSymbolPos
                tmpResult.OperationToken = otLogicalAND
                tmpResult.OperatorLen = strVBA.LenB2(op_and)
            Else
                LogXORSymbolPos = GetOPeratorSymbolPos(expression, op_xor, LogXORSymbolPos + 1)
                If NonZero(LogXORSymbolPos) Then
                    tmpResult.Position = LogXORSymbolPos
                    tmpResult.OperationToken = otLogicalXOR
                    tmpResult.OperatorLen = strVBA.LenB2(op_xor)
                Else
                    Do &apos;Discard false positives: &quot;||&quot;
                        LogORSymbolPos = GetOPeratorSymbolPos(expression, op_or, LogORSymbolPos + 1)
                        If LogORSymbolPos Then
                            testChar = strVBA.MidB(expression, LogORSymbolPos + 2, 2)
                        Else
                            testChar = vbNullString
                        End If
                    Loop While LogORSymbolPos &gt; 0 And testChar = op_or
                    If NonZero(LogORSymbolPos) Then
                        tmpResult.Position = LogORSymbolPos
                        tmpResult.OperationToken = otLogicalOR
                        tmpResult.OperatorLen = strVBA.LenB2(op_or)
                    Else                        &apos;Missing opetaration symbol.
                        tmpResult.Position = -1        &apos;Return a out of bound value
                    End If
                End If
            End If
        End If
	Set GetLCOpInfo = tmpResult
End Function

Private Function GetLogicalNeg(ByRef aToken As token) As Variant
    Dim tmpBoolArr(0 To 1) As Boolean
    
    If aToken.Arg1.NegationFlagOn Then
        tmpBoolArr(0) = Not CBool(strVBA.MidB(aToken.Arg1.Operand, 3))
    Else
        tmpBoolArr(0) = CBool(aToken.Arg1.Operand)
    End If
    If aToken.Arg2.NegationFlagOn Then
        tmpBoolArr(1) = Not CBool(strVBA.MidB(aToken.Arg2.Operand, 3))
    Else
        tmpBoolArr(1) = CBool(aToken.Arg2.Operand)
    End If
    GetLogicalNeg = tmpBoolArr
End Function

Private Function GetLiteralStringGap(startPos As Long, ByRef expression As String) As Variant
    Dim literalStrGap() As Long
    Dim tmpPos1 As Long
    Dim tmpPos2 As Long
    Dim tmpPos As Long
    Dim markerChr As String
    ReDim literalStrGap(0 To 1)
    
    tmpPos1 = InStr(startPos, expression, d_Apostrophe)
    tmpPos2 = InStr(startPos, expression, d_Underscore)
    If tmpPos1 &lt;= tmpPos2 Then &apos;Leftmost one
        tmpPos = tmpPos1
        markerChr = d_Apostrophe
    Else
        tmpPos = tmpPos2
        markerChr = d_Underscore
    End If
    If tmpPos Then
        literalStrGap(0) = tmpPos
        literalStrGap(1) = InStr(tmpPos + 1, expression, markerChr)
    End If
    GetLiteralStringGap = literalStrGap
End Function

Private Function GetLParentPos(ByRef expression As String, ByRef RelativePosition As Long) As Long
    Dim tmpCounter As Long
    Dim SearchIndex As Long
    Dim OpenedP As Long
    Dim tmpResult As Long
    Dim literalStrGap As Variant
    Dim foundLiteralStrGap As Boolean
    
    literalStrGap = GetLiteralStringGap(1, expression)
    foundLiteralStrGap = (literalStrGap(0) &gt; 0 And literalStrGap(1) &gt; 0)
    OpenedP = strVBA.InStrB(1, expression, d_lParenthesis)
    If foundLiteralStrGap Then
        Do While OpenedP And (OpenedP &gt; literalStrGap(0) * 2 _
                                And OpenedP &lt; literalStrGap(1) * 2)
            OpenedP = strVBA.InStrB(1, expression, d_lParenthesis)
        Loop
    End If
    Do While tmpCounter &lt; RelativePosition
        tmpCounter = tmpCounter + 1
        SearchIndex = OpenedP + 2
        If SearchIndex &gt; literalStrGap(1) * 2 And foundLiteralStrGap Then
            literalStrGap = GetLiteralStringGap(1, expression)
            foundLiteralStrGap = (literalStrGap(0) &gt; 0 And literalStrGap(1) &gt; 0)
        End If
        If Not (OpenedP &gt; literalStrGap(0) * 2 And OpenedP &lt; literalStrGap(1) * 2) Then
            tmpResult = OpenedP
        End If
        OpenedP = strVBA.InStrB(SearchIndex, expression, d_lParenthesis)
    Loop
    GetLParentPos = tmpResult
End Function

Private Sub GetOperand(ByRef CurArg As Argument, _
                        ByRef CurTree As ClusterTree, _
                        ByRef BaseIndex As Long)
                                    
    If CurArg.Implicit Then
        If CurArg.FunctionIn Then &apos;Implicit function
            If CurArg.FactorialIn Then
                If CurArg.LinkedIndex &gt;= BaseIndex Then &apos;Data on current tree
                    CurArg.Operand = Factorial(EvalFunction(CurTree.Storage(CurArg.LinkedIndex - BaseIndex).EvalResult, _
                                        CurArg.funcName, CurArg.UDFFunctionIn))
                Else &apos;Data is main tree
                    CurArg.Operand = Factorial(EvalFunction(EvalTree(CurArg.LinkedIndex).EvalResult, _
                                        CurArg.funcName, CurArg.UDFFunctionIn))
                End If
            Else &apos;Eval
                If CurArg.LinkedIndex &gt;= BaseIndex Then
                    CurArg.Operand = EvalFunction(CurTree.Storage(CurArg.LinkedIndex - BaseIndex).EvalResult, _
                                        CurArg.funcName, CurArg.UDFFunctionIn)
                Else
                    CurArg.Operand = EvalFunction(EvalTree(CurArg.LinkedIndex).EvalResult, _
                                        CurArg.funcName, CurArg.UDFFunctionIn)
                End If
            End If
        Else    &apos;Return data
            If CurArg.LinkedIndex &gt;= BaseIndex Then
                If CurArg.FactorialIn Then
                    CurArg.Operand = Factorial(CurTree.Storage(CurArg.LinkedIndex - BaseIndex).EvalResult)
                Else
                    CurArg.Operand = CurTree.Storage(CurArg.LinkedIndex - BaseIndex).EvalResult
                End If
            Else
                If CurArg.FactorialIn Then
                    CurArg.Operand = Factorial(EvalTree(CurArg.LinkedIndex).EvalResult)
                Else
                    CurArg.Operand = EvalTree(CurArg.LinkedIndex).EvalResult
                End If
            End If
        End If
        If AscW(CurArg.DefString) = 45 Then
            CurArg.Operand = ApplyLawOfSigns(op_minus + CurArg.Operand)
        End If
    Else     &apos;Explicit function or data
        If CurArg.LinkedVar &gt; -1 Then     &apos;Variable substitution
            If CurArg.FactorialIn Then            &apos;Operate factorials
                CurArg.Operand = Factorial(P_SCOPE.GetVarValue(CurArg.LinkedVar))
            Else
                CurArg.Operand = P_SCOPE.GetVarValue(CurArg.LinkedVar)
            End If
            If AscW(CurArg.DefString) = 45 Then
                CurArg.Operand = ApplyLawOfSigns(op_minus + CurArg.Operand)
            End If
        Else
            If CurArg.FactorialIn Then
                CurArg.Operand = Factorial(strVBA.MidB(CurArg.DefString, 1, strVBA.LenB2(CurArg.DefString) - 2))
            Else
                CurArg.Operand = CurArg.DefString
            End If
        End If
    End If
End Sub

Private Sub GetOperands(ByRef CurToken As token, ByRef CurTree As ClusterTree, _
                                    ByRef BaseIndex As Long)
                                    
    &apos;@--------------------------------------------------------------------
    &apos; Get the first operand
    GetOperand CurToken.Arg1, CurTree, BaseIndex
    &apos;@--------------------------------------------------------------------
    &apos; Get the second operand if required
    If Not CurToken.OperationToken = otNull Then
        GetOperand CurToken.Arg2, CurTree, BaseIndex
    End If
End Sub

Private Function GetOPeratorSymbolPos(ByRef expression As String, _
                                    ByRef OperatorSymbol As String, _
                                    Optional StartPosition As Long = 1) As Long
    Dim tmpResult As Long
    
    tmpResult = strVBA.InStrB(StartPosition, expression, OperatorSymbol)
    Do While IsSymbolInLiteralString(expression, tmpResult) And tmpResult
        tmpResult = strVBA.InStrB(tmpResult + strVBA.LenB2(OperatorSymbol), expression, OperatorSymbol)
    Loop
    GetOPeratorSymbolPos = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Gets the operator given an operator token.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function GetOpSymbol(ByRef OPtoken As OperatorToken) As String
    Select Case OPtoken
        Case otSum
            GetOpSymbol = op_plus
        Case otDiff
            GetOpSymbol = op_minus
        Case otMultiplication
            GetOpSymbol = op_mult
        Case otDivision
            GetOpSymbol = op_div
        Case otIntDiv
            GetOpSymbol = op_intDiv
        Case otMod
            GetOpSymbol = op_mod
        Case otPower
            GetOpSymbol = op_power
        Case otEqual
            GetOpSymbol = op_equal
        Case otEqual_
            GetOpSymbol = op_equal_
        Case otNotEqual
            GetOpSymbol = op_inequality
        Case otGreaterThan
            GetOpSymbol = op_gt
        Case otLessThan
            GetOpSymbol = op_lt
        Case otGreaterThanOrEqual
            GetOpSymbol = op_gtequal
        Case otLessThanOrEqual
            GetOpSymbol = op_ltequal
        Case otLike
            GetOpSymbol = op_like
        Case otLogicalAND
            GetOpSymbol = op_and
        Case otLogicalOR
            GetOpSymbol = op_or
        Case otLogicalXOR
            GetOpSymbol = op_xor
    End Select
End Function

Private Function GetPowerSymbolPos(ByRef expression As String) As Long
    Dim tmpPos As Long
    Dim tmpResult As Long

    tmpPos = GetOPeratorSymbolPos(expression, op_power)
    Do While tmpPos
        tmpResult = tmpPos
        tmpPos = GetOPeratorSymbolPos(expression, op_power, tmpPos + 2)
    Loop
    GetPowerSymbolPos = tmpResult
End Function

Private Function GetPrecisionResult(p2 As Double) As Double
    If p2 &lt;&gt; 0 Then
        GetPrecisionResult = RoundToPrecision(p2, Precision_(p2))
    Else
        GetPrecisionResult = 0
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an array populated with the predictors relations to
&apos;&apos;&apos;     be used in a multiple linear regression model. The relations
&apos;&apos;&apos;     are expressed using dot to separate IDs. If named predictors
&apos;&apos;&apos;     are used, the list of predictors names must be supplied.
&apos;&apos;&apos;     Usage example:
&apos;&apos;&apos;                    GetPredInterArr(&quot;&apos;X1:X2;X2:X2&apos;&quot;,2)
&apos;&apos;&apos;                    GetPredInterArr(&quot;&apos;Height:Width&apos;&quot;,2,&quot;&apos;Height;Width&apos;&quot;)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;strPredictorsInterList&quot;&gt;
&apos;&apos;&apos;     A list of predictors relations with the syntax &apos;X#:X#;X#:X#&apos;.
&apos;&apos;&apos;     The # symbol denotes relative position of the predictor X in the
&apos;&apos;&apos;     model. The entire list must be enclosed in apostrophes.
&apos;&apos;&apos; &lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt; Predictors count.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;strPreditorsNames&quot;&gt;
&apos;&apos;&apos;     The full list of predictors names in &apos;$;$;$&apos; format.
&apos;&apos;&apos;     Here the $ symbol denotre a valid string name
&apos;&apos;&apos; &lt;/param&gt;
Private Function GetPredInterArr(ByRef strPredictorsInterList As String, n As Long, _
                                Optional strPreditorsNames As String = vbNullString) As Variant
    Dim tmpData() As String
    Dim tmpPredict() As String
    Dim tmpResult() As Boolean
    Dim fInteractions As String
    Dim idx1 As Long
    Dim idx2 As Long
    Dim s As Long
    Dim i As Long
    Dim j As Long
    Dim m As Long
    Dim elemComb As Long
    Dim r As Double    &apos;Sample of r elements
    
    On Error GoTo err_Handler
    r = 2
    elemComb = FACT(n + r - 1) / (FACT(r) * FACT(n - 1)) &apos;Combination with replacement taken from a set of n distinct objects
    ReDim tmpResult(0 To elemComb - 1)
    If strPreditorsNames &lt;&gt; vbNullString Then
        fInteractions = FormatNumeredInteractions( _
                                FormatNamedPredictors(strPreditorsNames, strPredictorsInterList) _
                            )
    Else
        fInteractions = FormatNumeredInteractions(strPredictorsInterList)
    End If
    If fInteractions = vbNullString Then Exit Function &apos;Syntax error or missed req. argument
    tmpData = Split(FormatLiteralString(fInteractions, True), P_SEPARATORCHAR)
    For m = LBound(tmpData) To UBound(tmpData)
        tmpPredict = Split(tmpData(m), ChrW(58))
        idx1 = CLng(strVBA.MidB(tmpPredict(LBound(tmpPredict)), 3))
        idx2 = CLng(strVBA.MidB(tmpPredict(LBound(tmpPredict) + 1), 3))
        s = 0
        j = 0
        Do While s &lt; elemComb
            i = 1
            j = j + 1
            Do While i &lt;= j
                &apos;Check predictor &quot;Xi.Xj&quot;
                If idx1 = i And idx2 = j Then
                    tmpResult(s) = True
                    Exit Do
                End If
                i = i + 1
                s = s + 1
            Loop
        Loop
    Next m
    GetPredInterArr = tmpResult
err_Handler:
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns a string holding a list of predictors relations with the syntax &apos;X1*X2;X3*X4&apos;
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;PredInterArr&quot;&gt;
&apos;&apos;&apos;     A list of predictors relations used in a multiple linear regression model.
&apos;&apos;&apos; &lt;/param&gt;
Private Function GetPredInterNames(ByRef PredInterArr() As Boolean) As String
    Dim tmpResult As String
    Dim s As Long
    Dim i As Long
    Dim j As Long
    Dim elemComb As Long
    
    elemComb = UBound(PredInterArr) - LBound(PredInterArr) + 1

    Do While s &lt; elemComb
        i = 1
        j = j + 1
        Do While i &lt;= j
            &apos;Check predictor &quot;Xi.Xj&quot;
            If PredInterArr(s) Then
                If tmpResult &lt;&gt; vbNullString Then
                    tmpResult = tmpResult &amp; P_SEPARATORCHAR &amp; _
                                &quot;X&quot; &amp; i &amp; op_mult &amp; &quot;X&quot; &amp; j
                Else
                    tmpResult = &quot;X&quot; &amp; i &amp; op_mult &amp; &quot;X&quot; &amp; j
                End If
            End If
            i = i + 1
            s = s + 1
        Loop
    Loop
    GetPredInterNames = tmpResult
End Function

Private Sub GetRootedTree(ByRef SubExpression As String, ByRef tmpReplacement As String, _
                                    ByRef OperationIndex As Long, ByRef outBuffer As ClusterTree)
    Dim vToken As token
    Dim Switch As Boolean
    Dim tmpPos As Long
    Dim OperandInBundle As Boolean
    Dim prevChar As String
    
    Do
        SubExpression = ApplyLawOfSigns(SubExpression)
        Set vToken = GetEvalToken(SubExpression)
        &apos;@--------------------------------------------------------------------
        &apos; Mask worked token
        tmpPos = strVBA.InStrB(1, SubExpression, vToken.DefString)
        If tmpPos &gt; 2 Then
            prevChar = strVBA.MidB(SubExpression, tmpPos - 2, 2)
            OperandInBundle = (strVBA.InStrB(1, op_AllItems, prevChar))
            Do While Not OperandInBundle And tmpPos &gt; 2    &apos;Tokens starts with a operator or with a null string
                tmpPos = strVBA.InStrB(tmpPos + 2, SubExpression, vToken.DefString)
                prevChar = strVBA.MidB(SubExpression, tmpPos - 2, 2)
                OperandInBundle = (strVBA.InStrB(1, op_AllItems, prevChar))
            Loop
        End If
        If tmpPos &gt; 0 Then
            SubExpression = strVBA.MidB(SubExpression, 1, tmpPos - 1) &amp; tmpReplacement &amp; strVBA.MidB(SubExpression, tmpPos + strVBA.LenB2(vToken.DefString))
        Else
            SubExpression = tmpReplacement
        End If
        AppendToBuffer outBuffer, vToken &apos;Save to target token ClusterTree
        Switch = (SubExpression &lt;&gt; tmpReplacement)
        OperationIndex = OperationIndex + 1
        tmpReplacement = GetSubstStr(OperationIndex)
    Loop While Switch
End Sub


Private Function GetRParentPos(ByRef expression As String, ByRef index As Long) As Long
    Dim tmpCounter As Long
    Dim SearchIndex As Long
    Dim OpenedSum As Long
    Dim tmpChr As String
    Dim literalStrGap As Variant
    ReDim literalStrGap(0 To 1)
    Dim foundLiteralStrGap As Boolean
    
    SearchIndex = 1
    OpenedSum = 0
    literalStrGap = GetLiteralStringGap(1, expression)
    foundLiteralStrGap = (literalStrGap(0) &gt; 0 And literalStrGap(1) &gt; 0)
    Do
        If Not (SearchIndex &gt; literalStrGap(0) * 2 And SearchIndex &lt; literalStrGap(1) * 2) Then
            tmpChr = strVBA.MidB(expression, SearchIndex, 2)
            If tmpChr = d_lParenthesis Then
                OpenedSum = OpenedSum + 1
            Else
                If tmpChr = d_rParenthesis Then
                    OpenedSum = OpenedSum - 1
                End If
            End If
        Else
            If SearchIndex &gt; literalStrGap(1) * 2 And foundLiteralStrGap Then
                literalStrGap = GetLiteralStringGap(literalStrGap(1) + 1, expression)
                foundLiteralStrGap = (literalStrGap(0) &gt; 0 And literalStrGap(1) &gt; 0)
            End If
        End If
        SearchIndex = SearchIndex + 2
    Loop While SearchIndex &lt;= index
    SearchIndex = 1
    tmpCounter = 0
    literalStrGap = GetLiteralStringGap(1, expression)
    Do
        If Not (SearchIndex &gt; literalStrGap(0) * 2 And SearchIndex &lt; literalStrGap(1) * 2) Then
            tmpChr = strVBA.MidB(expression, SearchIndex, 2)
            If tmpChr = d_lParenthesis Then
                tmpCounter = tmpCounter + 1
            Else
                If tmpChr = d_rParenthesis Then
                    tmpCounter = tmpCounter - 1
                End If
            End If
        Else
            If SearchIndex &gt; literalStrGap(1) * 2 And foundLiteralStrGap Then
                literalStrGap = GetLiteralStringGap(literalStrGap(1) + 1, expression)
                foundLiteralStrGap = (literalStrGap(0) &gt; 0 And literalStrGap(1) &gt; 0)
            End If
        End If
        SearchIndex = SearchIndex + 2
    Loop Until (tmpCounter = OpenedSum - 1) And (SearchIndex &gt; index)
    GetRParentPos = SearchIndex - 2
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Assigns the value from VarValue to VarName variable.
&apos;&apos;&apos;     A list of two elements is expected, first the name
&apos;&apos;&apos;     of the variable to be assigned the value and then
&apos;&apos;&apos;     the value to assign. The fucntion returns the VarValue.
&apos;&apos;&apos;
&apos;&apos;&apos;     NOTE: The name need to be pased as literal string.
&apos;&apos;&apos;     If the value parameter is omitted, the variable value
&apos;&apos;&apos;     is returned.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt;VarName.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;d&quot;&gt;VarValue.&lt;/param&gt;
Private Function GETS(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = tmpData(UB)
            P_SCOPE.LetVarValue(FormatLiteralString(tmpData(LB), True), tmpData(UB))
        Case 1
            Dim varName As String
            varName = FormatLiteralString(tmpData(LB), True)
            tmpEval = P_SCOPE.GetVarValue(varName)
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    GETS = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    GETS = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function GetSubstStr(ByRef aValue As Long) As String
    If aValue &gt;= 0 Then
        LIndexConstruc(1) = aValue
        GetSubstStr = Join$(LIndexConstruc, vbNullString)
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an array with all the sub expressions needed to
&apos;&apos;&apos;     evaluate the given expression. A string such as [0]
&apos;&apos;&apos;     indicates that the current token should be evaluated using
&apos;&apos;&apos;     the value or token residing at index 0 using functions
&apos;&apos;&apos;     and arithmetic operators.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Expression&quot;&gt;The expression to parse.&lt;/param&gt;
Private Function GetSubTreeData(ByRef expression As String) As Variant
    Dim opCount As Long
    Dim CPcount As Long
    
    opCount = CountParentheses(expression, d_lParenthesis)
    CPcount = CountParentheses(expression, d_rParenthesis)
    If opCount &lt;&gt; CPcount Then
        Exit Function
    End If
    Dim PSerial() As String
    Dim FSerial() As String
    If opCount &gt; 0 Then
        ReDim PSerial(0 To opCount - 1)
        Dim tgOpenP As Long
        Dim tgClosedP As Long
        Dim bMark As Long
        Dim eMark As Long
        Dim tmpTK As String
        Dim Uspace As Long
        Dim tmpKey As String
        
        tgOpenP = opCount
        tgClosedP = 1
        Uspace = LBound(PSerial)
        Do
            bMark = GetLParentPos(expression, tgOpenP) + 2
            eMark = GetRParentPos(expression, bMark - 2)
            tmpTK = strVBA.MidB(expression, bMark, eMark - bMark)
            If UnicToken(PSerial, tmpTK) Then
                PSerial(Uspace) = tmpTK
                Uspace = Uspace + 1
            End If
            tgOpenP = tgOpenP - 1
        Loop While tgOpenP &gt; 0
        Dim curIdx As Long
        Dim fpIdx As Long
        
        ReDim Preserve PSerial(LBound(PSerial) To Uspace - 1)
        FSerial() = PSerial
        For curIdx = UBound(PSerial) To LBound(PSerial) Step -1
            For fpIdx = LBound(PSerial) To UBound(PSerial)
                If fpIdx &lt;&gt; curIdx Then
                    If strVBA.InStrB(1, FSerial(fpIdx), PSerial(curIdx)) Then
                        tmpKey = GetSubstStr(curIdx)
                        FSerial(fpIdx) = Replace(FSerial(fpIdx), _
                                                    d_lParenthesis &amp; PSerial(curIdx) &amp; d_rParenthesis, _
                                                    tmpKey)
                    End If
                End If
            Next fpIdx
        Next curIdx
    Else
        ReDim FSerial(0 To 0)
        FSerial(0) = expression
    End If
    GetSubTreeData = FSerial
End Function

Private Sub GetTokenEnd(ByRef expression As String, ByRef startIndex As Long, ByRef OPlen As Long, ByRef outLng As Long)
    Dim curChar As String
    Dim lenExpr As Long
    Dim tmpPos As Long
    Dim varLen As Long
    Dim tmpVar As String
    Dim functionFlag As Boolean
    Dim cFlag As Boolean
    Dim OperandInBundle As Boolean
    
    lenExpr = strVBA.LenB2(expression)
    outLng = startIndex + OPlen
    curChar = strVBA.MidB(expression, outLng, 2)
    &apos;@--------------------------------------------------------------------
    &apos; Skip literal strings
    If curChar = d_Apostrophe Or curChar = d_Underscore Then
        Do
            outLng = outLng + 2
            curChar = strVBA.MidB(expression, outLng, 2)
        Loop While ((curChar &lt;&gt; d_Apostrophe) Or (curChar &lt;&gt; d_Underscore)) And outLng &lt; lenExpr
        If outLng &gt;= lenExpr Then Exit Sub
    End If
    Do
        tmpPos = outLng
        If IsLetter(curChar) Then &apos;Check for functions [ arg/-funct(...) ] and Sci notation
            Do
                varLen = varLen + 2
                outLng = outLng + 2
                curChar = strVBA.MidB(expression, outLng, 2)
            Loop While IsAlphaNumeric(curChar) And tmpPos &lt; lenExpr
            tmpVar = strVBA.MidB(expression, tmpPos, varLen)
            functionFlag = (GetFunctionName(tmpVar) &lt;&gt; vbNullString)
            If functionFlag Then   &apos;Ignore [+-] symbols for functions
                outLng = outLng + 2
                curChar = strVBA.MidB(expression, outLng, 2)
                If IsPlusOrMinus(curChar) Then
                    outLng = outLng + 2
                    curChar = strVBA.MidB(expression, outLng, 2)
                End If
            Else
                If strVBA.LenB2(tmpVar) = 2 Then  &apos;Ignore [+-] symbols for sci not symbol &quot;E&quot;
                    If AscW(tmpVar) = 69 Then
                        If IsPlusOrMinus(curChar) Then
                            outLng = outLng + 2
                            curChar = strVBA.MidB(expression, outLng, 2)
                        End If
                    End If
                End If
            End If
        Else &apos;Check operations like a[*/\^]-b
            If strVBA.InStrB(1, op_AllNotUnaryItems, curChar) Then &apos;May be unary symbol
                outLng = outLng + 2
            End If
        End If
        cFlag = (tmpPos &lt;&gt; outLng)
        If Not cFlag Then           &apos;Conditional check of the next symbol
            outLng = outLng + 2
            curChar = strVBA.MidB(expression, outLng, 2)
        End If
        OperandInBundle = (strVBA.InStrB(1, op_AllItems, curChar))
    Loop While Not OperandInBundle And outLng &lt; lenExpr
    If outLng &lt; lenExpr Then
        outLng = outLng - 2
    Else
        outLng = lenExpr
    End If
End Sub

Private Function GetTokenInfo(ByRef expression As String) As TokenInfo
    Dim tmpResult As TokenInfo
            
    Set tmpResult = GetArithOpInfo(expression)
    If tmpResult.Position = -1 Then &apos;Missing arithmetic opetarators.
        If expression Like &quot;*[=&lt;&gt;&amp;|$]*&quot; Then &apos;Try with logical operators.
            Set tmpResult = GetLCOpInfo(expression)
            tmpResult.LogicalToken = Not (expression Like &quot;&apos;*[=&lt;&gt;&amp;|$]*&apos;&quot;)
        Else
            tmpResult.Position = -1
            If expression Like &quot;*[Tt][Rr][Uu][Ee]&quot; Then
                tmpResult.LogicalToken = True
            Else
                If expression Like &quot;*[Ff][Aa][Ll][Ss][Ee]&quot; Then
                    tmpResult.LogicalToken = True
                Else
                    If expression Like &quot;~*&quot; Then
                        tmpResult.LogicalToken = True
                    End If
                End If
            End If
        End If
    End If
    Set GetTokenInfo = tmpResult
End Function

Private Sub GetTokenStart(ByRef expression As String, ByRef startIndex As Long, ByRef outLng As Long)
    Dim curChar As String
    Dim cAcsw As Long
    
    outLng = startIndex - 2
    curChar = strVBA.MidB(expression, outLng, 2)
    &apos;@--------------------------------------------------------------------
    &apos; Skip literal strings
    If curChar = d_Apostrophe Or curChar = d_Underscore Then
        Do
            outLng = outLng - 2
            curChar = strVBA.MidB(expression, outLng, 2)
        Loop While ((curChar &lt;&gt; d_Apostrophe) Or (curChar &lt;&gt; d_Underscore)) And outLng &gt; 1
        If outLng = 1 Then Exit Sub
    End If
    Do While (strVBA.InStrB(1, op_AllItems, curChar) = 0) And outLng &gt; 1
        outLng = outLng - 2
        curChar = strVBA.MidB(expression, outLng, 2)
        If AscW(curChar) = AscDecSymbol Then  &apos;Decimal symbol: [.][,]
            outLng = outLng - 2
            If outLng &gt; 0 Then
                curChar = strVBA.MidB(expression, outLng, 2)
            End If
        Else
            If outLng &gt;= 3 Then
                If AscW(strVBA.MidB(expression, outLng - 2, 2)) = 69 Then &apos;Ignore Sci notation &quot;E&quot;
                    If outLng &gt; 4 Then
                        curChar = strVBA.MidB(expression, outLng - 4, 2)
                        Select Case AscW(curChar) &apos;Previous char must be numeric: #E[+-]#
                            Case 48 To 57
                                outLng = outLng - 4
                        End Select
                    End If
                End If
            End If
        End If
    Loop
    &apos;@--------------------------------------------------------------------
    &apos; Check for symbols combination: [*+-/^%\~=&lt;&gt;&amp;|][-~]
    If outLng &gt; 1 Then
        cAcsw = AscW(curChar)
        Select Case cAcsw
            Case 45, 126
                Dim prevChar As String
                prevChar = strVBA.MidB(expression, outLng - 2, 2)
                If strVBA.InStrB(1, op_AllNotUnaryItems, prevChar) Then
                    If cAcsw = 45 And (prevChar = op_plus Or prevChar = op_minus) Then
                        outLng = outLng - 2
                    Else
                        If cAcsw = 126 And prevChar = op_neg Then
                            outLng = outLng - 2
                        End If
                    End If
                Else
                    outLng = outLng + 2
                End If
            Case Else
                outLng = outLng + 2
        End Select
    Else
        If outLng &lt; 1 Then
            outLng = 1
        End If
    End If
End Sub

Private Function GoBackToOpSymbol(ByRef expression As String, ByRef VarStartPos As Long) As Long
    Dim tmpResult As Long
    
    tmpResult = VarStartPos - 2
    Do While tmpResult &gt;= 1
        If ImplicitMultFlag(strVBA.MidB(expression, tmpResult, 2)) Then
            tmpResult = tmpResult - 2
        Else
            Exit Do
        End If
    Loop
    GoBackToOpSymbol = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the googness of a curve fit over The ObserArray must be a 2 columns
&apos;&apos;&apos;     array in which the first column contains the X (independent variable) values
&apos;&apos;&apos;     and the second column contains the Y (dependent variable) values
&apos;&apos;&apos; &lt;/summary&gt;
Private Function GoodnessOfFit_(ByRef Polynomial As String, ByRef ObserArray() As Double) As Double
    Dim exprHelper As Object
    Dim averageY As Double
    Dim Rsquared As Double
    Dim seSquare As Double
    Dim stSquare As Double
    Dim i As Long
    Dim n As Long
    
    n = UBound(ObserArray) - LBound(ObserArray) + 1
    Set exprHelper = New VBAexpressions
    With exprHelper
        .Create Polynomial
        averageY = ColumnAvg(ObserArray, 1) &apos;Mean
        For i = 0 To n - 1
            .Eval &quot;x=&quot; &amp; CStr(ObserArray(i, 0))
            seSquare = seSquare + (ObserArray(i, 1) - CDbl(.Result)) ^ 2 &apos;Partial sum squared regression
            stSquare = stSquare + (averageY - ObserArray(i, 1)) ^ 2 &apos;Partial total sum of squares
        Next i
        Rsquared = Round(1 - seSquare / stSquare, 4)
    End With
    GoodnessOfFit_ = Rsquared
    Set exprHelper = Nothing
End Function

Private Function Hour_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = Hour( _
                            FormatLiteralString(tmpData(LB), True) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Hour_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Hour_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the cumulative distribution function (CDF) for the beta distribution
&apos;&apos;&apos;     (i.e., the area under the beta distribution from 0 to x), given values of
&apos;&apos;&apos;     the shape parameters, and the point at which to evaluate the function.
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;x&quot;&gt;Integration limit point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;a&quot;&gt;Shape parameter alpha.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;b&quot;&gt;Shape parameter beta.&lt;/param&gt;
Private Function iBETA(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = iBETA_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(LB + 1)), _
                            CDbl(tmpData(UB)))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    iBETA = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    iBETA = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function iBETAINV(p As Double, A As Double, B As Double) As Double
    Const EPS As Double = 0.00000001
    Dim aL As Double
    Dim a1, b1 As Double
    Dim j As Long
    Dim lna As Double, lnb As Double
    Dim pp As Double, t As Double
    Dim u As Double, err As Double
    Dim x As Double, h As Double
    Dim w As Double, afac As Double

    a1 = A - 1: b1 = B - 1
    j = 0
    If p &lt;= 0 Then
        iBETAINV = 0
        Exit Function
    End If
    If p &gt;= 1 Then
        iBETAINV = 1
        Exit Function
    End If
    If A &gt;= 1 And B &gt;= 1 Then
        If p &lt; 0.5 Then
            pp = p
        Else
            pp = 1 - p
        End If
        t = Sqr(-2 * Log(pp))
        x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t
        If p &lt; 0.5 Then x = -x
        aL = (x * x - 3) / 6
        h = 2 / (1 / (2 * A - 1) + 1 / (2 * B - 1))
        w = (x * Sqr(aL + h) / h) - (1 / (2 * B - 1) - 1 / (2 * A - 1)) * _
            (aL + 5 / 6 - 2 / (3 * h))
        x = A / (A + B * Exp(2 * w))
    Else
        lna = Log(A / (A + B)): lnb = Log(B / (A + B))
        t = Exp(A * lna) / A: u = Exp(B * lnb) / B
        w = t + u
        If p &lt; t / w Then
            x = (A * w * p) ^ (1 / A)
        Else
            x = 1 - ((B * w * (1 - p)) ^ (1 / B))
        End If
    End If
    afac = -GAMMALN_(A) - GAMMALN_(B) + GAMMALN_(A + B)
    Do While j &lt; 10
        If x = 0 Or x = 1 Then iBETAINV = x: Exit Function
        err = iBETA_(x, A, B) - p
        t = Exp(a1 * Log(x) + b1 * Log(1 - x) + afac)
        u = err / t
        t = u / (1 - 0.5 * MIN_(1, u * (a1 / x - b1 / (1 - x))))
        x = x - t
        If x &lt;= 0 Then x = 0.5 * (x + t)
        If x &gt;= 1 Then x = 0.5 * (x + t + 1)
        If Abs(t) &lt; EPS * x And j &gt; 0 Then Exit Do
        j = j + 1
    Loop
    iBETAINV = x
End Function

Private Function iBETA_(x As Double, A As Double, B As Double) As Variant
    Dim BT As Double

&apos;   // Factors in front of the continued fraction.
    If x = 0 Or x = 1 Then
        BT = 0
    Else
        BT = Exp(GAMMALN_(A + B) - GAMMALN_(A) - GAMMALN_(B) + A * Log(x) + B * Log(1 - x))
    End If
    If x &lt; 0 Or x &gt; 1 Then
        iBETA_ = False: Exit Function
    Else
        If x &lt; (A + 1) / (A + B + 2) Then
&apos;           // Use continued fraction directly.
            iBETA_ = BT * betacf(x, A, B) / A
        Else
&apos;           // else use continued fraction after making the symmetry transformation.
            iBETA_ = 1 - BT * betacf(1 - x, B, A) / B
        End If
    End If
End Function

Private Function Iff_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Boolean
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = CBool( _
                            FormatLiteralString(tmpData(LB), True) _
                            )
        Case Else
            Iff_ = e_ValueError
            Exit Function
    End Select
    If tmpEval Then    &apos;Return the TRUE part
        Iff_ = tmpData(LB + 1)
    Else
        Iff_ = tmpData(UB)
    End If
    Exit Function
err_Handler:
    Iff_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an array with the incenter&apos;s coordinates for the
&apos;&apos;&apos;     given triangle.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointA&quot;&gt;First point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointB&quot;&gt;Second point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointC&quot;&gt;Third point.&lt;/param&gt;
Private Function Incenter(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Variant
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = InCenter_(ToDblArray(ArrayFromString(tmpData(LB))), _
                                    ToDblArray(ArrayFromString(tmpData(LB + 1))), _
                                    ToDblArray(ArrayFromString(tmpData(UB))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    If IsArray(tmpEval) Then
        Incenter = ArrayToString(tmpEval)
    Else
        Incenter = tmpEval
    End If
    Erase tmpData
    Exit Function
err_Handler:
    Incenter = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function InCenter_(PointA() As Double, PointB() As Double, PointC() As Double) As Variant
    Dim AngleBisection1 As Variant
    Dim AngleBisection2 As Variant
    
    AngleBisection1 = ToDblArray(AngleBisector_(PointA, PointB, PointC))
    AngleBisection2 = ToDblArray(AngleBisector_(PointB, PointC, PointA))
    InCenter_ = LinesIntersection(AngleBisection1, AngleBisection2)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an array with the coordinates for the center
&apos;&apos;&apos;     and the radius for circle inscribed in the given triangle.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointA&quot;&gt;First point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointB&quot;&gt;Second point.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PointC&quot;&gt;Third point.&lt;/param&gt;
Private Function Incircle(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Variant
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = InCircle_(ToDblArray(ArrayFromString(tmpData(LB))), _
                                    ToDblArray(ArrayFromString(tmpData(LB + 1))), _
                                    ToDblArray(ArrayFromString(tmpData(UB))))
        Case Else
            tmpEval = e_ValueError
            BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    If IsArray(tmpEval) Then
        Incircle = ArrayToString(tmpEval)
    Else
        Incircle = tmpEval
    End If
    Erase tmpData
    Exit Function
err_Handler:
    Incircle = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function InCircle_(PointA() As Double, PointB() As Double, PointC() As Double) As Variant
    Dim hk() As Double
    Dim intersectP() As Double
    Dim aSegment(0 To 1, 0 To 1) As Double
    Dim result2D(0 To 1, 0 To 1) As Double
    Dim Radius As Double
    
    hk = ToDblArray(InCenter_(PointA, PointB, PointC))
    aSegment(0, 0) = PointA(0): aSegment(0, 1) = PointA(1)
    aSegment(1, 0) = PointB(0): aSegment(1, 1) = PointB(1)
    intersectP = ToDblArray(LinesIntersection(aSegment, PerpendicularLine_(aSegment, hk)))
    Radius = Distance_(hk, intersectP)
    result2D(0, 0) = hk(0): result2D(0, 1) = hk(1)
    result2D(1, 0) = Radius: result2D(1, 1) = Radius
    InCircle_ = result2D
End Function

Private Function InStr_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = CStr(InStr( _
                                    1, _
                                    FormatLiteralString(tmpData(LB), True), _
                                    FormatLiteralString(tmpData(UB), True) _
                                ) _
                            )
        Case 3
            tmpEval = CStr(InStr( _
                                    CLng(tmpData(LB)), _
                                    FormatLiteralString(tmpData(LB + 1), True), _
                                    FormatLiteralString(tmpData(UB), True) _
                                ) _
                            )
        Case 4
            tmpEval = CStr(InStr( _
                                    CLng(tmpData(LB)), _
                                    FormatLiteralString(tmpData(LB + 1), True), _
                                    FormatLiteralString(tmpData(LB + 2), True), _
                                    CLng(tmpData(UB)) _
                                ) _
                            )
        Case Else
            InStr_ = e_ValueError
            Exit Function
    End Select
    InStr_ = tmpEval
    Exit Function
err_Handler:
    InStr_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ImplicitMultFlag(ByRef Char As String) As Boolean
    If strVBA.LenB2(Char) Then
        Select Case AscW(Char)
            Case AscDecSymbol, 48 To 57
                ImplicitMultFlag = True
            Case Else
                ImplicitMultFlag = False
        End Select
    End If
End Function

Private Sub InitBuffer(ByRef aBuffer As ClusterTree)
	Dim tmpBuffer() As token
	
	aBuffer.Capacity = 128
	ReDim tmpBuffer(0 To aBuffer.Capacity - 1)
	Set aBuffer.Storage = tmpBuffer
	aBuffer.aindex = -1
End Sub

Private Sub InitCBbuffer(ByRef aBuffer As ClusterBuffer)
	Dim tmpBuffer() As ClusterItem
	
	aBuffer.Capacity = 128
	ReDim tmpBuffer(0 To aBuffer.Capacity - 1)
	Set aBuffer.Storage = tmpBuffer
	aBuffer.aindex = -1
End Sub

Private Sub InitializeErrHandler()
    P_ERRORDESC = vbNullString
    P_ERRTYPE = errNone
End Sub

Private Function InverseMatrix(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            Dim aArray() As Double
            Dim pivotingIdx() As Long
            Dim d As Double             &apos;Interchages parity
            
            aArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            tmpEval = ArrayToString(MInverse_(aArray, pivotingIdx, d))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    InverseMatrix = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    InverseMatrix = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function IPMT_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 4
            tmpEval = IPmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = IPmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 6
            tmpEval = IPmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 4), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    IPMT_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    IPMT_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function IRR_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    Dim strArray() As String
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    strArray() = ArrayFromString(tmpData(LB)) &apos;Get array of data
    Select Case argsCount
        Case 1, 2
            &apos;Attempt to arrive at a positive IRR solution.
            tmpEval = fZeroMBM(DefineIRRfunction(strArray), -0.2, 0.99, False, 0.00001)
            If argsCount = 2 Then
                If CBool(tmpData(UB)) Then
                    If tmpEval = e_ValueError Then &apos;Positive IRR not found
                        tmpEval = fZeroMBM(DefineIRRfunction(strArray), -0.99, -0.19, False, 0.00001)
                    End If
                End If
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    IRR_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    IRR_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Is2Darray(arr As Variant) As Boolean
    Dim d As Long
    
    On Error GoTo err_Handler
    d = UBound(arr, 2)
    Is2Darray = True
    Exit Function
err_Handler:
    Is2Darray = False
End Function

Private Function IsAlphaNumeric(ByRef Char As String) As Boolean
    If strVBA.LenB2(Char) Then
        Select Case AscW(Char)
            Case 48 To 57, 65 To 90, 97 To 122
                IsAlphaNumeric = True
            Case Else
                IsAlphaNumeric = False
        End Select
    End If
End Function

Private Function IsArrayAllocated(ByRef arr As Variant) As Boolean
    Dim UB As Long
    
    On Error GoTo err_Handler
    UB = UBound(arr)
    IsArrayAllocated = True
    Exit Function
err_Handler:
    IsArrayAllocated = False
End Function

Private Function IsAssigned(aVarName As String) As Boolean
    IsAssigned = (strVBA.LenB(P_SCOPE.VarValue(aVarName)) &gt; 0)
End Function

Private Function IsBoolean(ByRef expression As String) As Boolean
    IsBoolean = (expression = &quot;true&quot;)
    If Not IsBoolean Then
        IsBoolean = (expression = &quot;false&quot;)
    End If
End Function

Public Function IsConstant(aVarName As String) As Boolean
    IsConstant = P_SCOPE.IsConstant(aVarName)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Determines if a token/sub-expressions is constant
&apos;&apos;&apos; &lt;/summary&gt;
Private Function IsConstantToken(ByRef CurToken As token, ByRef CurTree As ClusterTree, _
                                    ByRef BaseIndex As Long) As Boolean
    Dim VariablesInToken As Boolean
    Dim VariablesInRelatedToken1 As Boolean
    Dim VariablesInRelatedToken2 As Boolean
    Dim iCounter As Long
    Dim TokensCount As Long
    
    VariablesInToken = CurToken.Arg1.LinkedVar &lt;&gt; -1 Or CurToken.Arg2.LinkedVar &lt;&gt; -1
    If CurToken.Arg1.Implicit Or CurToken.Arg2.Implicit Then &apos;Check related token
        If CurToken.Arg1.Implicit Then
            If CurToken.Arg1.LinkedIndex &gt;= BaseIndex Then &apos;Data on current tree
                VariablesInRelatedToken1 = Not IsConstantToken(CurTree.Storage(CurToken.Arg1.LinkedIndex - BaseIndex), _
                                                            CurTree, BaseIndex)
            Else &apos;Data is main tree
                VariablesInRelatedToken1 = Not IsConstantToken(EvalTree(CurToken.Arg1.LinkedIndex).Storage(0), _
                                                            EvalTree(CurToken.Arg1.LinkedIndex), BaseIndex)
                iCounter = 1 &apos;Check all tokens in current cluster
                TokensCount = EvalTree(CurToken.Arg1.LinkedIndex).aindex
                Do While VariablesInRelatedToken1 And iCounter &lt;= TokensCount
                    VariablesInRelatedToken1 = Not IsConstantToken(EvalTree(CurToken.Arg1.LinkedIndex).Storage(iCounter), _
                                                            EvalTree(CurToken.Arg1.LinkedIndex), BaseIndex)
                    iCounter = iCounter + 1
                Loop
            End If
        End If
        If CurToken.Arg2.Implicit Then
            If CurToken.Arg2.LinkedIndex &gt;= BaseIndex Then
                VariablesInRelatedToken2 = Not IsConstantToken(CurTree.Storage(CurToken.Arg2.LinkedIndex - BaseIndex), _
                                                            CurTree, BaseIndex)
            Else
                VariablesInRelatedToken2 = Not IsConstantToken(EvalTree(CurToken.Arg2.LinkedIndex).Storage(0), _
                                                            EvalTree(CurToken.Arg2.LinkedIndex), BaseIndex)
                iCounter = 1
                TokensCount = EvalTree(CurToken.Arg2.LinkedIndex).aindex
                Do While VariablesInRelatedToken2 And iCounter &lt;= TokensCount
                    VariablesInRelatedToken2 = Not IsConstantToken(EvalTree(CurToken.Arg2.LinkedIndex).Storage(iCounter), _
                                                            EvalTree(CurToken.Arg2.LinkedIndex), BaseIndex)
                    iCounter = iCounter + 1
                Loop
            End If
        End If
        IsConstantToken = Not VariablesInToken And (Not VariablesInRelatedToken1 And Not VariablesInRelatedToken2)
    Else
        IsConstantToken = Not VariablesInToken
    End If
End Function

Private Function IsDigit(ByRef Char As String) As Boolean
    If strVBA.LenB2(Char) Then
        Select Case AscW(Char)
            Case 48 To 57
                IsDigit = True
            Case Else
                IsDigit = False
        End Select
    End If
End Function

Private Function IsExtAlphaNumeric(ByRef Char As String) As Boolean
    If strVBA.LenB2(Char) Then
        Select Case AscW(Char)
            Case AscDecSymbol, 48 To 57, 65 To 90, 95, 97 To 122
                IsExtAlphaNumeric = True
            Case Else
                IsExtAlphaNumeric = False
        End Select
    End If
End Function

Private Function IsInList(ByRef aList As Variant, aValue As String) As Boolean
    Dim i As Long, j As Long
    Dim tmpResult As Boolean
    
    i = LBound(aList)
    j = UBound(aList)
    Do
        tmpResult = (FormatLiteralString(CStr(aList(i)), True) = aValue)
        i = i + 1
    Loop While i &lt;= j And Not tmpResult
    IsInList = tmpResult
End Function

Private Function IsLetter(ByRef Char As String) As Boolean
    If strVBA.LenB2(Char) Then
        Select Case AscW(Char)
            Case 65 To 90, 97 To 122
                IsLetter = True
            Case Else
                IsLetter = False
        End Select
    End If
End Function

Private Function IsLikeSciNot(ByRef Chars As String) As Boolean
    If strVBA.LenB2(Chars) Then
        If AscW(Chars) = 69 Then &apos;Sci not token &quot;E&quot;
            If IsDigit(strVBA.MidB(Chars, 3, 2)) Then &apos;Check 2nd char
                IsLikeSciNot = True
            End If
        Else
            IsLikeSciNot = False
        End If
    End If
End Function

Private Function IsLiteralString(ByRef aString As String) As Boolean
    If aString &lt;&gt; vbNullString Then
        If AscW(aString) = 39 Then &apos;Apostrophe
            IsLiteralString = (strVBA.InStrB(3, aString, d_Apostrophe) = strVBA.LenB2(aString) - 1)
        ElseIf AscW(aString) = 95 Then &apos;Underscore
            IsLiteralString = (strVBA.InStrB(3, aString, d_Underscore) = strVBA.LenB2(aString) - 1)
        Else
            IsLiteralString = False
        End If
    End If
End Function

Private Function IsPlusOrMinus(ByRef Char As String) As Boolean
    If strVBA.LenB2(Char) Then
        Select Case AscW(Char)
            Case 43, 45
                IsPlusOrMinus = True
            Case Else
                IsPlusOrMinus = False
        End Select
    End If
End Function

Private Function IsSavedPredictorName(ByRef aName As String, ByRef aNamesList() As String) As Boolean
    Dim i As Long
    Dim tmpResult As Boolean
    Dim n As Long

    n = UBound(aNamesList)
    i = LBound(aNamesList)
    Do While Not tmpResult And i &lt;= n
        tmpResult = (aName = aNamesList(i))
        i = i + 1
    Loop
    IsSavedPredictorName = tmpResult
End Function

Private Function IsSymbolInLiteralString(ByRef expression As String, SymbolPos As Long) As Boolean
    Dim tmpPos As Long
    Dim literalGap() As Long
    
    literalGap() = GetLiteralStringGap(1, expression)
    Do While (literalGap(1) &lt; SymbolPos) And (literalGap(1) &gt; 0)
        literalGap() = GetLiteralStringGap(literalGap(1) + 1, expression)
    Loop
    IsSymbolInLiteralString = ((SymbolPos &gt; literalGap(0)) And (SymbolPos &lt; literalGap(1)))
End Function

Private Function IsTwiceJaggedArr(ByRef arr As Variant, elIdx As Long) As Boolean
    On Error GoTo err_Handler
    IsTwiceJaggedArr = IsArray(arr(elIdx)(LBound(arr(elIdx))))
    Exit Function
err_Handler:
    IsTwiceJaggedArr = False
    err.Clear
End Function

Private Function JoinArrFunctArg(ByRef DecompArray() As String, ByRef MapedIdx() As Long) As String
    Dim tmpResult As String
    Dim tmpArray As String
    Dim MaxRowIndex As Long
    Dim MaxColIndex As Long
    Dim i As Long, j As Long
    Dim k As Long
    Dim UB As Long
    Dim wIdx As Long
    
    UB = UBound(MapedIdx)
    For k = LBound(MapedIdx) To UB
        If MapedIdx(k) &lt;&gt; -2 Then
            MaxRowIndex = MapedIdx(k)
            If MapedIdx(k + 1) &lt;&gt; -3 Then &apos;2D Array
                MaxColIndex = MapedIdx(k + 1)
            Else &apos;Vector
                MaxColIndex = 0
            End If
            tmpArray = vbNullString
            For i = 0 To MaxRowIndex
                If MapedIdx(k + 1) &lt;&gt; -3 And MaxColIndex &gt; 0 Then
                    For j = 0 To MaxColIndex
                        If j = 0 Then
                            tmpArray = tmpArray &amp; d_lCurly &amp; _
                                                DecompArray(j + (i * (MaxColIndex + 1)) + wIdx)
                        Else
                            tmpArray = tmpArray &amp; P_SEPARATORCHAR &amp; DecompArray(j + (i * (MaxColIndex + 1)) + wIdx)
                        End If
                        If j = MaxColIndex Then
                            tmpArray = tmpArray &amp; d_rCurly
                        End If
                    Next j
                Else
                    If i = 0 Then
                        tmpArray = tmpArray &amp; d_lCurly &amp; DecompArray((i * (MaxColIndex + 1)) + wIdx)
                    Else
                        tmpArray = tmpArray &amp; DecompArray((i * (MaxColIndex + 1)) + wIdx)
                    End If
                    If i = MaxRowIndex Then
                        tmpArray = tmpArray &amp; d_rCurly
                    End If
                End If
                If i &lt; MaxRowIndex Then
                    tmpArray = tmpArray &amp; P_SEPARATORCHAR
                End If
            Next i
            If MapedIdx(k + 1) &lt;&gt; -3 Then
                tmpArray = d_lCurly &amp; tmpArray &amp; d_rCurly
                If MaxColIndex &gt; 0 Then
                    wIdx = wIdx + i * j
                Else
                    wIdx = wIdx + i
                End If
            Else
                wIdx = wIdx + i
            End If
            tmpResult = tmpResult &amp; tmpArray
            k = k + 1
        Else
            If tmpResult &lt;&gt; vbNullString Then
                tmpResult = tmpResult &amp; DecompArray(wIdx)
            Else
                tmpResult = DecompArray(wIdx)
            End If
            wIdx = wIdx + 1
        End If
        If k &lt; UB Then
            tmpResult = tmpResult &amp; P_SEPARATORCHAR
        End If
    Next k
    JoinArrFunctArg = tmpResult
End Function

Private Function LCase_(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    LCase_ = ToLiteralString(LCase(expression))
    Exit Function
err_Handler:
    LCase_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Left_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ToLiteralString(Left(FormatLiteralString(tmpData(LB), True), 1))
        Case 2
            tmpEval = ToLiteralString( _
                                        Left( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Left_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Left_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Len_(ByRef expression As String, ByRef fName As String) As String
    Dim tmpResult As Long
    
    On Error GoTo err_Handler
    If IsLiteralString(expression) Then
        tmpResult = Len(FormatLiteralString(expression))
    Else
        tmpResult = Len(expression)
    End If
    Len_ = CStr(tmpResult)
    Exit Function
err_Handler:
    Len_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function LgN(ByRef expression As String, ByRef fName As String) As String
    Dim tmpData() As String
    Dim tmpEval As Double
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpEval = 0
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    If UB - LB = 1 Then
        tmpEval = Log(CDbl(tmpData(LB))) _
                    / Log(CDbl(tmpData(UB)))    &apos;Log(x)/Log(N)
    Else
        tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End If
    LgN = CStr(tmpEval): Erase tmpData
    Exit Function
err_Handler:
    LgN = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     This function return the intersection of two lines given
&apos;&apos;&apos;     two ordered pairs of points for each line. The PointsInLine1
&apos;&apos;&apos;     and PointsInLine2 arguments must have the array form |[x] [y]|
&apos;&apos;&apos;     with the same size (2 rows and 2 columns). The returned value
&apos;&apos;&apos;     is an array |[x] [y]| if the lines meet and a #Null error value
&apos;&apos;&apos;     for parallel lines.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function LinesIntersection(ByRef PointsInLine1 As Variant, _
                                    PointsInLine2 As Variant, Optional k As Integer = 1) As Variant
    Dim i As Double
    Dim j As Double
    Dim m As Double
    Dim n As Double
    Dim O As Double
    Dim PP As Double
    Dim HomogeneousPointsL1(0 To 1, 0 To 2) As Variant
    Dim HomogeneousPointsL2(0 To 1, 0 To 2) As Variant
    Dim HomogeneousEcuations(0 To 1, 0 To 2) As Variant
    Dim EcuationsProduct(0 To 0, 0 To 2) As Variant
    Dim intersection(0 To 1) As Variant
    
    If k &lt;= 0 Then k = 1 &apos;Ensure positive scalar value
    m = LBound(PointsInLine1, 1)
    n = LBound(PointsInLine1, 2)
    &apos;Represent the points with homogeneous coordinates
    i = 0
    For O = m To m + 1
        j = 0
        For PP = n To n + 2
            If PP &lt; n + 2 Then
                HomogeneousPointsL1(i, j) = PointsInLine1(O, PP)
                HomogeneousPointsL2(i, j) = PointsInLine2(O, PP)
            Else
                HomogeneousPointsL1(i, j) = k
                HomogeneousPointsL2(i, j) = k
            End If
            j = j + 1
        Next PP
        i = i + 1
    Next O
    &apos;Compute the lines homogeneous ecuations using Vectorial Matrix Products
    HomogeneousEcuations(0, 0) = (HomogeneousPointsL1(0, 1) * HomogeneousPointsL1(1, 2)) - _
                                (HomogeneousPointsL1(1, 1) * HomogeneousPointsL1(0, 2)) &apos;[a01*a12 - a11*a02]
    HomogeneousEcuations(0, 1) = -1 * ((HomogeneousPointsL1(0, 0) * HomogeneousPointsL1(1, 2)) - _
                                (HomogeneousPointsL1(1, 0) * HomogeneousPointsL1(0, 2))) &apos;-[a00*a12 - a10*a02]
    HomogeneousEcuations(0, 2) = (HomogeneousPointsL1(0, 0) * HomogeneousPointsL1(1, 1)) - _
                                (HomogeneousPointsL1(1, 0) * HomogeneousPointsL1(0, 1)) &apos;[a00*a11 - a10*a01]
    HomogeneousEcuations(1, 0) = (HomogeneousPointsL2(0, 1) * HomogeneousPointsL2(1, 2)) - _
                                (HomogeneousPointsL2(1, 1) * HomogeneousPointsL2(0, 2))
    HomogeneousEcuations(1, 1) = -1 * ((HomogeneousPointsL2(0, 0) * HomogeneousPointsL2(1, 2)) - _
                                (HomogeneousPointsL2(1, 0) * HomogeneousPointsL2(0, 2)))
    HomogeneousEcuations(1, 2) = (HomogeneousPointsL2(0, 0) * HomogeneousPointsL2(1, 1)) - _
                                (HomogeneousPointsL2(1, 0) * HomogeneousPointsL2(0, 1))
    &apos;Compute the lines meet using Vectorial Matrix Products
    EcuationsProduct(0, 0) = (HomogeneousEcuations(0, 1) * HomogeneousEcuations(1, 2)) - _
                                (HomogeneousEcuations(1, 1) * HomogeneousEcuations(0, 2)) &apos;[a01*a12 - a11*a02]
    EcuationsProduct(0, 1) = -1 * ((HomogeneousEcuations(0, 0) * HomogeneousEcuations(1, 2)) - _
                                (HomogeneousEcuations(1, 0) * HomogeneousEcuations(0, 2))) &apos;-[a00*a12 - a10*a02]
    EcuationsProduct(0, 2) = (HomogeneousEcuations(0, 0) * HomogeneousEcuations(1, 1) - _
                                (HomogeneousEcuations(1, 0) * HomogeneousEcuations(0, 1))) &apos;[a00*a11 - a10*a01]
    If EcuationsProduct(0, 2) = 0 Then
        LinesIntersection = &quot;#Null&quot; &apos;Return a Null value. The lines meet at the infinity.
    Else
        intersection(0) = k * EcuationsProduct(0, 0) / EcuationsProduct(0, 2)
        If intersection(0) = 0 Then intersection(0) = Abs(intersection(0)) &apos;Avoid negative zero
        intersection(1) = k * EcuationsProduct(0, 1) / EcuationsProduct(0, 2)
        If intersection(1) = 0 Then intersection(1) = Abs(intersection(1))
        LinesIntersection = intersection
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the intersection point for two lines.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Line1&quot;&gt;Array of coordinates in format {{x1;y1};{x2;y2}}.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;Line2&quot;&gt;Array of coordinates in format {{x3;y3};{x4;y4}}.&lt;/param&gt;
Private Function LinesIntersect(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Variant
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            Dim aArray() As Variant
            ReDim aArray(0 To 1)
            
            aArray(0) = ToDblArray(ArrayFromString(tmpData(LB)))
            aArray(1) = ToDblArray(ArrayFromString(tmpData(UB)))
            tmpEval = LinesIntersection(aArray(0), aArray(1))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    If IsArray(tmpEval) Then
    	LinesIntersect = ArrayToString(tmpEval)
    else
    	LinesIntersect = tmpEval
    End If
    Erase tmpData
    Exit Function
err_Handler:
    LinesIntersect = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function LN(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    LN = CStr(Log(CDbl(expression)))
    Exit Function
err_Handler:
    LN = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Log10(aValue As Double) As Double
    Log10 = Log(aValue) / Log(10)
End Function

Private Function Logarithm(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    Logarithm = CStr(Log(CDbl(expression)) / Log(10))
    Exit Function
err_Handler:
    Logarithm = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary: Least squares solution of A*X = B&gt;
&apos;&apos;&apos;     Returns X that minimizes the two norm of Q*R*X-B
&apos;&apos;&apos;     @exception  IllegalArgumentException  Matrix row dimensions must agree.
&apos;&apos;&apos;     @exception  RuntimeException  Matrix is rank deficient.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;A&quot;&gt;Matrix of coefficients of the system variables.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;b&quot;&gt;Right side vector.&lt;/param&gt;
Private Function LSQRsolve(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = ArrayToString(QR_LSQsolve( _
                            ToDblArray(ArrayFromString(tmpData(LB))), _
                            ToDblArray(ArrayFromString(tmpData(UB))) _
                            ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    LSQRsolve = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    LSQRsolve = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Solves the set of n linear equations A.X = B. Here
&apos;&apos;&apos;     a[1,...,n][1,...,n] is input, not as the matrix A but
&apos;&apos;&apos;     rather as its LU decomposition, determined by the routine
&apos;&apos;&apos;     LUdecomp. indx[1,...,n] is input as the permutation vector
&apos;&apos;&apos;     returned from LUdecomp. b[1,...,n] is input as the right-hand
&apos;&apos;&apos;     side vector B, and returns with the solution vector X
&apos;&apos;&apos; &lt;/summary&gt;
Private Sub LUbkSub(ByRef A() As Double, ByRef indx() As Long, ByRef B() As Double)
&apos;@----------------------------------------------------------------------------------------
&apos; Numerical recipes in C: the art of scientific computing / William H. Press [et al.]
&apos; - 2nd ed. (p.47)
&apos;-----------------------------------------------------------------------------------------
    Dim i As Long
    Dim ii As Long
    Dim ip As Long
    Dim j As Long
    Dim n As Long
    Dim pSum As Double
    Dim aLB As Long
    Dim aUB As Long
    Dim bLB As Long
    
    aUB = UBound(A)
    aLB = LBound(A)
    bLB = LBound(B)
    n = aUB - aLB + 1
    ii = 0
    For i = 1 To n
        ip = indx(i)
        pSum = B(ip + bLB - 1)
        B(ip + bLB - 1) = B(i + bLB - 1)
        If ii Then
            For j = ii To i - 1
                pSum = pSum - A(i + aLB - 1, j + aLB - 1) * B(j + bLB - 1)
            Next j
        ElseIf pSum Then
            ii = i
        End If
        B(i + bLB - 1) = pSum
    Next i
    For i = n To 1 Step -1
        pSum = B(i + bLB - 1)
        For j = i + 1 To n
            pSum = pSum - A(i + aLB - 1, j + aLB - 1) * B(j + bLB - 1)
        Next j
        B(i + bLB - 1) = pSum / A(i + aLB - 1, i + aLB - 1)
    Next i
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Given a matrix a[1,...,n][1,...,n], this routine replaces
&apos;&apos;&apos;     it by the LU decomposition of a rowwise permutation of
&apos;&apos;&apos;     itself. a is input. a is output, indx[1,...,n] is
&apos;&apos;&apos;     an output vector that records the rows permutation effected
&apos;&apos;&apos;     by the partial pivoting; d is output +-1 depending whether
&apos;&apos;&apos;     the number of row interchanges was even or odd, respectively.
&apos;&apos;&apos;     This routine is used in combination with LUbkSub to solve
&apos;&apos;&apos;     linear equations or invert matrix.
&apos;&apos;&apos; &lt;/summary&gt;
Private Sub LUdecomp(ByRef A() As Double, ByRef indx() As Long, _
                        ByRef d As Double)
&apos;@----------------------------------------------------------------------------------------
&apos; Numerical recipes in C: the art of scientific computing / William H. Press [et al.]
&apos; - 2nd ed. (p.46-47)
&apos;-----------------------------------------------------------------------------------------
    Dim n As Long
    Dim i As Long
    Dim imax As Long
    Dim j As Long
    Dim k As Long
    Dim big As Double
    Dim dum As Double
    Dim pSum As Double
    Dim temp As Double
    Dim vv() As Double         &apos;vv stores the implicit scaling of each row
    Dim aLB As Long
    Dim aUB As Long
    
    aUB = UBound(A)
    aLB = LBound(A)
    n = aUB - aLB + 1
    ReDim vv(1 To n)
    ReDim indx(1 To n)
    d = 1                       &apos;No row interchanges yet
    For i = 1 To n              &apos;Loop rows to get the implicit scaling information
        big = 0
        For j = 1 To n
            temp = Abs(A(i + aLB - 1, j + aLB - 1))
            If temp &gt; big Then big = temp
        Next j
        If big = 0 Then         &apos;a is a singular matrix
            Exit Sub
        End If
        &apos;No nonzero largest element
        vv(i) = 1 / big          &apos;Save the scaling
    Next i
    For j = 1 To n               &apos;Loop over columns of Crout&apos;s method
        For i = 1 To j - 1
            pSum = A(i + aLB - 1, j + aLB - 1)
            For k = 1 To i - 1
                pSum = pSum - A(i + aLB - 1, k + aLB - 1) * A(k + aLB - 1, j + aLB - 1)
            Next k
            A(i + aLB - 1, j + aLB - 1) = pSum
        Next i
        big = 0                  &apos;Initialize for search the largest pivot element
        For i = j To n
            pSum = A(i + aLB - 1, j + aLB - 1)
            For k = 1 To j - 1
                pSum = pSum - A(i + aLB - 1, k + aLB - 1) * A(k + aLB - 1, j + aLB - 1)
            Next k
            A(i + aLB - 1, j + aLB - 1) = pSum
            dum = vv(i) * Abs(pSum)
            If dum &gt;= big Then
                big = dum
                imax = i
            End If
        Next i
        If j &lt;&gt; imax Then         &apos;Need rows interchange?
            For k = 1 To n
                dum = A(imax + aLB - 1, k + aLB - 1)
                A(imax + aLB - 1, k + aLB - 1) = A(j + aLB - 1, k + aLB - 1)
                A(j + aLB - 1, k + aLB - 1) = dum
            Next k
            d = -1 * d           &apos;Change parity
            vv(imax) = vv(j)     &apos;Change scale factor
        End If
        indx(j) = imax
        If A(j + aLB - 1, j + aLB - 1) = 0 Then    &apos;Avoid division by zero in singular matrix
            A(j + aLB - 1, j + aLB - 1) = Tiny
        End If
        If j &lt;&gt; n Then           &apos;Divide by the pivot element
            dum = 1 / A(j + aLB - 1, j + aLB - 1)
            For i = j + 1 To n
                A(i + aLB - 1, j + aLB - 1) = A(i + aLB - 1, j + aLB - 1) * dum
            Next i
        End If
    Next j
    Erase vv
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the LU decomposition for the given matrix
&apos;&apos;&apos; &lt;/summary&gt;
Private Function LUdecomposition(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            Dim aArray() As Double
            Dim pivotingIdx() As Long
            Dim d As Double             &apos;Interchages parity
            
            aArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            LUdecomp aArray(), pivotingIdx, d
            tmpEval = ArrayToString(aArray)
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    LUdecomposition = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    LUdecomposition = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Solves the linear system AX = B using LU decomposition. The function
&apos;&apos;&apos;     requires that the &lt;expression&gt; argument be composed of the following:
&apos;&apos;&apos;                     1-) An array in text form containing the coefficients of all equations.
&apos;&apos;&apos;                     2-) An one dimentional array containing the name of each variable
&apos;&apos;&apos;                         (the first name will be applied to the first column of coefficients,
&apos;&apos;&apos;                         the second name to the second column and so on).
&apos;&apos;&apos;                     3-) An one dimentional array containing the right-hand side of each equation,
&apos;&apos;&apos;                         (the first name will be applied to the first column of coefficients,
&apos;&apos;&apos;                         the second name to the second column and so on).
&apos;&apos;&apos;                     4-) A True or False parameter to decide when to include the variable names
&apos;&apos;&apos;                         in the result set.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function LUsolve(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3, 4
            Dim aArray() As Double
            Dim eqCount As Long
            Dim iCounter As Long
            Dim includeNames As Boolean
            Dim mLB As Long
            Dim mUB As Long
            Dim xArray() As String
            Dim bArray() As Double
            Dim tmpElement As String
            
            aArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            bArray() = ToDblArray(ArrayFromString(tmpData(LB + 2)))
            mLB = LBound(aArray)
            mUB = UBound(aArray)
            
            eqCount = mUB - mLB + 1
            LUsolve_ aArray, bArray
            If argsCount = 4 Then
                xArray() = ArrayFromString(tmpData(LB + 1))
                includeNames = CBool(tmpData(UB))
            End If
            For iCounter = mLB To mUB
                If iCounter &gt; mLB Then
                    tmpEval = tmpEval &amp; P_SEPARATORCHAR &amp; d_Space
                End If
                If includeNames Then
                    tmpElement = FormatLiteralString(xArray(iCounter)) _
                                &amp; d_Space &amp; op_equal &amp; d_Space _
                                &amp; bArray(iCounter)
                Else
                    tmpElement = bArray(iCounter)
                End If
                tmpEval = tmpEval &amp; tmpElement
            Next iCounter
            If Not includeNames Then
                tmpEval = d_lCurly &amp; d_lCurly &amp; tmpEval &amp; d_rCurly &amp; d_rCurly
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    LUsolve = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    LUsolve = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function LUsolve_(ByRef aArray() As Double, ByRef bArray() As Double) As Variant
    Dim pivotingIdx() As Long
    Dim d As Double             &apos;Interchages parity
    
    LUdecomp aArray, pivotingIdx, d             &apos;LU decomposition
    LUbkSub aArray, pivotingIdx, bArray         &apos;Back substitution, returning in bArray
    LUsolve_ = bArray
End Function

Private Function Max(ByRef expression As String, ByRef fName As String) As String
    Dim g As Long
    Dim tmpData() As String
    Dim tmpEval As Double
    Dim compEval As Double
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    tmpEval = CDbl(tmpData(LBound(tmpData)))
    For g = LBound(tmpData) + 1 To UBound(tmpData)
        compEval = CDbl(tmpData(g))
        If compEval &gt; tmpEval Then
            tmpEval = compEval
        End If
    Next g
    Max = CStr(tmpEval): Erase tmpData
    Exit Function
err_Handler:
    Max = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MAX_(ParamArray aList() As Variant) As Double
    Dim i As Long
    Dim tmpResult As Double
    Dim tmpEl As Double
    
    i = LBound(aList)
    tmpResult = CDbl(aList(i))
    For i = i + 1 To UBound(aList)
        tmpEl = CDbl(aList(i))
        If tmpEl &gt; tmpResult Then tmpResult = tmpEl
    Next i
    MAX_ = tmpResult
End Function

Private Function Mid_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = ToLiteralString( _
                                        Mid( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case 3
            tmpEval = ToLiteralString( _
                                        Mid( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                CLng(FormatLiteralString(tmpData(LB + 1), True)), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Mid_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Mid_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Min(ByRef expression As String, ByRef fName As String) As String
    Dim g As Long
    Dim tmpData() As String
    Dim tmpEval As Double
    Dim compEval As Double
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    tmpEval = CDbl(tmpData(LBound(tmpData)))
    For g = LBound(tmpData) + 1 To UBound(tmpData)
        compEval = CDbl(tmpData(g))
        If compEval &lt; tmpEval Then
            tmpEval = compEval
        End If
    Next g
    Min = CStr(tmpEval): Erase tmpData
    Exit Function
err_Handler:
    Min = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Takes a list of values of type Long and
&apos;&apos;&apos;     returns the minimum non-zero value.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Values&quot;&gt;The list of values.&lt;/param&gt;
Private Function MinNonZero(ParamArray values() As Variant) As Long
    Dim minTmp As Long
    Dim vIndex As Long
    
    vIndex = LBound(values)
    minTmp = values(vIndex)
    For vIndex = vIndex + 1 To UBound(values)
        If values(vIndex) &gt; 0 Then
            If minTmp Then
                If values(vIndex) &lt; minTmp Then
                    minTmp = values(vIndex)
                End If
            Else
                minTmp = values(vIndex)
            End If
        End If
    Next vIndex
    MinNonZero = minTmp
End Function

Private Function Minute_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = Minute( _
                            FormatLiteralString(tmpData(LB), True) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Minute_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Minute_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MInverse_(ByRef A() As Double, ByRef indx() As Long, _
                        ByRef d As Double) As Variant
&apos;@----------------------------------------------------------------------------------------
&apos; Numerical recipes in C: the art of scientific computing / William H. Press [et al.]
&apos; - 2nd ed. (p.48)
&apos;-----------------------------------------------------------------------------------------
    Dim y() As Double
    Dim col() As Double
    Dim i As Long
    Dim j As Long
    Dim aUB As Long
    Dim aLB As Long
    Dim n As Long
    
    aUB = UBound(A)
    aLB = LBound(A)
    n = aUB - aLB + 1
    ReDim y(0 To n - 1, 0 To n - 1)
    ReDim col(1 To n)
    LUdecomp A, indx, d
    For j = 1 To n
        For i = 1 To n
            col(i) = 0
        Next i
        col(j) = 1
        LUbkSub A, indx, col
        For i = 1 To n
            If Abs(col(i)) = 0 Then col(i) = 0      &apos;Avoid VBA -0 value
            y(i - 1, j - 1) = col(i)
        Next i
    Next j
    MInverse_ = y
End Function

Private Function MIN_(ParamArray aList() As Variant) As Double
    Dim i As Long
    Dim tmpResult As Double
    Dim tmpEl As Double
    
    i = LBound(aList)
    tmpResult = CDbl(aList(i))
    For i = i + 1 To UBound(aList)
        tmpEl = CDbl(aList(i))
        If tmpEl &lt; tmpResult Then tmpResult = tmpEl
    Next i
    MIN_ = tmpResult
End Function

Private Function MIRR_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    Dim idx As Long
    Dim strArray() As String
    Dim dblArray() As Double
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    strArray() = ArrayFromString(tmpData(LB)) &apos;Get array of data
    ReDim dblArray(LBound(strArray) To UBound(strArray))
    For idx = LBound(strArray) To UBound(strArray) &apos;Copy to double array
        dblArray(idx) = CDbl(FormatLiteralString(strArray(idx), True))
    Next idx
    Select Case argsCount
        Case 3
            tmpEval = MIRR(dblArray, _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(UB), True)))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MIRR_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    MIRR_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Performs a multiple linear regression over a model with more than to regressors/predictors.
&apos;&apos;&apos;     The parameters required by the functions are:
&apos;&apos;&apos;         1- X: the model NxK matrix with K regressors variables for all the N observations.
&apos;&apos;&apos;         2- Y: a Nx1 vector with N observations for the model.
&apos;&apos;&apos;         3- formatOutput: a boolean indicating when to format the output as polynomial.
&apos;&apos;&apos;         4-PredInteractions: an optional list of interactions between predictors in the model.
&apos;&apos;&apos;             This parameter use the syntax &apos;X#:X#;...;X#:X#&apos; for nominal predictors.
&apos;&apos;&apos;             The # symbol indicates the position of the predictor X# in the model matrix
&apos;&apos;&apos;             The alternative syntax is &apos;$#:$#;...;$#:$#&apos;, where the symbol $ refers to a predictor
&apos;&apos;&apos;             name from the PredNames list. If named predictors are used, the list of predictors
&apos;&apos;&apos;             names must be supplied.
&apos;&apos;&apos;         5-PredNames: an optional list of names for all the predictors in the model in &apos;$;$;$&apos; format.
&apos;&apos;&apos;     NOTES: for a predictors relation X{i}:X{j} the method will ensure i&gt;=j.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function MLR(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3, 4, 5
            Dim x() As Double
            Dim y() As Double
            Dim tmpResult() As Double
            Dim formatOutput As Boolean
            Dim k As Long
            Dim m As Long
            Dim Rsquared As Double
            Dim Rsquared_adj As Double
            Dim fittedPolynomial As String
            
            x = ToDblArray(ArrayFromString(tmpData(LB)))
            y = ToDblArray(ArrayFromString(tmpData(LB + 1)))
            formatOutput = CBool(tmpData(LB + 2))
            m = UBound(x, 2) - LBound(x, 2) + 1 &apos;Number of regressors/predictors on user input
            AddIntersectionCol x
            If argsCount &gt; 3 Then
                Dim PredInteractions() As String
                
                If argsCount = 4 Then
                    PredInteractions = Split(GetPredInterNames(GetPredInterArr(tmpData(LB + 3), m)), P_SEPARATORCHAR)
                Else
                    PredInteractions = Split(GetPredInterNames(GetPredInterArr(tmpData(LB + 3), m, tmpData(LB + 4))), P_SEPARATORCHAR)
                End If
                AddPredictorsRelations x, PredInteractions
            End If
            k = UBound(x, 2) - LBound(x, 2) &apos;Total number of predictors on model
             &apos;Saves goodness of fit to the Rsquared and Rsquared_adj parameters
            tmpResult = MLR_(x, y, k, Rsquared, Rsquared_adj:=Rsquared_adj)
            If formatOutput Then
                If argsCount &gt; 3 Then
                    If argsCount = 5 Then
                        fittedPolynomial = RegressionString(tmpResult, _
                                        Split(FormatLiteralString(tmpData(LB + 4), True), P_SEPARATORCHAR), _
                                        PredInteractions)
                    Else
                        fittedPolynomial = RegressionString(tmpResult, PredInteractions:=PredInteractions)
                    End If
                Else
                    fittedPolynomial = RegressionString(tmpResult)
                End If
                tmpEval = d_lCurly &amp; _
                        d_lCurly &amp; fittedPolynomial &amp; d_rCurly &amp; P_SEPARATORCHAR &amp; _
                        d_lCurly &amp; CStr(Rsquared) &amp; P_SEPARATORCHAR &amp; _
                        CStr(Rsquared_adj) &amp; d_rCurly &amp; d_rCurly
            Else
                tmpEval = d_lCurly &amp; _
                        d_lCurly &amp; ArrayToString(MROUND_(tmpResult, 4)) &amp; d_rCurly &amp; _
                        P_SEPARATORCHAR &amp; d_lCurly &amp; CStr(Rsquared) &amp; P_SEPARATORCHAR &amp; _
                        CStr(Rsquared_adj) &amp; d_rCurly &amp; d_rCurly
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MLR = tmpEval: Erase tmpData, tmpResult
    Exit Function
err_Handler:
    MLR = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MLR_(x() As Double, y() As Double, Optional k As Long = -1, _
                        Optional ByRef Rsquared As Double, _
                        Optional ByRef standardError As Double, _
                        Optional ByRef Rsquared_adj As Double) As Variant
    Dim Xt() As Double
    Dim XtX() As Double
    Dim XtY() As Double
    Dim XtXInv() As Double
    Dim indx() As Long
    Dim Betahat() As Double
    Dim yhat() As Double
    Dim e() As Double
    Dim sigmaSquared As Double
    Dim ymean As Double
    Dim d As Double
    Dim n As Long
    Dim p As Long
    Dim SSE As Double
    Dim SST As Double
    Dim i As Long
    Dim tmpY() As Double
    
    If Not Is2Darray(y) Then
        tmpY = RowColVectTransform(y)
    Else
        tmpY = y
    End If
    Xt = MTranspose_(x) &apos;Transpose of X
    XtX = ToDblArray(MMULT_(Xt, x)) &apos;Transpose of X multiplied by X
    XtY = ToDblArray(MMULT_(Xt, tmpY)) &apos;Transpose of X multiplied by Y column vector
    XtXInv = MInverse_(XtX, indx, d)
    Betahat = ToDblArray(MMULT_(XtXInv, XtY))
    If k &gt; 0 Then
        &apos;Compute goodness of fit
        n = UBound(y) - LBound(y) + 1 &apos;Number of observations in the model
        p = k + 1 &apos;Number of parameters in the model
        yhat = ToDblArray(MMULT_(x, Betahat)) &apos;Predictions
        e = MSum_(tmpY, yhat, True)    &apos;Residuals
        ymean = ColumnAvg(y)
        For i = 0 To n - 1
            SSE = SSE + e(i, 0) ^ 2
            SST = SST + (y(i) - ymean) ^ 2
        Next i
        If n &gt; p Then
            sigmaSquared = SSE / (n - p) &apos;Squared standard error
        Else
            sigmaSquared = 1.79769313486231E+308
        End If
        Rsquared = Round(1 - SSE / SST, 4)
        standardError = Round(Sqr(sigmaSquared), 4)
        Rsquared_adj = Round(1 - (1 - Rsquared) * (n - 1) / (n - k - 1), 4)
    End If
    MLR_ = Betahat
    Erase Xt, XtX, XtY, XtXInv, indx, yhat, e, tmpY
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Multiplies 2 matrices A and B. Matrix B can be a column vector or
&apos;&apos;&apos;     an scalar number.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function MMult(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    Dim tmpOP As Variant
    Dim bIsMatrix As Boolean
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            bIsMatrix = strVBA.InStrB(1, tmpData(UB), &quot;{{&quot;)
            If bIsMatrix Then
                tmpOP = MMULT_( _
                                ToDblArray(ArrayFromString(tmpData(LB))), _
                                ToDblArray(ArrayFromString(tmpData(UB))))
            Else
                tmpOP = MMULT_( _
                                ToDblArray(ArrayFromString(tmpData(LB))), _
                                CDbl(tmpData(UB)))
            End If
            If IsArray(tmpOP) Then
                tmpEval = ArrayToString(tmpOP)
            Else
                tmpEval = CStr(tmpOP)
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MMult = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    MMult = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MMULT_(ByRef A() As Double, ByRef B As Variant) As Variant
    Dim aIsVector As Boolean
    Dim aLB As Long, aLB2 As Long
    Dim aUB As Long, aUB2 As Long
    Dim bIsVector As Boolean
    Dim bLB As Long, bLB2 As Long
    Dim bUB As Long, bUB2 As Long
    Dim c() As Double
    Dim i As Long
    Dim j As Long, jj As Long
    Dim m As Long
    Dim n As Long
    Dim OutputIsArray As Boolean
    Dim pSum As Double
    
    aIsVector = Not Is2Darray(A) And IsArray(A)
    bIsVector = Not Is2Darray(B) And IsArray(B)
    OutputIsArray = True
    If aIsVector And bIsVector Then     &apos;Compute dot product
        aLB2 = LBound(A): aUB2 = UBound(A)
        bLB2 = LBound(B): bUB2 = UBound(B)
        n = aUB2 - aLB2 + 1
        m = bUB2 - bLB2 + 1
        If m = n Then   &apos;Require equal columns count
            For i = 0 To n - 1 &apos;Loop a() rows
                pSum = pSum + A(aLB2 + i) * B(bLB2 + i)
            Next i
            OutputIsArray = False
        End If
    ElseIf (aIsVector And Not IsArray(B)) Or _
            (Not aIsVector And Not IsArray(B)) Then &apos;1D or 2D array x scalar
        If IsArray(A) Then
            If aIsVector Then
                aLB = LBound(A): aUB = UBound(A)
                m = aUB - aLB + 1
                ReDim c(0 To m - 1)
                For i = 0 To m - 1
                    c(i) = A(aLB + i) * B
                Next i
            Else
                aLB = LBound(A): aUB = UBound(A)
                aLB2 = LBound(A, 2): aUB2 = UBound(A, 2)
                n = aUB - aLB + 1
                m = aUB2 - aLB2 + 1
                ReDim c(0 To n - 1, 0 To m - 1)
                For i = 0 To n - 1
                    For j = 0 To m - 1
                        c(i, j) = A(aLB + i, aLB2 + j) * B
                    Next j
                Next i
            End If
        End If
    ElseIf aIsVector And IsArray(B) Then &apos;1D array x 2D array
        VM_DOT_ A, B, aLB, aLB2, aUB, _
                aUB2, bLB2, bUB2, c, i, j, _
                m, n, pSum, bLB, bUB, jj
    ElseIf Not aIsVector And Not bIsVector Then &apos;2D array x 2D array
        MM_DOT_ A, B, aLB, aLB2, aUB, _
                aUB2, bLB, bLB2, bUB, _
                bUB2, c, i, j, jj, m, n, pSum
    ElseIf Not aIsVector And bIsVector Then &apos;2D array x 1D array
        MV_DOT_ A, B, aLB, aLB2, aUB, _
                aUB2, bLB, bLB2, bUB, _
                bUB2, c, i, j, jj, m, n, pSum
    End If
    If OutputIsArray Then
        If IsArrayAllocated(c) Then
            MMULT_ = c
        Else
            MMULT_ = e_ValueError
        End If
    Else
        MMULT_ = pSum
    End If
End Function

Private Sub MM_DOT_(ByRef A() As Double, ByRef B As Variant, ByRef aLB As Long, ByRef aLB2 As Long, ByRef aUB As Long, _
                    ByRef aUB2 As Long, ByRef bLB As Long, ByRef bLB2 As Long, ByRef bUB As Long, ByRef bUB2 As Long, _
                    ByRef c() As Double, ByRef i As Long, ByRef j As Long, ByRef jj As Long, ByRef m As Long, _
                    ByRef n As Long, ByRef pSum As Double)
                    
    aLB = LBound(A): aUB = UBound(A)
    aLB2 = LBound(A, 2): aUB2 = UBound(A, 2)
    bLB = LBound(B): bUB = UBound(B)
    bLB2 = LBound(B, 2): bUB2 = UBound(B, 2)
    n = aUB - aLB + 1
    m = bUB2 - bLB2 + 1
    If Not (aUB2 - aLB2 + 1) &lt;&gt; (bUB - bLB + 1) Then
        ReDim c(0 To n - 1, 0 To m - 1)
        For i = 0 To n - 1
            For j = 0 To m - 1
                pSum = 0
                For jj = 0 To aUB2 - aLB2
                    pSum = pSum + A(aLB + i, aLB2 + jj) * B(bLB + jj, bLB2 + j)
                Next jj
                c(i, j) = pSum
            Next j
        Next i
    End If
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns the negation of the given matrix.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;aMatrix&quot;&gt;The matrix to negate.&lt;/param&gt;
Private Function MNEG(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ArrayToString(MNEG_( _
                            ToDblArray(ArrayFromString(tmpData(LB))) _
                            ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MNEG = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    MNEG = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MNEG_(ByRef aMatrix() As Double) As Variant
    Dim mLB As Long
    Dim mLB2 As Long
    Dim mUB As Long
    Dim mUB2 As Long
    Dim i As Long, j As Long
    Dim ii As Long, jj As Long
    Dim tmpResult() As Double
    
    If Not IsArray(aMatrix) Then Exit Function
    mLB = LBound(aMatrix)
    mUB = UBound(aMatrix)
    If Is2Darray(aMatrix) Then
        mLB2 = LBound(aMatrix, 2)
        mUB2 = UBound(aMatrix, 2)
        ReDim tmpResult(0 To mUB - mLB, 0 To mUB2 - mLB2)
        For i = mLB To mUB
            jj = 0
            For j = mLB2 To mUB2
                If Abs(aMatrix(i, j)) Then tmpResult(ii, jj) = -1 * aMatrix(i, j)
                jj = jj + 1
            Next j
            ii = ii + 1
        Next i
    Else
        ReDim tmpResult(0 To mUB - mLB)
        For i = mLB To mUB
            If Abs(aMatrix(i, j)) Then tmpResult(ii) = -1 * aMatrix(i)
            ii = ii + 1
        Next
    End If
    MNEG_ = tmpResult
End Function

Private Function MonthName_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ToLiteralString(MonthName( _
                                            CLng(FormatLiteralString(tmpData(LB), True)) _
                                            ))
        Case 2
            tmpEval = ToLiteralString(MonthName( _
                                            CLng(FormatLiteralString(tmpData(LB), True)), _
                                            CBool(FormatLiteralString(tmpData(UB), True)) _
                                            ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MonthName_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    MonthName_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Month_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = Month( _
                            FormatLiteralString(tmpData(LB), True) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Month_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Month_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Rounds the list of arrays to the number of significant digits given. The
&apos;&apos;&apos;     last argument is interpreted as the significant digits for two or more called arguments.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;List&quot;&gt;The list of arrays to be rounded.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;DecPlaces&quot;&gt;Significance.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;ExtPoint&quot;&gt;An external or tangent point for the circle.&lt;/param&gt;
Private Function MROUND(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ArrayToString(MROUND_( _
                            ToDblArray(ArrayFromString(tmpData(LB))) _
                            ))
        Case Is &gt;= 2  &apos;Round a list of arrays
            Dim i As Long
            Dim tmpRounds() As String
            
            ReDim tmpRounds(0 To argsCount - 2)
            For i = 1 To argsCount - 1
                tmpRounds(i - 1) = ArrayToString(MROUND_( _
                                        ToDblArray(ArrayFromString(tmpData(i - 1))), _
                                        CDbl(tmpData(UB)) _
                                        ))
            Next i
            tmpEval = Join(tmpRounds, P_SEPARATORCHAR)
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MROUND = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    MROUND = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MROUND_(ByRef aArray() As Double, Optional nDigits As Long = 0) As Variant
    Dim i As Long, j As Long
    Dim LB1 As Long, LB2 As Long
    Dim UB1 As Long, UB2 As Long
    Dim tmpResult() As Double
    
    If Is2Darray(aArray) Then
        UB1 = UBound(aArray): LB1 = LBound(aArray)
        UB2 = UBound(aArray, 2): LB2 = LBound(aArray, 2)
        ReDim tmpResult(0 To UB1 - LB1, 0 To UB2 - LB2)
        For i = LB1 To UB1
            For j = LB2 To UB2
                tmpResult(i - LB1, j - LB2) = Round(aArray(i, j), nDigits)
            Next j
        Next i
    Else
        UB1 = UBound(aArray): LB1 = LBound(aArray)
        ReDim tmpResult(0 To UB1 - LB1)
        For i = LB1 To UB1
            tmpResult(i - LB1) = Round(aArray(i), nDigits)
        Next i
    End If
    MROUND_ = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Sum 2 matrices A and B when A and B has same number of
&apos;&apos;&apos;     rows and columns. With the last argument set to True
&apos;&apos;&apos;     A - B is computed instead of A + B
&apos;&apos;&apos; &lt;/summary&gt;
Private Function MSum(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = ArrayToString(MSum_( _
                                ToDblArray(ArrayFromString(tmpData(LB))), _
                                ToDblArray(ArrayFromString(tmpData(UB)))) _
                                )
        Case 3
            tmpEval = ArrayToString(MSum_( _
                                ToDblArray(ArrayFromString(tmpData(LB))), _
                                ToDblArray(ArrayFromString(tmpData(LB + 1))), _
                                CBool(tmpData(UB))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MSum = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    MSum = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MSum_(ByRef A() As Double, ByRef B() As Double, _
                        Optional Difference As Boolean = False) As Variant
    Dim c() As Double
    Dim LBa As Long
    Dim LBa2 As Long
    Dim UBb As Long
    Dim LBb As Long
    Dim LBb2 As Long
    Dim m As Long
    Dim n As Long
    Dim i As Long
    Dim j As Long
    Dim pSum As Double
    Dim aFlag As Boolean
    Dim bFlag As Boolean
    
    LBa = LBound(A)
    LBb = LBound(B)
    UBb = UBound(B)
    aFlag = Is2Darray(A)
    bFlag = Is2Darray(B)
    If aFlag And bFlag Then &apos;Two 2D matrices
        LBa2 = LBound(A, 2)
        n = UBound(A) - LBa + 1
        m = UBound(A, 2) - LBa2 + 1
        LBb2 = LBound(B, 2)
        If UBb - LBb + 1 &lt;&gt; n Then Exit Function    &apos;Required equal numbers of rows
        If UBound(B, 2) - LBb2 + 1 &lt;&gt; m Then Exit Function     &apos;Required equal numbers of columns
        ReDim c(0 To n - 1, 0 To m - 1)
        For i = 0 To n - 1
            For j = 0 To m - 1
                If Not Difference Then
                    pSum = A(i + LBa, j + LBa2) + B(i + LBb, j + LBb2)
                Else
                    pSum = A(i + LBa, j + LBa2) - B(i + LBb, j + LBb2)
                End If
                c(i, j) = pSum
            Next j
        Next i
    Else
        If Not aFlag And Not bFlag Then &apos;Two vectors
            n = UBound(A) - LBa + 1
            If UBb - LBb + 1 &lt;&gt; n Then Exit Function
            ReDim c(0 To n - 1)
            For i = 0 To n - 1
                If Not Difference Then
                    pSum = A(i + LBa) + B(i + LBb)
                Else
                    pSum = A(i + LBa) - B(i + LBb)
                End If
                c(i) = pSum
            Next i
        Else &apos;One vector and one 2D matrix
            Dim M2D() As Double
            Dim VECT1D() As Double
            Dim lbM2D As Long
            Dim ubM2D As Long
            Dim lb2M2D As Long
            Dim ub2M2D As Long
            Dim lbV1D As Long
            Dim ubV1D As Long
            Dim invertedSumFlag As Boolean
            
            If aFlag Then &apos;A is the 2D matrix
                M2D = A
                lbM2D = LBa
                ubM2D = UBound(A)
                VECT1D = B
                lbV1D = LBb
                ubV1D = UBb
                invertedSumFlag = False
            Else
                M2D = B
                lbM2D = LBb
                ubM2D = UBb
                VECT1D = A
                lbV1D = LBa
                ubV1D = UBound(A)
                invertedSumFlag = True
            End If
            lb2M2D = LBound(M2D, 2)
            ub2M2D = UBound(M2D, 2)
            If ub2M2D - lbM2D + 1 = 1 Then &apos;Vector expressed as 2d matrix
                n = ubV1D - lbV1D + 1
                If ubM2D - lbM2D + 1 &lt;&gt; n Then Exit Function
                ReDim c(0 To n - 1)
                For i = 0 To n - 1
                    If Not Difference Then
                        pSum = M2D(i + lbM2D, lb2M2D) + VECT1D(i + lbV1D)
                    Else &apos;Always compute A-B
                        If Not invertedSumFlag Then
                            pSum = M2D(i + lbM2D, lb2M2D) - VECT1D(i + lbV1D)
                        Else
                            pSum = VECT1D(i + lbV1D) - M2D(i + lbM2D, lb2M2D)
                        End If
                    End If
                    c(i) = pSum
                Next i
            End If
        End If
    End If
    MSum_ = c
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes an array transposition
&apos;&apos;&apos; &lt;/summary&gt;
Private Function MTranspose(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ArrayToString(MTranspose_( _
                                ToDblArray(ArrayFromString(tmpData(LB)))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    MTranspose = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    MTranspose = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function MTranspose_(ByRef A() As Double) As Variant
    Dim c() As Double
    Dim LBa As Long
    Dim LBa2 As Long
    Dim UBa As Long
    Dim UBa2 As Long
    Dim m As Long
    Dim n As Long
    Dim i As Long
    Dim j As Long
    Dim Is1Darray As Boolean
    
    Is1Darray = Not Is2Darray(A)
    If Not Is1Darray Then
        LBa = LBound(A)
        UBa = UBound(A)
        LBa2 = LBound(A, 2)
        UBa2 = UBound(A, 2)
    Else
        LBa = 0
        UBa = LBa
        LBa2 = LBound(A)
        UBa2 = UBound(A)
    End If

    n = UBa - LBa + 1
    m = UBa2 - LBa2 + 1
    ReDim c(0 To m - 1, 0 To n - 1)
    For i = 0 To n - 1
        For j = 0 To m - 1
            If Not Is1Darray Then
                c(j, i) = A(LBa + i, LBa2 + j)
            Else
                c(j, i) = A(LBa + j)
            End If
        Next j
    Next i
    MTranspose_ = c
End Function

Private Sub MV_DOT_(ByRef A() As Double, ByVal B As Variant, ByVal aLB As Long, ByVal aLB2 As Long, _
                    ByVal aUB As Long, ByVal aUB2 As Long, ByVal bLB As Long, ByVal bLB2 As Long, _
                    ByVal bUB As Long, ByVal bUB2 As Long, ByRef c() As Double, ByVal i As Long, _
                    ByVal j As Long, ByVal jj As Long, ByVal m As Long, ByVal n As Long, ByRef pSum As Double)
                    
    aLB = LBound(A): aUB = UBound(A)
    aLB2 = LBound(A, 2): aUB2 = UBound(A, 2)
    bLB = 0: bUB = 0
    bLB2 = LBound(B): bUB2 = UBound(B)
    n = aUB - aLB + 1
    m = bUB2 - bLB2 + 1
    If Not (aUB2 - aLB2 + 1) &lt;&gt; (bUB - bLB + 1) Then
        ReDim c(0 To n - 1, 0 To m - 1)
        For i = 0 To n - 1
            For j = 0 To m - 1
                pSum = 0
                For jj = 0 To aUB2 - aLB2
                    pSum = pSum + A(aLB + i, aLB2 + jj) * B(bLB2 + j)
                Next jj
                c(i, j) = pSum
            Next j
        Next i
    End If
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Takes a list of values of type Long and
&apos;&apos;&apos;     returns true if one of then is a non-zero value.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Values&quot;&gt;The list of values.&lt;/param&gt;
Private Function NonZero(ParamArray values() As Variant) As Boolean
    Dim tmpResult As Boolean
    Dim vIndex As Long
    Dim valuesUB As Long
    
    vIndex = LBound(values)
    valuesUB = UBound(values)
    Do
        tmpResult = (values(vIndex) &gt; 0)
        vIndex = vIndex + 1
    Loop While Not tmpResult And vIndex &lt;= valuesUB
    NonZero = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the two-tailed probability value forstandard normal curve,
&apos;&apos;&apos;     given a Z-score (i.e., the two-tailed probability from +/- the
&apos;&apos;&apos;     Z-score to infinity on both tails of the distribution).
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;z&quot;&gt;Z-score.&lt;/param&gt;
Private Function NORM(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = NORM_( _
                            CDbl(tmpData(LB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    NORM = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    NORM = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function NORM_(z As Double) As Double
    Dim q As Double
    q = z * z
    If (Abs(z) &gt; 7) Then
        NORM_ = (1 - 1 / q + 3 / (q * q)) * Exp(-q / 2) / (Abs(z) * Sqr(PID2))
    Else
        NORM_ = CHISQ_(q, 1)
    End If
End Function

Private Function NotIsPI(ByRef varName As String) As Boolean
    NotIsPI = Not (varName Like &quot;[Pp][Ii]&quot;)
End Function

Private Function Now_(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    If expression &lt;&gt; vbNullString Then
        Now_ = ToLiteralString(Now)
    End If
    Exit Function
err_Handler:
    Now_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function NPER_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = NPer(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 4
            tmpEval = NPer(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = NPer(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CLng((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    NPER_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    NPER_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function NPV_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Double
    Dim iRate As Double
    Dim pCounter As Long
    Dim LB As Long, UB As Long
    Dim cLooper As Long
    Dim strArray() As String
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            strArray() = ArrayFromString(tmpData(UB)) &apos;Get array of data
            iRate = CDbl(tmpData(LB))
            pCounter = 1
            For cLooper = LBound(strArray) To UBound(strArray)
                tmpEval = tmpEval + CDbl(strArray(cLooper)) / ((1 + iRate) ^ pCounter)
                pCounter = pCounter + 1
            Next cLooper
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    NPV_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    NPV_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function OPsymbolInArgument(ByRef ArgDefStr As String, ByRef Pattrn As String) As Boolean
    Dim i As Long
    Dim tmpResult As Boolean
    Dim LenStr As Long
    
    i = 1
    LenStr = strVBA.LenB2(ArgDefStr)
    Do
        tmpResult = strVBA.InStrB(1, strVBA.MidB(ArgDefStr, i, 2), Pattrn)
        i = i + 2
    Loop While i &lt;= LenStr And Not tmpResult
    OPsymbolInArgument = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Tries to retrieve a value from a given array name
&apos;&apos;&apos;     Expected one or two indexes for the operation.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function OverLoadVarName(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression) &apos;Expected simple integers list
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1, 2
            Dim vIdx As Long
            
            vIdx = P_SCOPE.VarIndex(fName)
            If Not P_SCOPE.GetAssignedArray(vIdx) Or Not P_SCOPE.GetAssignedArray(vIdx) Then
                P_SCOPE.LetVarValue2(fName, True, P_SCOPE.GetVarValue(fName))
            End If
            If argsCount = 1 Then
                tmpEval = CStr(P_SCOPE.GetVarValue2(fName, True)(CLng(tmpData(LB))))
            Else
                tmpEval = CStr(P_SCOPE.GetVarValue2(fName, True)(CLng(tmpData(LB)), CLng(tmpData(UB))))
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    OverLoadVarName = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    OverLoadVarName = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Parses an expression and builds a parse tree. The
&apos;&apos;&apos;     computed data is ready for traverse and evaluate.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Expression&quot;&gt;The expression to parse.&lt;/param&gt;
Private Sub Parse(ByRef expression As String)
    Dim lambdaText As String
    Dim meLB As Long
    Dim meUB As Long
    Dim meCounter As Long
    Dim SimpleExpr As Boolean
    Dim TreeUB As Long
    Dim LbrCount As Long
    Dim RbrCount As Long
    
    On Error GoTo Parse_errHandler
    InitializeErrHandler
    LbrCount = CountParentheses(expression, d_lParenthesis)
    RbrCount = CountParentheses(expression, d_rParenthesis)
    If LbrCount &lt;&gt; RbrCount Then
        If LbrCount &gt; RbrCount Then
            BuildErrMessage errUnbalancedBrackets, &quot;At least one right parenthesis [)] is missing.&quot;
        Else
            BuildErrMessage errUnbalancedBrackets, &quot;At least one left parenthesis [(] is missing.&quot;
        End If
        Exit Sub
    End If
    err.Clear
    SubTreeData = GetSubTreeData(expression)
    lambdaText = SerializeSubTree(expression, SubTreeData)
    meLB = LBound(SubTreeData)
    meUB = UBound(SubTreeData)
    SimpleExpr = (meUB - meLB = 0 And lambdaText = SubTreeData(meUB))
    TreeUB = meUB + Abs(CLng(Not SimpleExpr)) &apos;Upper bound for ClusterTree array
    
    ReDim EvalTree(meLB To TreeUB)
    For meCounter = meLB To TreeUB
    	InitBuffer EvalTree(meCounter)
    Next meCounter
    For meCounter = meLB To TreeUB
        InitBuffer EvalTree(meCounter)   &apos;Reserve storage for tree branches/Expressions
        If meCounter &lt; TreeUB Then          &apos;Tokenize branches
            TokenizeSubExpr SubTreeData(meCounter), SubTreeData, EvalTree(meCounter)
        Else
            If Not SimpleExpr Then          &apos;Tokenize main tree/lambda expression
                TokenizeSubExpr lambdaText, SubTreeData, EvalTree(meCounter)
            Else
                TokenizeSubExpr SubTreeData(meCounter), SubTreeData, EvalTree(meCounter)
            End If
        End If
        ShrinkBuffer EvalTree(meCounter)
    Next meCounter
    If ValidTree Then    &apos;Call the validate function
        DetermineKtokens &apos;Detect constants tokens
        GeneratedTree = True
    Else
        GeneratedTree = False
        If P_ERRTYPE = errNone Then
            BuildErrMessage errSyntaxError
        End If
    End If
    Exit Sub
Parse_errHandler:
    BuildErrMessage errSyntaxError, err.Description &amp; &quot;.&quot;
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Parses variables in an expression and resolves implicit multiplications.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Expression&quot;&gt;The expression to parse.&lt;/param&gt;
Private Sub ParseVariables(ByRef expression As String)
    Dim curPos As Long
    Dim lenExpr As Long
    Dim varInitPos As Long
    Dim varLen As Long
    Dim tmpChr As String
    Dim tmpVar As String
    Dim tmpPos As Long
    Dim ConstantKey As String
    Dim charsBefore As String
    
    curPos = 1
    lenExpr = strVBA.LenB2(expression)
    Do
        tmpChr = strVBA.MidB(expression, curPos, 2)
        varLen = 0
        If IsLetter(tmpChr) Or tmpChr = d_Apostrophe Or tmpChr = d_Underscore Then
            varInitPos = curPos
            If tmpChr &lt;&gt; d_Apostrophe And tmpChr &lt;&gt; d_Underscore Then
                Do
                    varLen = varLen + 2
                    curPos = curPos + 2
                    tmpChr = strVBA.MidB(expression, curPos, 2)
                Loop While IsExtAlphaNumeric(tmpChr) And curPos &lt; lenExpr
            Else
                If tmpChr = d_Apostrophe Then
                    curPos = strVBA.InStrB(varInitPos + 2, expression, d_Apostrophe)
                Else
                    curPos = strVBA.InStrB(varInitPos + 2, expression, d_Underscore)
                End If
                varLen = curPos - varInitPos + 2
            End If
            If varInitPos &gt; 2 Then
                tmpPos = varInitPos - 2
            Else
                tmpPos = varInitPos
            End If
            If Not IsDigit(strVBA.MidB(expression, tmpPos, 2)) Then  &apos;Variables start with a letter
                tmpVar = strVBA.MidB(expression, varInitPos, varLen)
                If Not ReservedToken(tmpVar) Then
                    If GetFunctionName(LCase$(tmpVar)) = vbNullString Then
                        If Not IsLiteralString(tmpVar) Then &apos;Exclude literal strings
                            AddVariable tmpVar, ConstantKey
                        End If
                    End If
                End If
            Else
                tmpVar = strVBA.MidB(expression, varInitPos, varLen)
                If Not ReservedToken(tmpVar) Then
                    tmpPos = GoBackToOpSymbol(expression, varInitPos) + 1
                    charsBefore = strVBA.MidB(expression, tmpPos + 1, varInitPos - (tmpPos + 1)) &apos;Chars before variable
                    If IsNumeric(charsBefore) Then &apos;implied multiplication found
                        If GetFunctionName(LCase$(tmpVar)) = vbNullString Then
                            If Not IsLiteralString(tmpVar) Then
                                AddVariable tmpVar, ConstantKey
                            End If
                        End If
                        expression = strVBA.MidB(expression, 1, varInitPos - strVBA.LenB2(charsBefore) - 1) &amp; _
                                        charsBefore &amp; op_mult &amp; tmpVar &amp; _
                                        strVBA.MidB(expression, varInitPos + strVBA.LenB2(tmpVar))
                        lenExpr = strVBA.LenB2(expression)
                    End If
                End If
            End If
        End If
        curPos = curPos + 2
    Loop While curPos &lt; lenExpr
End Sub

Private Function PatternToCheckOn(ByRef ArgDefStr As String) As String
    If strVBA.LenB2(ArgDefStr) Then
        Select Case AscW(ArgDefStr)
            Case 43, 45
                PatternToCheckOn = op_AllNotUnaryItems
            Case Else
                PatternToCheckOn = op_AllItems
        End Select
    Else
        PatternToCheckOn = op_AllItems
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns two points representing a line parallel to the given one and
&apos;&apos;&apos;     containing the given point.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Line&quot;&gt;Array of coordinates in format {{x1;y1};{x2;y2}}.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;Point&quot;&gt;Array of coordinates in format {{x;y}}.&lt;/param&gt;
Private Function ParallelLine(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Variant
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = ArrayToString(ParallelLine_( _
                                                ToDblArray(ArrayFromString(tmpData(LB))), _
                                                ToDblArray(ArrayFromString(tmpData(UB))) _
                                            ) _
                                        )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    ParallelLine = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    ParallelLine = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ParallelLine_(aLine() As Double, Point() As Double) As Variant
    Dim aTerm As Double
    Dim bTerm As Double
    Dim cTerm As Double
    Dim pointArr(0 To 1) As Variant
    Dim tmpArr(0 To 1) As Double
    Dim result2D(0 To 1, 0 To 1) As Double
    
    aTerm = aLine(0, 1) - aLine(1, 1) &apos;y1-y2
    bTerm = aLine(1, 0) - aLine(0, 0) &apos;x2-x1
    cTerm = aLine(0, 0) * aLine(1, 1) _
            - aLine(1, 0) * aLine(0, 1) &apos;x1*y2-x2*y1
    pointArr(0) = Point
    If aTerm &lt;&gt; 0 And bTerm &lt;&gt; 0 Then
        tmpArr(0) = 0
        tmpArr(1) = (aTerm * Point(0) + bTerm * Point(1)) / bTerm
    Else
        If aTerm = 0 Then &apos;Horizontal line
            tmpArr(0) = Point(0) - Point(1) + 1
            tmpArr(1) = Point(1)
        Else &apos;Vertical line
            tmpArr(0) = Point(0)
            tmpArr(1) = Point(0) - Point(1) + 1
        End If
    End If
    pointArr(1) = tmpArr
    result2D(0, 0) = pointArr(0)(0): result2D(0, 1) = pointArr(0)(1)
    result2D(1, 0) = pointArr(1)(0): result2D(1, 1) = pointArr(1)(1)
    Erase pointArr
    ParallelLine_ = result2D
End Function

Private Function Percent(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    Percent = CDbl(expression) / 100
    Exit Function
err_Handler:
    Percent = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns two points representing a line perpendicular to the
&apos;&apos;&apos;     given one and containing the given point.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Line&quot;&gt;Array of coordinates in format {{x1;y1};{x2;y2}}.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;Point&quot;&gt;Array of coordinates in format {{x;y}}.&lt;/param&gt;
Private Function PerpendicularLine(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = ArrayToString(PerpendicularLine_( _
                                        ToDblArray(ArrayFromString(tmpData(LB))), _
                                        ToDblArray(ArrayFromString(tmpData(UB))) _
                                    ) _
                            )
        Case Else
            tmpEval = e_ValueError
            BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    PerpendicularLine = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    PerpendicularLine = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function PerpendicularLine_(aLine() As Double, Point() As Double) As Variant
    Dim aTerm As Double
    Dim bTerm As Double
    Dim cTerm As Double
    Dim pointArr(0 To 1) As Variant
    Dim tmpArr(0 To 1) As Double
    Dim result2D(0 To 1, 0 To 1) As Double
    
    aTerm = aLine(0, 1) - aLine(1, 1) &apos;y1-y2
    bTerm = aLine(1, 0) - aLine(0, 0) &apos;x2-x1
    cTerm = aLine(0, 0) * aLine(1, 1) _
            - aLine(1, 0) * aLine(0, 1) &apos;x1*y2-x2*y1
    pointArr(0) = Point
    If aTerm &lt;&gt; 0 And bTerm &lt;&gt; 0 Then
        &apos; (-c*a+b(b*x3-a*y3))/(a^2 + b^2)
        tmpArr(0) = (-cTerm * aTerm + bTerm * (bTerm * Point(0) - aTerm * Point(1))) _
                        / _
                    (aTerm ^ 2 + bTerm ^ 2)
        &apos; (-a(b*x3-a*y3)-b*c)/(a^2 + b^2)
        tmpArr(1) = (-aTerm * (bTerm * Point(0) - aTerm * Point(1)) - bTerm * cTerm) _
                        / _
                    (aTerm ^ 2 + bTerm ^ 2)
        If Round(pointArr(0)(0), 4) = Round(tmpArr(0), 4) And _
                    Round(pointArr(0)(1), 4) = Round(tmpArr(1), 4) Then &apos;Known point is the intersection
            tmpArr(0) = pointArr(0)(0) + 1
            tmpArr(1) = pointArr(0)(1) + bTerm / aTerm
        End If
    Else
        If aTerm = 0 Then &apos;Horizontal line
            tmpArr(0) = Point(0)
            tmpArr(1) = Point(0) - Point(1) + 1
        Else  &apos;Vertical line
            tmpArr(0) = Point(0) - Point(1) + 1
            tmpArr(1) = Point(1)
        End If
    End If
    pointArr(1) = tmpArr
    result2D(0, 0) = pointArr(0)(0): result2D(0, 1) = pointArr(0)(1)
    result2D(1, 0) = pointArr(1)(0): result2D(1, 1) = pointArr(1)(1)
    Erase pointArr
    PerpendicularLine_ = result2D
End Function

Private Function PMT_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = Pmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 4
            tmpEval = Pmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = Pmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CLng((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    PMT_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    PMT_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Performs a regression polynomial fitting in which the relationship between the
&apos;&apos;&apos;     independent variable x and the dependent variable y is modelled as an nth
&apos;&apos;&apos;     degree polynomial in x in the form y = a + b*x + c*x^2 +...+ m*x^n. The method use
&apos;&apos;&apos;     multiple linear regresion as core basis.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;samplesArr&quot;&gt;Data sample containing the observations pairs (x,y).&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;pDegree&quot;&gt;Polynomial degree.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;stringOutput&quot;&gt;When &apos;False&apos; the coeficents array is returned.&lt;/param&gt;
Private Function PolyFit_(ByRef samplesArr() As Double, pDegree As Long, _
                            Optional stringOutput As Boolean = True) As Variant
    Dim observCount As Long
    Dim i As Long
    Dim mLB As Long
    Dim mUB As Long
    Dim modelArray() As Double
    Dim responseArray() As Double
    Dim pDegreesArr() As Long
    Dim SolverResult() As Double
    Dim k As Long
    
    mLB = LBound(samplesArr)
    mUB = UBound(samplesArr)
    observCount = mUB - mLB + 1
    &apos;Create arrays
    ReDim modelArray(0 To observCount - 1, 0 To 0)
    ReDim responseArray(0 To observCount - 1, 0 To 0)
    For i = 0 To observCount - 1
        modelArray(i, 0) = samplesArr(i, 0)
        responseArray(i, 0) = samplesArr(i, 1)
    Next i
    &apos;Create degrees vector
    ReDim pDegreesArr(0 To pDegree - 1)
    For i = 0 To pDegree - 1
        pDegreesArr(i) = i + 1
    Next i
    &apos;Add polynomial substitutions predictors
    AddExponentialPredictors modelArray, pDegreesArr
    &apos;Add columns of ones
    AddIntersectionCol modelArray
    &apos;Solve linear eq. system
    k = UBound(modelArray, 2) - LBound(modelArray)
    SolverResult = MLR_(modelArray, responseArray)
    If stringOutput Then
        &apos;Format
        PolyFit_ = PolyString(SolverResult, pDegree)
    Else
        PolyFit_ = SolverResult
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Creates a polynomial string representation from solver coefficients
&apos;&apos;&apos;     NOTE: PolyFit helper
&apos;&apos;&apos; &lt;/summary&gt;
Private Function PolyString(ByRef SolverResult() As Double, ByRef pDegree As Long) As String
    Dim i As Long
    Dim tmpResult As String
    
    For i = 0 To pDegree
        If i = 0 Then
            tmpResult = CStr(Round(SolverResult(i, 0), 4))
        Else
            If CDbl(SolverResult(i, 0)) &gt; 0 Then
                tmpResult = tmpResult &amp; d_Space &amp; op_plus _
                            &amp; d_Space &amp; Round(SolverResult(i, 0), 4)
            Else
                tmpResult = tmpResult &amp; d_Space &amp; Round(SolverResult(i, 0), 4)
            End If
            If i &gt; 1 Then
                tmpResult = tmpResult &amp; &quot;*x^&quot; &amp; i
            Else
                tmpResult = tmpResult &amp; &quot;*x&quot;
            End If
        End If
    Next i
    PolyString = tmpResult
End Function

Private Function Power(ByRef expression As String, ByRef fName As String) As String
    Dim tmpData() As String
    Dim tmpEval As Double
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    If UB - LB = 1 Then
        tmpEval = CDbl(tmpData(LB)) ^ _
                        CDbl(tmpData(UB))
    Else
        tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End If
    Power = CStr(tmpEval): Erase tmpData
    Exit Function
err_Handler:
    Power = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function PPMT_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 4
            tmpEval = PPmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = PPmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 6
            tmpEval = PPmt(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 4), True)), _
                        CLng((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    PPMT_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    PPMT_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Precision_(p5 As Double) As Double
    Precision_ = Abs(Fix(Log10(Abs(p5)) - 7))
End Function

Private Function PV_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = PV(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 4
            tmpEval = PV(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = PV(CDbl(FormatLiteralString(tmpData(LB), True)), _
                        CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                        CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CLng((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    PV_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    PV_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary QR Decomposition&gt;
&apos;&apos;&apos; For an m-by-n matrix A with m &gt;= n, the QR decomposition is an m-by-n
&apos;&apos;&apos; orthogonal matrix Q and an n-by-n upper triangular matrix R so that
&apos;&apos;&apos; A = Q*R.
&apos;&apos;&apos;
&apos;&apos;&apos; The QR decompostion always exists, even if the matrix does not have
&apos;&apos;&apos; full rank, so the constructor will never fail.  The primary use of the
&apos;&apos;&apos; QR decomposition is in the least squares solution of nonsquare systems
&apos;&apos;&apos; of simultaneous linear equations.  This will fail if isFullRank()
&apos;&apos;&apos; returns false.
&apos;&apos;&apos;&lt;NOTE&gt;
&apos;&apos;&apos; The original source code was modified to allow the computation of R
&apos;&apos;&apos; by enforce signs of the diagonal elements to be positive.
&apos;&apos;&apos; https://github.com/fiji/Jama/blob/master/src/main/java/Jama/QRDecomposition.java
&apos;&apos;&apos; https://math.nist.gov/javanumerics/jama/
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;A&quot;&gt;Matrix to decompose.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;PositiveDiag&quot;&gt;When &quot;True&quot; enforce signs of the diagonal elements to be positive.&lt;/param&gt;
Private Function QRdec(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1, 2
            If argsCount = 1 Then
                QR_ ArrayFromString(tmpData(LB))
            Else
                QR_ ArrayFromString(tmpData(LB)), CBool(FormatLiteralString(tmpData(UB), True))
            End If
            tmpEval = d_lCurly _
                        &amp; ArrayToString(QR_getQ) &amp; P_SEPARATORCHAR &amp; _
                        ArrayToString(QR_getR) &amp; _
                    d_rCurly
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    QRdec = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    QRdec = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;# QR DECOMPOSITION
&apos;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Private Sub QR_(ByRef A As Variant, Optional PositiveDiag As Boolean = False)
    Dim i As Long, j As Long
    Dim k As Long
    Dim s As Double
    Dim nrm As Double
    
    m = UBound(A) - LBound(A) + 1
    n = UBound(A, 2) - LBound(A, 2) + 1
    QR() = ToDblArray(A)
    ReDim rDiag(0 To n - 1)
    ReDim signFlip(0 To n - 1)
    For k = 0 To n - 1
        &apos;// Compute 2-norm of k-th column without under/overflow.
        nrm = 0
        For i = k To m - 1
            nrm = QR_hypot(nrm, QR(i, k))
        Next i
        If nrm &lt;&gt; 0 Then
            &apos;// Form k-th Householder vector.
            If (QR(k, k) &lt; 0) Then
                nrm = -nrm
            End If
            For i = k To m - 1
                QR(i, k) = QR(i, k) / nrm
            Next i
            QR(k, k) = QR(k, k) + 1#
            &apos;// Apply transformation to remaining columns.
            For j = k + 1 To n - 1
                s = 0#
                For i = k To m - 1
                    s = s + QR(i, k) * QR(i, j)
                Next i
                s = -s / QR(k, k)
                For i = k To m - 1
                    QR(i, j) = QR(i, j) + s * QR(i, k)
                Next i
            Next j
        End If
        rDiag(k) = -nrm
        signFlip(k) = (rDiag(k) &lt; 0) And PositiveDiag
    Next k
End Sub

&apos;   /** Return the Householder vectors
&apos;   @return     Lower trapezoidal matrix whose columns define the reflections
&apos;   */
Private Function QR_getH() As Variant
    Dim h() As Double
    Dim i As Long, j As Long
    
    ReDim h(0 To m - 1, 0 To n - 1)
    For i = 0 To m - 1
        For j = 0 To n - 1
            If i &gt;= j Then
                h(i, j) = QR(i, j)
            Else
                h(i, j) = 0#
            End If
        Next j
    Next i
    QR_getH = h
End Function

&apos;   /** Generate and return the (economy-sized) orthogonal factor
&apos;   @return     Q
&apos;   */
Private Function QR_getQ() As Variant
    Dim q() As Double
    Dim i As Long, j As Long
    Dim k As Long
    Dim s As Double
    
    ReDim q(0 To m - 1, 0 To n - 1)
    For k = m - 1 To 0 Step -1
        q(k, k) = 1#
        For j = k To n - 1
            If (QR(k, k) &lt;&gt; 0) Then
                s = 0#
                For i = k To m - 1
                    s = s + QR(i, k) * q(i, j)
                Next i
                s = -s / QR(k, k)
                For i = k To m - 1
                    q(i, j) = q(i, j) + s * QR(i, k)
                Next i
            End If
        Next j
    Next k
    For i = 0 To m - 1
        For j = 0 To n - 1
            If Abs(q(i, j)) &lt;&gt; 0 Then
                If signFlip(j) Then
                    q(i, j) = -1 * q(i, j)
                End If
            Else
                 q(i, j) = 0
            End If
        Next j
    Next i
    QR_getQ = q
End Function

&apos;   /** Return the upper triangular factor
&apos;   @return     R
&apos;   */
Private Function QR_getR() As Variant
    Dim r() As Double
    Dim i As Long, j As Long
    
    ReDim r(0 To n - 1, 0 To n - 1)
    For i = 0 To n - 1
        For j = 0 To n - 1
            If i &lt; j Then
                r(i, j) = QR(i, j)
            ElseIf i = j Then
                r(i, j) = rDiag(i)
            Else
                r(i, j) = 0#
            End If
            If signFlip(i) And (r(i, j) &lt;&gt; 0) Then r(i, j) = -1 * r(i, j)
        Next j
    Next i
    QR_getR = r
End Function

   
Private Function QR_hypot(ParamArray args() As Variant) As Double
    Dim i As Long
    Dim sqrSum As Double
    
    For i = LBound(args) To UBound(args)
        sqrSum = sqrSum + (args(i) * args(i))
    Next i
    QR_hypot = Sqr(sqrSum)
End Function

&apos;   /** Is the matrix full rank?
&apos;   @return     true if R, and hence A, has full rank.
&apos;   */
Private Function QR_isFullRank() As Boolean
    Dim j As Long
    Dim tmpResult As Boolean
    
    Do While j &lt; n And Not tmpResult
        tmpResult = (rDiag(j) = 0)
        j = j + 1
    Loop
    QR_isFullRank = Not tmpResult
End Function

Private Function QR_LSQsolve(ByRef A() As Double, B() As Double) As Variant
    QR_ A
    QR_LSQsolve = QR_solve(B)
End Function

Private Function QR_solve(ByRef B() As Double) As Variant
    If UBound(B) - LBound(B) + 1 &lt;&gt; m Then
        Exit Function &apos;&quot;Matrix row dimensions must agree.&quot;
    End If
    If Not QR_isFullRank Then
        Exit Function &apos;&quot;Matrix is rank deficient.&quot;
    End If
    Dim x() As Double, nx As Long
    Dim i As Long, j As Long, k As Long
    Dim s As Double, tmpResult() As Double
    
&apos;    // Copy right hand side
    x() = get2DimArrayCopy(B)
    nx = UBound(x, 2) - LBound(x, 2) + 1
&apos;    // Compute Y = transpose(Q)*B
    For k = 0 To n - 1
        For j = 0 To nx - 1
            s = 0
            For i = k To m - 1
                s = s + QR(i, k) * x(i, j)
            Next i
            s = -s / QR(k, k)
            For i = k To m - 1
                x(i, j) = x(i, j) + s * QR(i, k)
            Next i
        Next j
    Next k
&apos;    // Solve R*X = Y
    For k = n - 1 To 0 Step -1
        For j = 0 To nx - 1
            x(k, j) = x(k, j) / rDiag(k)
        Next j
        For i = 0 To k - 1
            For j = 0 To nx - 1
                x(i, j) = x(i, j) - x(k, j) * QR(i, k)
            Next j
        Next i
    Next k
    ReDim tmpResult(0 To n - 1, 0 To nx - 1)
    For i = 0 To n - 1
        For j = 0 To nx - 1
            tmpResult(i, j) = x(i, j)
        Next j
    Next i
    QR_solve = tmpResult
End Function

Private Function RATE_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = Rate(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 4
            tmpEval = Rate(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case 5
            tmpEval = Rate(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                        CLng((FormatLiteralString(tmpData(UB), True))))
        Case 6
            tmpEval = Rate(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 3), True)), _
                         CLng(FormatLiteralString(tmpData(LB + 4), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    RATE_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    RATE_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ReconstructLiteralStrings(InputExpr As String, StoredExp As String) As String
    Dim curPosInput As Long
    Dim lastPosInput As Long
    Dim curPosStored As Long
    Dim lastPosStored As Long
    Dim closingMarkInput As Long
    Dim closingMarkStored As Long
    Dim tmpResult As String
    
    On Error GoTo Reconstruct_errHandler
    lastPosInput = 1
    lastPosStored = -1
    curPosInput = strVBA.InStrB(lastPosInput, InputExpr, d_Apostrophe)
    tmpResult = StoredExp
    Do While curPosInput        &apos;Found literal string
        lastPosStored = lastPosStored + 2
        curPosStored = strVBA.InStrB(lastPosStored, tmpResult, d_Apostrophe)
        closingMarkInput = strVBA.InStrB(curPosInput + 2, InputExpr, d_Apostrophe)
        closingMarkStored = strVBA.InStrB(curPosStored + 2, tmpResult, d_Apostrophe)
        tmpResult = strVBA.MidB(tmpResult, 1, curPosStored - 1) _
                    &amp; strVBA.MidB(InputExpr, curPosInput, closingMarkInput - curPosInput + 2) _
                    &amp; strVBA.MidB(tmpResult, closingMarkStored + 2)
        lastPosStored = strVBA.InStrB(closingMarkStored, tmpResult, d_Apostrophe)
        lastPosInput = closingMarkInput + 2
        curPosInput = strVBA.InStrB(lastPosInput, InputExpr, d_Apostrophe)
    Loop
    ReconstructLiteralStrings = tmpResult
    Exit Function
Reconstruct_errHandler:
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Creates a polynomial string representation from regression coefficients
&apos;&apos;&apos;     NOTE: MLR helper
&apos;&apos;&apos; &lt;/summary&gt;
Private Function RegressionString(ByRef SolverResult() As Double, Optional ByRef PredNames As Variant = -1, _
                                    Optional ByRef PredInteractions As Variant = -1) As String
    Dim i As Long
    Dim tmpResult As String
    Dim tmpNames() As String
    Dim strPNames As String
    Dim m As Long
    Dim n As Long
    Dim o As Long
    Dim s As Long
    
    m = -1
    n = -1
    If Not IsNumeric(PredNames) Then
        m = UBound(PredNames)
        strPNames = Join$(PredNames, P_SEPARATORCHAR)
    End If
    If Not IsNumeric(PredInteractions) Then n = UBound(PredInteractions)
    o = UBound(SolverResult)
    ReDim tmpNames(0 To o - 1)
    For i = 0 To o - 1
        If m &gt;= 0 And n &gt;= 0 Then
            If s &lt;= m Then
                tmpNames(i) = PredNames(i)
                s = s + 1
            Else
                tmpNames(i) = FormatNamedPredictors(strPNames, CStr(PredInteractions(i - s)), False)
            End If
        Else
            If n + 1 - (o - i) &gt;= 0 Then &apos;Save predictors relations without names
                tmpNames(i) = PredInteractions(n + 1 - (o - i))
            Else
                tmpNames(i) = &quot;X&quot; &amp; CStr(i + 1)
            End If
        End If
    Next i
    For i = 0 To o
        If i = 0 Then
            tmpResult = CStr(Round(SolverResult(i, 0), 4))
        Else
            If CDbl(SolverResult(i, 0)) &gt; 0 Then
                tmpResult = tmpResult &amp; d_Space &amp; op_plus _
                            &amp; d_Space &amp; Round(SolverResult(i, 0), 4)
            Else
                tmpResult = tmpResult &amp; d_Space &amp; Round(SolverResult(i, 0), 4)
            End If
            tmpResult = tmpResult &amp; op_mult &amp; tmpNames(i - 1)
        End If
    Next i
    RegressionString = tmpResult
End Function

Private Function RemoveDupNegation(ByRef expression As String) As String
    Dim tmpResult As String
    
    tmpResult = expression
    Do While tmpResult Like &quot;*~~*&quot;
        tmpResult = Replace(tmpResult, &quot;~~&quot;, vbNullString)
    Loop
    RemoveDupNegation = tmpResult
End Function

Private Function REM_(n As Double, d As Double)
    Dim q As Double
    
    q = Fix(n / d)
    REM_ = n - d * q
End Function

Private Function ReplaceImpliedMult(expression As String) As String
    Dim tmpPos As Long
    Dim tmpStr As String
    Dim LookupPos As Long
    Dim tmpVar As String
    Dim tmpVarInitPos As Long
    Dim prevChar As String
    Dim reservedChar As Boolean
    Dim tmpChar As String
    Dim literalGap() As Long
    
    LookupPos = 1
    tmpStr = expression
    tmpPos = strVBA.InStrB(LookupPos, tmpStr, d_lParenthesis)
    Do While InLiteralGap(tmpStr, tmpPos) And tmpPos
        tmpPos = strVBA.InStrB(tmpPos + 2, tmpStr, d_lParenthesis)
    Loop
    Do While tmpPos
        If tmpPos &gt; 2 Then
            If strVBA.InStrB(1, op_AllItems, strVBA.MidB(tmpStr, tmpPos - 2, 2)) = 0 Then
                tmpVarInitPos = tmpPos
                Do While tmpVarInitPos &gt; 1
                    tmpChar = strVBA.MidB(tmpStr, tmpVarInitPos - 2, 2)
                    If (strVBA.InStrB(1, op_AllItems, tmpChar) &lt;&gt; 0) Then Exit Do
                    If tmpChar = d_lParenthesis Then Exit Do
                    If tmpChar = d_rParenthesis Then Exit Do
                    If tmpChar = P_SEPARATORCHAR Then Exit Do
                    tmpVarInitPos = tmpVarInitPos - 2
                Loop
                tmpVar = strVBA.MidB(tmpStr, tmpVarInitPos, tmpPos - tmpVarInitPos)
                prevChar = strVBA.MidB(tmpStr, tmpPos - 2, 2)
                reservedChar = (prevChar = d_lParenthesis Or strVBA.InStrB(1, op_AllItems, prevChar))
                If Not reservedChar Then
                    If GetFunctionName(LCase(tmpVar)) = vbNullString Then  &apos;Implied multiplication found
                        tmpStr = strVBA.MidB(tmpStr, 1, tmpPos - 1) &amp; op_mult &amp; strVBA.MidB(tmpStr, tmpPos)
                    End If
                End If
            End If
            LookupPos = tmpPos + 4
            tmpPos = strVBA.InStrB(LookupPos, tmpStr, d_lParenthesis)
            Do While InLiteralGap(tmpStr, tmpPos) And tmpPos
                tmpPos = strVBA.InStrB(tmpPos + 2, tmpStr, d_lParenthesis)
            Loop
        Else
            LookupPos = tmpPos + 2
            tmpPos = strVBA.InStrB(LookupPos, tmpStr, d_lParenthesis)
            Do While InLiteralGap(tmpStr, tmpPos) And tmpPos
                tmpPos = strVBA.InStrB(tmpPos + 2, tmpStr, d_lParenthesis)
            Loop
        End If
    Loop
    ReplaceImpliedMult = tmpStr
End Function

Private Function Replace_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = ToLiteralString( _
                                        Replace( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                FormatLiteralString(tmpData(LB + 1), True), _
                                                FormatLiteralString(tmpData(UB), True) _
                                                ) _
                                    )
        Case 4
            tmpEval = ToLiteralString( _
                                        Replace( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                FormatLiteralString(tmpData(LB + 1), True), _
                                                FormatLiteralString(tmpData(LB + 2), True), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case 5
            tmpEval = ToLiteralString( _
                                        Replace( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                FormatLiteralString(tmpData(LB + 1), True), _
                                                FormatLiteralString(tmpData(LB + 2), True), _
                                                CLng(FormatLiteralString(tmpData(LB + 3), True)), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case 6
            tmpEval = ToLiteralString( _
                                        Replace( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                FormatLiteralString(tmpData(LB + 1), True), _
                                                FormatLiteralString(tmpData(LB + 2), True), _
                                                CLng(FormatLiteralString(tmpData(LB + 3), True)), _
                                                CLng(FormatLiteralString(tmpData(LB + 4), True)), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Replace_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Replace_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function ReservedToken(ByRef varName As String) As Boolean
    ReservedToken = True
    If Not IsBoolean(LCase$(varName)) Then &apos;Exclude logical values
        If IsLikeSciNot(varName) Then &apos; Like &quot;E#*&quot;
            If Not IsDigit(strVBA.MidB(varName, strVBA.LenB2(varName) - 1)) Then &apos;Exclude Sci notation exp
                If Not AscW(varName) = 69 Then  &apos;Exclude Sci notation token E
                    ReservedToken = False
                End If
            End If
        Else
            If Not AscW(varName) = 69 Then  &apos;Exclude Sci notation token E
                ReservedToken = False
            End If
        End If
    End If
End Function

Private Function Right_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ToLiteralString(right(FormatLiteralString(tmpData(LB), True), 1))
        Case 2
            tmpEval = ToLiteralString( _
                                        right( _
                                                FormatLiteralString(tmpData(LB), True), _
                                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                                ) _
                                    )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Right_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Right_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function RoundToPrecision(t As Double, r As Double) As Double
    Dim tmpResult As Double

    tmpResult = t * 10 ^ r
    RoundToPrecision = Round(tmpResult) / (10 ^ r)
End Function

Private Function ROUND_(aNumber As Double, Optional aDigits As Double = 0) As Double
    ROUND_ = Round(aNumber, aDigits)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Turns a row vector into a column vector and viceversa.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;tVector&quot;&gt;The vertor to transform.&lt;/param&gt;
Private Function RowColVectTransform(ByRef tVector As Variant) As Variant
    Dim vLB As Long
    Dim vLB2 As Long
    Dim vUB As Long
    Dim fromRowToCol As Boolean
    Dim i As Long, j As Long
    Dim tmpResult() As Double
    
    If Not IsArray(tVector) Then Exit Function
    vLB = LBound(tVector)
    vUB = UBound(tVector)
    fromRowToCol = Not Is2Darray(tVector)
    If fromRowToCol Then    &apos;Transform row vector to column vector
        ReDim tmpResult(0 To vUB - vLB, 0 To 0)
        For i = vLB To vUB
            tmpResult(j, 0) = CDbl(tVector(i))
            j = j + 1
        Next i
    Else    &apos;Transform column vector to row vector
        vLB2 = LBound(tVector, 2)
        ReDim tmpResult(0 To vUB - vLB)
        For i = vLB To vUB
            tmpResult(j) = CDbl(tVector(i, vLB2))
            j = j + 1
        Next i
    End If
    RowColVectTransform = tmpResult
End Function

Private Function SegmentBisector_(PointA() As Double, PointB() As Double) As Variant
    Dim Ax As Double, Ay As Double
    Dim Bx As Double, By As Double
    Dim mPoint(0 To 1) As Double
    Dim sLine(0 To 1, 0 To 1) As Double
    
    Ax = PointA(0): Ay = PointA(1)
    Bx = PointB(0): By = PointB(1)
    sLine(0, 0) = Ax: sLine(0, 1) = Ay
    sLine(1, 0) = Bx: sLine(1, 1) = By
    mPoint(0) = (Ax + Bx) / 2
    mPoint(1) = (Ay + By) / 2
    SegmentBisector_ = PerpendicularLine_(sLine, mPoint)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Replaces square brackets with parentheses
&apos;&apos;&apos; &lt;/summary&gt;
Private Function SBracketsNotationToNominal(ByRef aExpression As String) As String
    SBracketsNotationToNominal = Replace(Replace( _
                                        aExpression, d_lSquareB, d_lParenthesis), _
                                        d_rSquareB, d_rParenthesis)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an implicit string containing the order in which arithmetic operations
&apos;&apos;&apos;     should be evaluated. The string can point to any part of the source expression
&apos;&apos;&apos;     using syntax such as {1}*{3}+{0} to represent it.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Expression&quot;&gt;The target expression of the lambda operation.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;SubExpressionsData&quot;&gt;A set of expressions to derive the lambda string.&lt;/param&gt;
Private Function SerializeSubTree(ByRef expression As String, ByRef SubExpressionsData() As String) As String
    Dim glUb As Long
    Dim glCounter As Long
    Dim tmpResult As String
    Dim tmpKey As String
    
    tmpResult = expression
    glUb = UBound(SubExpressionsData)
    For glCounter = LBound(SubExpressionsData) To glUb
        If strVBA.InStrB(1, tmpResult, SubExpressionsData(glCounter)) Then
            tmpKey = GetSubstStr(glCounter)
            tmpResult = Replace(tmpResult, d_lParenthesis &amp; SubExpressionsData(glCounter) &amp; d_rParenthesis, tmpKey)
        End If
    Next
    SerializeSubTree = tmpResult
End Function

Private Sub ShrinkBuffer(ByRef aBuffer As ClusterTree)
    If aBuffer.aindex &gt; -1 Then
    	Dim tmpBuffer() As token
    	
        aBuffer.Capacity = aBuffer.aindex
        tmpBuffer = aBuffer.Storage
        ReDim Preserve tmpBuffer(0 To aBuffer.Capacity)
        aBuffer.Storage = tmpBuffer
    End If
End Sub

Private Function Sign(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    Sign = CStr(Sgn(CDbl(expression)))
    Exit Function
err_Handler:
    Sign = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Sub SignSubstitution(ByRef expression As String, FindStr As String, Replacement As String)
    If strVBA.InStrB(1, expression, FindStr) Then
        expression = Replace(expression, FindStr, Replacement)
    End If
End Sub

Private Function Sine(ByRef expression As String, ByRef fName As String) As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = CDbl(expression)
    If P_DEGREES Then
        tmpEval = tmpEval * pi / 180
    End If
    Sine = CStr(Sin(tmpEval))
    Exit Function
err_Handler:
    Sine = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function SLN_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = SLN(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    SLN_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    SLN_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Solves the linear system AX = B using Over Relaxation (SOR)
&apos;&apos;&apos;     iteration. The function requires that the &lt;expression&gt; argument be composed
&apos;&apos;&apos;     of the following:
&apos;&apos;&apos;                     1-) An array in text form containing the coefficients of all equations.
&apos;&apos;&apos;                     2-) An one dimentional array containing the name of each variable
&apos;&apos;&apos;                         (the first name will be applied to the first column of coefficients,
&apos;&apos;&apos;                         the second name to the second column and so on).
&apos;&apos;&apos;                     3-) An one dimentional array containing the right-hand side of each equation,
&apos;&apos;&apos;                         (the first name will be applied to the first column of coefficients,
&apos;&apos;&apos;                         the second name to the second column and so on).
&apos;&apos;&apos;                     4-) A True or False parameter to decide when to include the variable names
&apos;&apos;&apos;                         in the result set.
&apos;&apos;&apos;     The program will iterate until the solution is approximated to 9
&apos;&apos;&apos; significant digits or until 500 iterations are completed, whichever comes first.
&apos;&apos;&apos; &lt;/summary&gt;
Private Function solve(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    Dim tolerance As Double
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3, 4
            Dim cArray() As Double
            Dim eqCount As Long
            Dim iCounter As Long
            Dim includeNames As Boolean
            Dim mLB As Long
            Dim mUB As Long
            Dim nArray() As String
            Dim rArray() As Double
            Dim tmpElement As String
            Dim significantDigits As Long
            Dim xArray() As Double
            
            tolerance = 0.0000000001
            significantDigits = Len(CStr(1 / tolerance)) - 1
            cArray() = ToDblArray(ArrayFromString(tmpData(LB)))
            rArray() = ToDblArray(ArrayFromString(tmpData(LB + 2)))
            mLB = LBound(cArray)
            mUB = UBound(cArray)
            
            ReDim xArray(mLB To mUB)
            eqCount = mUB - mLB + 1
            SORiteration eqCount, cArray, rArray, xArray, 500, tolerance, 1
            If argsCount = 4 Then
                nArray() = ArrayFromString(tmpData(LB + 1))
                includeNames = CBool(tmpData(UB))
            End If
            For iCounter = mLB To mUB
                If iCounter &gt; mLB Then
                    tmpEval = tmpEval &amp; P_SEPARATORCHAR &amp; d_Space
                End If
                If includeNames Then
                    tmpElement = FormatLiteralString(nArray(iCounter)) _
                                &amp; d_Space &amp; op_equal &amp; d_Space _
                                &amp; Round(xArray(iCounter), significantDigits)
                Else
                    tmpElement = Round(xArray(iCounter), significantDigits)
                End If
                tmpEval = tmpEval &amp; tmpElement
            Next iCounter
            If Not includeNames Then
                tmpEval = d_lCurly &amp; d_lCurly &amp; tmpEval &amp; d_rCurly &amp; d_rCurly
            End If
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    solve = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    solve = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Sub SORiteration(n As Long, ByRef A() As Double, ByRef B() As Double, _
                         ByRef x() As Double, iter As Long, tol As Double, omega As Double)
&apos;&apos;&apos; Hoffman, J. D. (2001). Numerical methods for engineers and scientists (2nd ed., rev.expanded). Marcel Dekker.
    Dim IT As Long
    Dim i As Long, j As Long
    Dim dxmax As Double
    Dim residual As Double
    Dim colLB As Long, rowLB As Long
    
    colLB = LBound(A, 2)
    rowLB = LBound(A)
    For IT = 1 To iter
        dxmax = 0
        For i = 1 To n
            residual = B(i + rowLB - 1)
            For j = 1 To n
                residual = residual - A(i + rowLB - 1, j + colLB - 1) * x(j + rowLB - 1)
            Next j
            If Abs(residual) &gt; dxmax Then dxmax = Abs(residual)
            x(i + rowLB - 1) = x(i + rowLB - 1) + omega * residual / A(i + rowLB - 1, i + colLB - 1)
        Next i
        If dxmax &lt; tol Then Exit For
    Next IT
End Sub

Private Function SplitArgs(ByRef args As String) As Variant
    Dim tmpPos As Long
    Dim curChar As String
    Dim SargStart As Long
    Dim SargEnd As Long
    Dim tmpResult As String
    Dim LenArgsStr As Long
    Dim VectorOpenFlag As Boolean
    Dim OpenCBrackets As Long
    Dim i As Long
    
    tmpPos = 1
    LenArgsStr = strVBA.LenB2(args)
    Do
        VectorOpenFlag = (strVBA.InStrB(tmpPos, args, d_lCurly) = tmpPos)
        If VectorOpenFlag Then &apos;Currrent argument is an array
            i = tmpPos
            OpenCBrackets = 1
            Do While VectorOpenFlag And i &lt;= LenArgsStr
                i = i + 2
                curChar = strVBA.MidB(args, i, 2)
                If curChar = d_lCurly Then
                    OpenCBrackets = OpenCBrackets + 1
                Else
                    If curChar = d_rCurly Then
                        OpenCBrackets = OpenCBrackets - 1
                    End If
                End If
                VectorOpenFlag = Not (curChar = d_rCurly) Or OpenCBrackets
            Loop
            SargStart = tmpPos
            SargEnd = i + 2
            tmpPos = i + 4
        Else
            SargStart = tmpPos
            curChar = strVBA.MidB(args, SargStart, 2)
            If curChar = d_Apostrophe Then &apos;Literal string into arguments
                SargEnd = strVBA.InStrB(tmpPos + 1, args, d_Apostrophe) + 2
            Else
                SargEnd = strVBA.InStrB(tmpPos, args, P_SEPARATORCHAR)
            End If
            If SargEnd = 0 Then
                SargEnd = LenArgsStr + 1
            End If
            tmpPos = SargEnd + 2
        End If
        If tmpResult &lt;&gt; vbNullString Then
            tmpResult = tmpResult &amp; &quot;?&quot; &amp; strVBA.MidB(args, SargStart, SargEnd - SargStart)
        Else
            tmpResult = strVBA.MidB(args, SargStart, SargEnd - SargStart)
        End If
    Loop While tmpPos &lt; LenArgsStr
    SplitArgs = Split(tmpResult, &quot;?&quot;)
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns an element from the given list. The last argument
&apos;&apos;&apos;     is used as the index
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;aList&quot;&gt;The list to split.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;index&quot;&gt;The list to split.&lt;/param&gt;
Private Function GetFromList(ByRef expression As String, ByRef fName As String) As String
    Dim tmpData() As String
    Dim tmpEval As String
    Dim argsCount As Long
    Dim LB As Long, UB As Long
    Dim idx As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    idx = CLng(tmpData(UB))
    If idx &lt; argsCount - 1 Then
        tmpEval = tmpData(idx)
        GetFromList = tmpEval: Erase tmpData
    Else
        GetFromList = e_ValueError
    End If
    Exit Function
err_Handler:
    GetFromList = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Splits an array function argument and returns an array with the bounds
&apos;&apos;&apos;     of the passed string array. In the returned array, the lower index
&apos;&apos;&apos;     indicates the argument max row index and the upper index indicates the
&apos;&apos;&apos;     argument max column index.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;Argument&quot;&gt;The array function argumnet (&quot;*{{*}}*&quot;).&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;outArr&quot;&gt;Array to be scanned and overwritten.&lt;/param&gt;
Private Function SplitArrBranch(ByRef Argument As String, ByRef outArr() As String) As Variant
    Dim tmpArr() As String
    Dim tmpArgs() As String
    Dim tmpResult() As Long
    Dim tmpOutArr() As String
    Dim i As Long
    Dim j As Long
    Dim k As Long
    Dim m As Long
    Dim n As Long
    Dim UB As Long
    Dim usedIdx As Long
    
    tmpArgs() = SplitArgs(Argument)
    UB = UBound(tmpArgs)
    ReDim tmpResult(0 To 2 * (UB + 1))
    ReDim outArr(0 To 0)
    For i = 0 To UB
        If (tmpArgs(i) Like &quot;{{*}}&quot;) Then &apos; Array
            tmpArr() = ArrayFromString(tmpArgs(i))
            If IsArrayAllocated(tmpArr) Then &apos;Transform success
                If Is2Darray(tmpArr) Then
                    tmpOutArr = ArraySTR1DFrom2DArr(tmpArr)
                    tmpResult(j) = UBound(tmpArr)   &apos;Rows in the array
                    tmpResult(j + 1) = UBound(tmpArr, 2) &apos;Columns in each row
                Else
                    tmpOutArr = tmpArr
                    tmpResult(j) = UBound(tmpArr)
                    tmpResult(j + 1) = 0
                End If
                j = j + 2 &apos;Worked array elements
            Else
                GoTo Err_return
            End If
        Else
            If (tmpArgs(i) Like &quot;{*}&quot;) Then &apos; Vector
                tmpArr() = Split(strVBA.MidB(tmpArgs(i), 3, strVBA.LenB2(tmpArgs(i)) - 4), P_SEPARATORCHAR)
                If IsArrayAllocated(tmpArr) Then
                    tmpOutArr = tmpArr
                    tmpResult(j) = UBound(tmpArr)
                    tmpResult(j + 1) = -3
                    j = j + 2
                Else
                    GoTo Err_return
                End If
            Else &apos; Single data
                ReDim tmpArr(0 To 0)
                tmpArr(0) = tmpArgs(i)
                tmpOutArr = tmpArr
                tmpResult(j) = -2 &apos;Single data type
                j = j + 1
            End If
        End If
        m = UBound(outArr)
        n = UBound(tmpOutArr) + 1
        ReDim Preserve outArr(0 To m + n)
        For k = 0 To n - 1
            outArr(usedIdx) = tmpOutArr(k)
            usedIdx = usedIdx + 1
        Next k
    Next i
    ReDim Preserve tmpResult(0 To j - 1)
    ReDim Preserve outArr(0 To usedIdx - 1)
nReturn:
    SplitArrBranch = tmpResult
    Exit Function
Err_return:
    ReDim tmpResult(0 To 1)
    tmpResult(0) = -1   &apos;Return error values
    tmpResult(1) = -1
    Resume nReturn
End Function

Private Sub SplitToken(ByRef expression As String, ByRef oArray() As String, ByRef OPtoken As OperatorToken)
    Dim opSymbol As String
    Dim tmpPos As Long
    Dim Position As Long
    ReDim oArray(0 To 1)
    
    opSymbol = GetOpSymbol(OPtoken)
    If OPtoken = otSum Or OPtoken = otDiff Then
        tmpPos = strVBA.InStrB(1, expression, opSymbol)
        Do While tmpPos
            Position = tmpPos
            tmpPos = strVBA.InStrB(tmpPos + 2, expression, opSymbol)
        Loop
        If tmpPos = 1 Then          &apos;unary expression
            oArray(0) = &quot;0&quot;
        Else
            oArray(0) = strVBA.MidB(expression, 1, Position - 1)
        End If
        oArray(1) = strVBA.MidB(expression, Position + 2)
    Else
        oArray() = Split(expression, opSymbol)
    End If
End Sub

Private Function SquareRoot(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    SquareRoot = CStr(Sqr(CDbl(expression)))
    Exit Function
err_Handler:
    SquareRoot = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function STATCOM(q As Double, i As Double, _
                        j As Double, B As Double) As Double
    Dim zz As Double
    Dim z As Double
    Dim k As Double
    
    zz = 1: z = zz: k = i
    Do While (k &lt;= j)
        zz = zz * q * k / (k - B)
        z = z + zz: k = k + 2
    Loop
    STATCOM = z
End Function

Private Sub StoreUDF(ByRef targetBuffer As ClusterBuffer, _
                    ByRef UDFname As String, ByRef UDFlib As String)
    Dim UDFidx As Long
    Dim tmpUDF As String
    Dim tmpUDFlib As String
    
    tmpUDF = LCase$(UDFname)
    UDFidx = GetCBItemIdx(targetBuffer, tmpUDF)
    If UDFidx = -1 Then &apos;Ensure uniqueness
        tmpUDFlib = LCase$(UDFlib)
        AppendToCBbuffer targetBuffer, tmpUDF, tmpUDFlib
    End If
End Sub

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Computes the two-tailed probability values of a t-test, given the
&apos;&apos;&apos;     t-value and the degrees of freedom. The one-tailed probabilities
&apos;&apos;&apos;     can be computed as:
&apos;&apos;&apos;                      One-tailed probability (right tail) = STUDT / 2
&apos;&apos;&apos;                      One-tailed probability (left tail) = 1 - STUDT / 2
&apos;&apos;&apos;     [(c) John C. Pezzullo](https://statpages.info/scicalc.html)
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;t&quot;&gt;t-value.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;n&quot;&gt;Degrees of freedom.&lt;/param&gt;
Private Function STUDT(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = STUDT_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    STUDT = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    STUDT = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function STUDT_(ByVal t As Double, n As Double) As Double
    Dim w As Double
    Dim th As Double
    Dim sth As Double
    Dim cth As Double
    
    t = Abs(t)
    w = t / Sqr(n)
    th = Atn(w)
    If (n = 1) Then STUDT_ = 1 - th / PID2: Exit Function
    sth = Sin(th): cth = Cos(th)
    If (REM_(n, 2) = 1) Then
        STUDT_ = 1 - (th + sth * cth * STATCOM(cth * cth, 2, n - 3, -1)) / PID2
    Else
        STUDT_ = 1 - sth * STATCOM(cth * cth, 1, n - 3, -1)
    End If
End Function

Private Function SUM(ByRef expression As String, ByRef fName As String) As String
    Dim g As Long
    Dim tmpData() As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = 0
    tmpData() = SplitArgs(expression)
    For g = LBound(tmpData) To UBound(tmpData)
        tmpEval = tmpEval + CDbl(tmpData(g))
    Next g
    SUM = CStr(tmpEval): Erase tmpData
    Exit Function
err_Handler:
    SUM = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Switch_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim idx As Long
    Dim LB As Long, UB As Long
    Dim tmpData() As String
    Dim tmpEval As Boolean
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount And 1
        Case 0
            idx = LB
            Do
                tmpEval = CBool( _
                            FormatLiteralString(tmpData(idx), True) _
                            )
                idx = idx + 2
            Loop While Not tmpEval And idx &lt;= UB - 1
        Case Else
            Switch_ = e_ValueError
            Exit Function
    End Select
    If tmpEval Then    &apos;Return the TRUE part
        Switch_ = tmpData(idx - 1)
    Else
        Switch_ = &quot;#Null!&quot;
    End If
    Exit Function
err_Handler:
    Switch_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function SYD_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 4
            tmpEval = SYD(CDbl(FormatLiteralString(tmpData(LB), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 1), True)), _
                         CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                        CDbl((FormatLiteralString(tmpData(UB), True))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    SYD_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    SYD_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Tangent(ByRef expression As String, ByRef fName As String) As String
    Dim tmpEval As Double
    
    On Error GoTo err_Handler
    tmpEval = CDbl(expression)
    If P_DEGREES Then
        tmpEval = tmpEval * pi / 180
    End If
    Tangent = CStr(Tan(tmpEval))
    Exit Function
err_Handler:
    Tangent = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Returns a list of the arrays defining the coordinates of
&apos;&apos;&apos;     the tangent segments to the given circle.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;CenterPoint&quot;&gt;The center of the circle.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;Radius&quot;&gt;The circle&apos;s radius.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;ExtPoint&quot;&gt;An external or tangent point for the circle.&lt;/param&gt;
Private Function CircleTangents(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As Variant
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = CircleTangents_(ToDblArray(ArrayFromString(tmpData(LB))), _
                                    CDbl(tmpData(LB + 1)), _
                                    ToDblArray(ArrayFromString(tmpData(UB))))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    If IsArray(tmpEval) Then
        If UBound(tmpEval) - LBound(tmpEval) &lt;&gt; 0 Then
            CircleTangents = ArrayToString(tmpEval(0)) _
                            &amp; P_SEPARATORCHAR &amp; _
                             ArrayToString(tmpEval(1))
        Else
            CircleTangents = ArrayToString(tmpEval(0))
        End If
    Else
        CircleTangents = tmpEval
    End If
    Erase tmpData
    Exit Function
err_Handler:
    CircleTangents = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function CircleTangents_(CenterPoint() As Double, Radius As Double, ExtPoint() As Double) As Variant
    Dim h As Double, k As Double
    Dim x1 As Double, y1 As Double
    Dim dx As Double, dy As Double
    Dim d2 As Double
    Dim tmpSegment1(0 To 1, 0 To 1) As Variant
    Dim tmpSegment2(0 To 1, 0 To 1) As Variant
    Dim rSegments() As Variant
    
    h = CenterPoint(0): k = CenterPoint(1)
    x1 = ExtPoint(0): y1 = ExtPoint(1)
    dx = x1 - h: dy = y1 - k
    d2 = dx * dx + dy * dy
    Select Case Round(d2 - (Radius * Radius), 8)
    Case Is &gt; 0
        Dim alpha As Double, beta As Double
        ReDim rSegments(0 To 1)
        alpha = Radius * Radius / d2
        beta = Radius * Sqr(d2 - Radius * Radius) / d2
        tmpSegment1(0, 0) = h + alpha * dx - beta * dy &apos;T1x
        tmpSegment1(0, 1) = k + alpha * dy + beta * dx &apos;T1y
        tmpSegment1(1, 0) = x1: tmpSegment1(1, 1) = y1
        rSegments(0) = tmpSegment1
        tmpSegment2(0, 0) = x1: tmpSegment2(0, 1) = y1
        tmpSegment2(1, 0) = h + alpha * dx + beta * dy &apos;T2x
        tmpSegment2(1, 1) = k + alpha * dy - beta * dx &apos;T2y
        rSegments(1) = tmpSegment2
    Case 0
        Dim perpLine As Variant
        Dim cpLine(0 To 1, 0 To 1) As Double
        ReDim rSegments(0 To 0)
        
        cpLine(0, 0) = h: cpLine(0, 1) = k
        cpLine(1, 0) = x1: cpLine(1, 1) = y1
        &apos;The tangent must be perpendicular to the CP segment
        rSegments(0) = ToDblArray(PerpendicularLine_(cpLine, ExtPoint))
    Case Else
        err.Raise vbObjectError + 515, , &quot;The given point is inside the circle.&quot;
        Exit Function
    End Select
    CircleTangents_ = rSegments
End Function

Private Function tGamma(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    tGamma = CStr(GAMMA(CDbl(expression)))
    Exit Function
err_Handler:
    tGamma = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function TimeSerial_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = ToLiteralString(TimeSerial( _
                                CLng(FormatLiteralString(tmpData(LB), True)), _
                                CLng(FormatLiteralString(tmpData(LB + 1), True)), _
                                CLng(FormatLiteralString(tmpData(UB), True)) _
                                ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    TimeSerial_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    TimeSerial_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function TimeValue_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ToLiteralString(TimeValue( _
                                FormatLiteralString(tmpData(LB), True) _
                                ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    TimeValue_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    TimeValue_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     receives the degrees of freedom and the confidence level to
&apos;&apos;&apos;     compute the one-tailed or two-tailed t-value (student t-value)
&apos;&apos;&apos;     with full accuracy. use the toption parameter to select from
&apos;&apos;&apos;     two and right one-tailed computation.
&apos;&apos;&apos;
&apos;&apos;&apos;     (c) david m. lane
&apos;&apos;&apos;     https://onlinestatbook.com/2/calculators/inverse_t_dist.html
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;confidence&quot;&gt;confidence level.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;dof&quot;&gt;shape parameter alpha.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;toption&quot;&gt;select from two and right one-tailed computation.&lt;/param&gt;
Private Function TINV(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = TINV_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(LB + 1)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    TINV = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    TINV = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function TINV_(ByRef confidence As Double, dof As Double, _
                            Optional tOption As Single = 2) As Double
    Dim x As Double
    Dim p As Double &apos;Probability
    
    If confidence &gt; 1 And confidence &lt; 100 Then &apos;Percentage entry
        confidence = confidence / 100
    End If
    p = 1 - confidence
    If tOption = 1 Then
        x = iBETAINV(2 * p, 0.5 * dof, 0.5)
    Else
        If tOption = 2 Then
            x = iBETAINV(p, 0.5 * dof, 0.5)
        End If
    End If
    x = Round(Sqr(dof * (1 - x) / x), 8)
    If confidence &gt; 0 Then
        TINV_ = x
    Else
        TINV_ = -x
    End If
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Receives the degrees of freedom and the Probability to
&apos;&apos;&apos;     compute the one-tailed t-value (Student t-value) with full
&apos;&apos;&apos;     accuracy. Parameter p can be passed as 0 &lt; p &lt; 1, or 1 &lt; p &lt; 100
&apos;&apos;&apos;
&apos;&apos;&apos;     (c) David M. Lane
&apos;&apos;&apos;     https://onlinestatbook.com/2/calculators/inverse_t_dist.html
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;Probability.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;dof&quot;&gt;Degrees of freedom.&lt;/param&gt;
Private Function TINV_1T(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = TINV_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)), _
                            1 _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    TINV_1T = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    TINV_1T = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Receives the degrees of freedom and the Probability to
&apos;&apos;&apos;     compute the two-tailed t-value (Student t-value) with full
&apos;&apos;&apos;     significant digits accuracy. Parameter p can be passed
&apos;&apos;&apos;     as 0 &lt; p &lt; 1, or 1 &lt; p &lt; 100
&apos;&apos;&apos;
&apos;&apos;&apos;     (c) David M. Lane
&apos;&apos;&apos;     https://onlinestatbook.com/2/calculators/inverse_t_dist.html
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;p&quot;&gt;Probability.&lt;/param&gt;
&apos;&apos;&apos; &lt;param name=&quot;dof&quot;&gt;Degrees of freedom.&lt;/param&gt;
Private Function TINV_2T(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 2
            tmpEval = TINV_( _
                            CDbl(tmpData(LB)), _
                            CDbl(tmpData(UB)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    TINV_2T = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    TINV_2T = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Public Function ToDblArray(ByRef aArray As Variant) As Variant
    Dim i As Long, LB As Long, UB As Long
    Dim j As Long, LB2 As Long, UB2 As Long
    Dim tmpResult() As Double
    Dim IsVector As Boolean
    
    LB = LBound(aArray)
    UB = UBound(aArray)
    IsVector = Not Is2Darray(aArray)
    If Not IsVector Then
        LB2 = LBound(aArray, 2)
        UB2 = UBound(aArray, 2)
        ReDim tmpResult(0 To UB - LB, 0 To UB2 - LB2)
        For i = LB To UB
	        For j = LB2 To UB2
	            tmpResult(i - LB, j - LB2) = CDbl(aArray(i, j))
	        Next j
    	Next i
    Else
        ReDim tmpResult(0 To UB - LB)
        For i = LB To UB
	        tmpResult(i - LB) = CDbl(aArray(i))
	    Next i
    End If
    ToDblArray = tmpResult
End Function

Private Sub TokenizeSubExpr(ByRef expression As String, ByRef SubExpressionsData() As String, ByRef outBuffer As ClusterTree)
    Dim tmpReplacement As String
    Dim ExpCopy As String
    Dim tmpArgs() As String
    Dim taIcounter As Long
    Dim OperationIndex As Long
    Dim tmpIndex As Long
    
    tmpIndex = UBound(SubExpressionsData) + 1
    OperationIndex = tmpIndex
    ExpCopy = expression
    tmpReplacement = GetSubstStr(OperationIndex)
    If Not (ExpCopy Like &quot;*{{*}}*&quot;) Then
        Select Case strVBA.InstrB(1, ExpCopy, P_SEPARATORCHAR)
            Case 0 &apos;Regular sub-expression
                GetRootedTree ExpCopy, tmpReplacement, OperationIndex, outBuffer
                outBuffer.CompCluster = False
            Case Else &apos;Composite function argument
                If Not (ExpCopy Like &quot;*{*}*&quot;) Then
                    tmpArgs() = SplitArgs(ExpCopy)
                    For taIcounter = LBound(tmpArgs) To UBound(tmpArgs)
                        GetRootedTree tmpArgs(taIcounter), tmpReplacement, OperationIndex, outBuffer
                        AddToMap outBuffer.aindex, outBuffer
                    Next taIcounter
                    outBuffer.CompCluster = True
                    outBuffer.CompArrCluster = False
                Else
                    ExpandCompositeArg outBuffer, tmpReplacement, ExpCopy, tmpArgs, taIcounter, OperationIndex
                End If
        End Select
    Else    &apos;Composite array function argument
        ExpandCompositeArg outBuffer, tmpReplacement, ExpCopy, tmpArgs, taIcounter, OperationIndex
    End If
End Sub

Private Function ToLiteralString(ByRef aString As String) As String
    If Not IsLiteralString(aString) Then
        ToLiteralString = d_Apostrophe &amp; aString &amp; d_Apostrophe
    Else
        ToLiteralString = aString
    End If
End Function

Private Function Trim_(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    Trim_ = ToLiteralString(Trim(FormatLiteralString(expression, True)))
    Exit Function
err_Handler:
    Trim_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function UCase_(ByRef expression As String, ByRef fName As String) As String
    On Error GoTo err_Handler
    UCase_ = ToLiteralString(UCase(expression))
    Exit Function
err_Handler:
    UCase_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function UnicToken(ByRef Source() As String, ByRef value As String) As Boolean
    Dim UTiCounter As Long
    Dim UTjCounter As Long
    Dim tmpResult As Boolean
    
    UTiCounter = LBound(Source)
    UTjCounter = UBound(Source)
    Do
        tmpResult = (Source(UTiCounter) = value)
        UTiCounter = UTiCounter + 1
    Loop While Not tmpResult And UTiCounter &lt; UTjCounter
    UnicToken = Not tmpResult
End Function

Private Function ValidFuntionName(ByRef expression As String, _
                                    ByRef FuntionName As String, _
                                    StartPos As Long) As Boolean
    Dim cLeft As Boolean
    Dim cRight As Boolean
    
    If StartPos &gt; 1 Then
        cLeft = Not IsLetter(strVBA.MidB(expression, StartPos - 2, 2))
    Else
        cLeft = True
    End If
    cRight = Not IsLetter(strVBA.MidB(expression, StartPos + strVBA.LenB2(FuntionName), 2))
    ValidFuntionName = cLeft And cRight
End Function

Private Function ValidTree() As Boolean
    Dim B As Long
    Dim c As Long
    Dim t As Long
    Dim tmpResult As Boolean
    
    B = LBound(EvalTree)
    c = UBound(EvalTree)
    Do                        &apos;Loop all subexpressions
        t = 0
        Do                    &apos;Loop all tokens
            tmpResult = CheckArgument(EvalTree(B).Storage(t).Arg1.DefString, _
                        EvalTree(B).Storage(t).Arg1.FactorialIn)
            If tmpResult Then
                If EvalTree(B).Storage(t).Arg2.DefString &lt;&gt; vbNullString Then
                    tmpResult = CheckArgument(EvalTree(B).Storage(t).Arg2.DefString, _
                                EvalTree(B).Storage(t).Arg2.FactorialIn)
                Else
                    tmpResult = (EvalTree(B).Storage(t).OperationToken = otNull) &apos;Check for invalid input like &quot;**&quot; &quot;//&quot; ...
                End If
            End If
            t = t + 1
        Loop While t &lt;= EvalTree(B).aindex And tmpResult
        B = B + 1
    Loop While B &lt;= c And tmpResult
    If Not tmpResult Then
        BuildErrMessage errSyntaxError, &quot;Misplaced operators have been found. Please check and try again.&quot;
    End If
    ValidTree = tmpResult
End Function

&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos;     Assigns values to the variables defined in the given expression.
&apos;&apos;&apos;     An expression such as &quot;x = 5; y = -20.5&quot; will assign 5 to the x
&apos;&apos;&apos;     variable and -20.5 to the y variable. Used by the eval method.
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;vString&quot;&gt;The list of variables to assign.&lt;/param&gt;
Private Sub VariableAssignment(ByRef vString As String)
    Dim tmpAssignment() As String
    Dim tmpValues() As String
    Dim avIcounter As Long
    Dim UB As Long
    Dim tmpVstring As String
    Dim fCurlyPos As Long
    
    tmpVstring = ReconstructLiteralStrings(vString, Join$(Split(vString, d_Space), vbNullString))
    fCurlyPos = strVBA.InStrB(1, tmpVstring, d_lCurly)
    If fCurlyPos &gt; 0 Then
        If strVBA.InStrB(fCurlyPos + 1, tmpVstring, d_lCurly) - fCurlyPos = 2 Then &apos;Full array
            tmpVstring = Replace(tmpVstring, d_rCurly &amp; d_rCurly &amp; P_SEPARATORCHAR, d_rCurly &amp; d_rCurly &amp; P_SEPARATORCHAR &amp; P_SEPARATORCHAR)
        Else &apos;Vector
            tmpVstring = Replace(tmpVstring, d_rCurly &amp; P_SEPARATORCHAR, d_rCurly &amp; P_SEPARATORCHAR &amp; P_SEPARATORCHAR)
        End If
    Else
        tmpVstring = Replace(tmpVstring, P_SEPARATORCHAR, P_SEPARATORCHAR &amp; P_SEPARATORCHAR)
    End If
    tmpAssignment() = Split(tmpVstring, P_SEPARATORCHAR &amp; P_SEPARATORCHAR)
    For avIcounter = LBound(tmpAssignment) To UBound(tmpAssignment)
        tmpValues() = Split(tmpAssignment(avIcounter), &quot;=&quot;)
        UB = UBound(tmpValues)
        If tmpValues(UB) &lt;&gt; vbNullString Then
            If IsNumeric(tmpValues(UB)) Or IsBoolean(tmpValues(UB)) Or IsLiteralString(tmpValues(UB)) Then
                P_SCOPE.LetVarValue(tmpValues(LBound(tmpValues)), tmpValues(UB))
            Else
                If strVBA.MidB(tmpValues(UB), 1, 2) = d_lCurly And _
                        strVBA.MidB(tmpValues(UB), strVBA.LenB2(tmpValues(UB)) - 1, 2) = d_rCurly Then &apos;Posible array assigment
                    P_SCOPE.LetVarValue(tmpValues(LBound(tmpValues)), tmpValues(UB))
                End If
            End If
        End If
    Next avIcounter
End Sub

Private Sub VariablesInit(ByRef expression As String)
    P_SCOPE.VariablesInit
    ParseVariables expression
    P_SCOPE.FillPredefinedVars
End Sub

Private Sub VM_DOT_(ByRef A() As Double, ByRef B As Variant, ByRef aLB As Long, ByRef aLB2 As Long, _
                    ByRef aUB As Long, ByRef aUB2 As Long, ByRef bLB2 As Long, ByRef bUB2 As Long, _
                    ByRef c() As Double, ByRef i As Long, ByRef j As Long, ByRef m As Long, _
                    ByRef n As Long, ByRef pSum As Double, ByRef bLB As Long, ByRef bUB As Long, ByRef jj As Long)
                    
    aLB = 0: aUB = 0
    aLB2 = LBound(A): aUB2 = UBound(A)
    bLB = LBound(B): bUB = UBound(B)
    bLB2 = LBound(B, 2): bUB2 = UBound(B, 2)
    n = aUB - aLB + 1
    m = bUB2 - bLB2 + 1
    If Not (aUB2 - aLB2 + 1) &lt;&gt; (bUB - bLB + 1) Then
        ReDim c(0 To n - 1, 0 To m - 1)
        For i = 0 To n - 1
            For j = 0 To m - 1
                pSum = 0
                For jj = 0 To aUB2 - aLB2        &apos;Loop a() columns
                    pSum = pSum + A(aLB + jj) * B(bLB + jj, bLB2 + j)
                Next jj
                c(i, j) = pSum
            Next j
        Next i
    End If
End Sub

Private Function WeekDayName_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = ToLiteralString(WeekdayName( _
                            CLng(FormatLiteralString(tmpData(LB), True)) _
                            ))
        Case 2
            tmpEval = ToLiteralString(WeekdayName( _
                            CLng(FormatLiteralString(tmpData(LB), True)), _
                            CBool(FormatLiteralString(tmpData(UB), True)) _
                            ))
        Case 3
            tmpEval = ToLiteralString(WeekdayName( _
                            CLng(FormatLiteralString(tmpData(LB), True)), _
                            CBool(FormatLiteralString(tmpData(LB + 1), True)), _
                            CLng(FormatLiteralString(tmpData(UB), True)) _
                            ))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    WeekDayName_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    WeekDayName_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function WeekDay_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = Weekday( _
                            FormatLiteralString(tmpData(LB), True) _
                            )
        Case 2
            tmpEval = Weekday( _
                            FormatLiteralString(tmpData(LB), True), _
                            CLng(FormatLiteralString(tmpData(UB), True)) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    WeekDay_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    WeekDay_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Year_(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 1
            tmpEval = Year( _
                            FormatLiteralString(tmpData(LB), True) _
                            )
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Year_ = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Year_ = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function

Private Function Zero(ByRef expression As String, ByRef fName As String) As String
    Dim argsCount As Long
    Dim tmpData() As String
    Dim tmpEval As String
    Dim LB As Long, UB As Long
    
    On Error GoTo err_Handler
    tmpData() = SplitArgs(expression)
    LB = LBound(tmpData)
    UB = UBound(tmpData)
    argsCount = UB - LB + 1
    Select Case argsCount
        Case 3
            tmpEval = fZeroMBM( _
                            FormatLiteralString(tmpData(LB), True) _
                            , CDbl(FormatLiteralString(tmpData(LB + 1), True)) _
                            , CDbl(FormatLiteralString(tmpData(UB), True)))
        Case 4
            tmpEval = fZeroMBM( _
                            FormatLiteralString(tmpData(LB), True) _
                            , CDbl(FormatLiteralString(tmpData(LB + 1), True)) _
                            , CDbl(FormatLiteralString(tmpData(LB + 2), True)), _
                            CBool(FormatLiteralString(tmpData(UB), True)))
        Case Else
            tmpEval = e_ValueError
              BuildErrMessage errMissingArgsOrTooManyArgs, d_lCurly &amp; fName &amp; d_rCurly
    End Select
    Zero = tmpEval: Erase tmpData
    Exit Function
err_Handler:
    Zero = e_ValueError
    BuildErrMessage errEvalError, d_lCurly &amp; fName &amp; d_rCurly &amp; &quot; | Error#: &quot; &amp; err.Number &amp; d_Space &amp; _
                                    d_lParenthesis &amp; err.Description &amp; d_rParenthesis
End Function
</script:module>