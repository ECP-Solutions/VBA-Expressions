VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "VM"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
' Class Module: VM (AST executor)
Option Explicit

' Executes AST nodes produced by Compiler (AST).
' Uses Map node types and ScopeStack. Logs to gRuntimeLog.

' Node helpers (Map-based)
Private Function MakeNode(nodeType As String) As Map
    Dim m As New Map
    m.Add "type", nodeType
    Set MakeNode = m
End Function

Public Sub RunProgramByIndex(idx As Long)
    ASF_InitGlobals
    If idx < 1 Or idx > gPrograms.Count Then Exit Sub
    Dim p As Variant: p = gPrograms(idx)
    Dim progName As String: progName = p(0)
    Dim stmts As Collection: Set stmts = p(1)
    Dim rawScope As Collection: Set rawScope = p(2)
    Dim progScope As New ScopeStack
    progScope.LoadRaw rawScope
    progScope.Push
    gRuntimeLog.Add "RUN Program: " & progName
    Dim i As Long
    For i = 1 To stmts.Count
        Dim ctrl As String
        ctrl = ExecuteStmtNode(stmts(i), progScope)
        If ctrl = "RETURN" Then Exit For
        If ctrl = "ERR" Then Exit For
    Next i
    progScope.Pop
End Sub

' Execute a statement node (Map). Return control signals: "", "BREAK", "CONTINUE", "RETURN", "ERR"
Private Function ExecuteStmtNode(node As Map, progScope As ScopeStack) As String
    On Error GoTo ErrHandler
    Dim tp As String: tp = node.GetValue("type")
    Dim rval As Variant
    Select Case tp
        Case "Print"
            Dim args As Collection: Set args = node.GetValue("args")
            Dim outParts As New Collection
            Dim i As Long
            For i = 1 To args.Count
                Dim v As Variant: v = EvalExprNode(args(i), progScope)
                outParts.Add ValueToStringForPrint(v)
            Next i
            Dim sb As String: sb = ""
            For i = 1 To outParts.Count
                If i > 1 Then sb = sb & ", "
                sb = sb & outParts(i)
            Next i
            gRuntimeLog.Add "PRINT:" & sb
            Debug.Print sb
            ExecuteStmtNode = ""
            Exit Function

        Case "Assign"
            Dim left As Map: Set left = node.GetValue("left")
            Dim right As Map: Set right = node.GetValue("right")
            rval = EvalExprNode(right, progScope)
            HandleAssignment left, rval, progScope
            ExecuteStmtNode = ""
            Exit Function

        Case "ExprStmt"
            Dim res As Variant: res = EvalExprNode(node.GetValue("expr"), progScope)
            ExecuteStmtNode = ""
            Exit Function

        Case "If"
            ExecuteStmtNode = ExecIfNode(node, progScope)
            Exit Function

        Case "For"
            ExecuteStmtNode = ExecForNode(node, progScope)
            Exit Function

        Case "While"
            ExecuteStmtNode = ExecWhileNode(node, progScope)
            Exit Function

        Case "Break"
            ExecuteStmtNode = "BREAK": Exit Function
        Case "Continue"
            ExecuteStmtNode = "CONTINUE": Exit Function

        Case "Return"
            Dim rex As Map: Set rex = node.GetValue("expr")
            If Not rex Is Nothing Then rval = EvalExprNode(rex, progScope) Else rval = Empty
            progScope.SetValue "__return", rval
            ExecuteStmtNode = "RETURN": Exit Function

        Case "TryCatch"
            ExecuteStmtNode = ExecTryCatchNode(node, progScope)
            Exit Function

        Case "Switch"
            ExecuteStmtNode = ExecSwitchNode(node, progScope)
            Exit Function

        Case Else
            ' unknown node type
            gRuntimeLog.Add "Unknown statement node: " & tp
            ExecuteStmtNode = ""
            Exit Function
    End Select

ErrHandler:
    gRuntimeLog.Add "VM statement error: " & err.Description
    err.Clear
    ExecuteStmtNode = "ERR"
End Function

' ---------------------
' Assignment helper (left node may be Variable or Index)
' ---------------------
Private Sub HandleAssignment(left As Map, rval As Variant, progScope As ScopeStack)
    Dim ltype As String: ltype = left.GetValue("type")
    If ltype = "Variable" Then
        progScope.SetValue left.GetValue("name"), rval
    ElseIf ltype = "Index" Then
        ' Evaluate base (should be variable) and index
        Dim baseNode As Map: Set baseNode = left.GetValue("base")
        Dim idxNode As Map: Set idxNode = left.GetValue("index")
        If baseNode.GetValue("type") = "Variable" Then
            Dim arrName As String: arrName = baseNode.GetValue("name")
            Dim idxV As Variant: idxV = EvalExprNode(idxNode, progScope)
            AssignToArray arrName, idxV, rval, progScope
        Else
            err.Raise vbObjectError + 6001, "VM.HandleAssignment", "Unsupported index assignment"
        End If
    ElseIf ltype = "Member" Then
        ' Member assignment: base.prop = value
        Dim baseNodeM As Map: Set baseNodeM = left.GetValue("base")
        Dim propName As String: propName = CStr(left.GetValue("prop"))
        ' Evaluate base to get the object (Map) instance
        Dim baseVal As Variant
        baseVal = EvalExprNode(baseNodeM, progScope)
        If TypeName(baseVal) = "Map" Then
            Dim baseMap As Map: Set baseMap = baseVal
            ' Use SetValue to allow overwrite
            baseMap.SetValue propName, rval
        ElseIf IsEmpty(baseVal) Then
            ' If base is empty and baseNode is a Variable, create a new Map and assign
            If baseNodeM.GetValue("type") = "Variable" Then
                Dim newMap As New Map
                newMap.Add propName, rval
                progScope.SetValue baseNodeM.GetValue("name"), newMap
            Else
                err.Raise vbObjectError + 6003, "VM.HandleAssignment", "Cannot assign property to non-object base"
            End If
        Else
            err.Raise vbObjectError + 6004, "VM.HandleAssignment", "Cannot assign property to non-object base"
        End If
    Else
        err.Raise vbObjectError + 6002, "VM.HandleAssignment", "Invalid assignment target"
    End If
End Sub

' Reuse your AssignToArray logic
Private Sub AssignToArray(arrName As String, idxV As Variant, val As Variant, progScope As ScopeStack)
    Dim arr As Variant
    Dim pos As Long
    Dim ub As Long
    Dim lb As Long

    arr = progScope.GetValue(arrName)
    pos = CLng(idxV)
    If pos < 1 Then
        err.Raise vbObjectError + 5001, "VM.AssignToArray", "Invalid array index (must be >=1)"
    End If
    If Not IsArray(arr) Then
        If IsEmpty(arr) Then
            arr = Array()
        Else
            err.Raise vbObjectError + 5002, "VM.AssignToArray", "Not an array"
        End If
    End If
    ub = -1
    If IsArray(arr) Then
        ub = UBound(arr)
    End If
    If ub < 0 Then
        ReDim arr(1 To pos)
    Else
        lb = LBound(arr)
        If pos > (ub - lb + 1) Then
            ReDim Preserve arr(lb To lb + pos - 1)
        End If
    End If
    arr(LBound(arr) + pos - 1) = val
    progScope.SetValue arrName, arr
End Sub

' ---------------------
' ExecIfNode: Evaluate condition, then execute proper block
' ---------------------
Private Function ExecIfNode(node As Map, progScope As ScopeStack) As String
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    If IsTruthy(EvalExprNode(condNode, progScope)) Then
        Dim thenStmts As Collection: Set thenStmts = node.GetValue("then")
        Dim si As Long
        For si = 1 To thenStmts.Count
            Dim ctrl As String: ctrl = ExecuteStmtNode(thenStmts(si), progScope)
            If ctrl <> "" Then ExecIfNode = ctrl: Exit Function
        Next si
        ExecIfNode = ""
        Exit Function
    End If
    Dim elseifConds As Collection: Set elseifConds = node.GetValue("elseif_conds")
    Dim elseifBlocks As Collection: Set elseifBlocks = node.GetValue("elseif_blocks")
    Dim idx As Long
    For idx = 1 To elseifConds.Count
        If IsTruthy(EvalExprNode(elseifConds(idx), progScope)) Then
            Dim bl As Collection: Set bl = elseifBlocks(idx)
            Dim si2 As Long
            For si2 = 1 To bl.Count
                Dim ctrl2 As String: ctrl2 = ExecuteStmtNode(bl(si2), progScope)
                If ctrl2 <> "" Then ExecIfNode = ctrl2: Exit Function
            Next si2
            ExecIfNode = ""
            Exit Function
        End If
    Next idx
    If node.GetValue("hasElse") Then
        Dim els As Collection: Set els = node.GetValue("else")
        Dim ee As Long
        For ee = 1 To els.Count
            Dim ctrl3 As String: ctrl3 = ExecuteStmtNode(els(ee), progScope)
            If ctrl3 <> "" Then ExecIfNode = ctrl3: Exit Function
        Next ee
    End If
    ExecIfNode = ""
End Function

' ---------------------
' ExecForNode
' ---------------------
Private Function ExecForNode(node As Map, progScope As ScopeStack) As String
    Dim initNode As Map: Set initNode = node.GetValue("init")
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    Dim stepNode As Map: Set stepNode = node.GetValue("step")
    Dim body As Collection: Set body = node.GetValue("body")
    Dim condOk As Boolean
    
    If Not initNode Is Nothing Then
        Dim initType As String
        initType = initNode.GetValue("type")
        Select Case initType
            Case "Assign", "Print", "If", "For", "While", "TryCatch", "Switch", "Return", "Break", "Continue", "ExprStmt"
                ' Already a statement node  execute directly so side-effects happen.
                ExecuteStmtNode initNode, progScope
            Case Else
                ' Expression node  wrap into ExprStmt for side-effect evaluation.
                ExecuteStmtNode MakeNodeExprStmt(initNode), progScope
        End Select
    End If

ForStart:
    condOk = True
    If Not condNode Is Nothing Then
        condOk = IsTruthy(EvalExprNode(condNode, progScope))
    End If
    If Not condOk Then GoTo ForEnd

    Dim s As Long
    For s = 1 To body.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(body(s), progScope)
        If ctrl = "BREAK" Then GoTo ForEnd
        If ctrl = "CONTINUE" Then Exit For
        If ctrl = "RETURN" Or ctrl = "ERR" Then ExecForNode = ctrl: Exit Function
    Next s

    If Not stepNode Is Nothing Then
        Dim stepType As String
        stepType = stepNode.GetValue("type")
        Select Case stepType
            Case "Assign", "Print", "If", "For", "While", "TryCatch", "Switch", "Return", "Break", "Continue", "ExprStmt"
                ExecuteStmtNode stepNode, progScope
            Case Else
                ExecuteStmtNode MakeNodeExprStmt(stepNode), progScope
        End Select
    End If
    GoTo ForStart

ForEnd:
    ExecForNode = ""
End Function

' Helper to wrap an expression node into an ExprStmt node
Private Function MakeNodeExprStmt(expr As Map) As Map
    Dim m As Map: Set m = MakeNode("ExprStmt")
    m.SetValue "expr", expr
    Set MakeNodeExprStmt = m
End Function

' ---------------------
' ExecWhileNode
' ---------------------
Private Function ExecWhileNode(node As Map, progScope As ScopeStack) As String
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    Dim body As Collection: Set body = node.GetValue("body")

WhileStart:
    If Not IsTruthy(EvalExprNode(condNode, progScope)) Then GoTo WhileEnd
    Dim i As Long
    For i = 1 To body.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(body(i), progScope)
        If ctrl = "BREAK" Then GoTo WhileEnd
        If ctrl = "CONTINUE" Then Exit For
        If ctrl = "RETURN" Or ctrl = "ERR" Then ExecWhileNode = ctrl: Exit Function
    Next i
    GoTo WhileStart

WhileEnd:
    ExecWhileNode = ""
End Function

' ---------------------
' ExecTryCatchNode
' ---------------------
Private Function ExecTryCatchNode(node As Map, progScope As ScopeStack) As String
    On Error GoTo TryErr
    Dim tryStmts As Collection: Set tryStmts = node.GetValue("try")
    Dim i As Long
    For i = 1 To tryStmts.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(tryStmts(i), progScope)
        If ctrl = "RETURN" Or ctrl = "ERR" Then ExecTryCatchNode = ctrl: Exit Function
    Next i
    ExecTryCatchNode = ""
    Exit Function

TryErr:
    err.Clear
    Dim catchStmts As Collection: Set catchStmts = node.GetValue("catch")
    If Not catchStmts Is Nothing Then
        Dim j As Long
        For j = 1 To catchStmts.Count
            Dim cctrl As String: cctrl = ExecuteStmtNode(catchStmts(j), progScope)
            If cctrl = "RETURN" Or cctrl = "ERR" Then ExecTryCatchNode = cctrl: Exit Function
        Next j
    End If
    ExecTryCatchNode = ""
End Function

' ---------------------
' ExecSwitchNode
' ---------------------
Private Function ExecSwitchNode(node As Map, progScope As ScopeStack) As String
    Dim switchVal As Variant: switchVal = EvalExprNode(node.GetValue("expr"), progScope)
    Dim cases As Collection: Set cases = node.GetValue("cases")
    Dim i As Long
    For i = 1 To cases.Count
        Dim pair As Collection: Set pair = cases(i)
        Dim caseExpr As Map: Set caseExpr = pair(1)
        Dim blockStmts As Collection: Set blockStmts = pair(2)
        If EvalExprNode(caseExpr, progScope) = switchVal Then
            Dim s As Long
            For s = 1 To blockStmts.Count
                Dim ctrl As String: ctrl = ExecuteStmtNode(blockStmts(s), progScope)
                If ctrl = "BREAK" Then ExecSwitchNode = "": Exit Function
                If ctrl = "RETURN" Or ctrl = "ERR" Then ExecSwitchNode = ctrl: Exit Function
            Next s
        End If
    Next i
    Dim defBlk As Collection: Set defBlk = node.GetValue("default")
    If Not defBlk Is Nothing Then
        Dim d As Long
        For d = 1 To defBlk.Count
            Dim ctrl2 As String: ctrl2 = ExecuteStmtNode(defBlk(d), progScope)
            If ctrl2 = "BREAK" Then ExecSwitchNode = "": Exit Function
            If ctrl2 = "RETURN" Or ctrl2 = "ERR" Then ExecSwitchNode = ctrl2: Exit Function
        Next d
    End If
    ExecSwitchNode = ""
End Function

Private Sub vAssignment(ByRef var As Variant, ByRef vValue As Variant)
    If IsObject(vValue) Then
        Set var = vValue
    Else
        var = vValue
    End If
End Sub
' ---------------------
' Expression evaluator: Evaluate Expr AST nodes to runtime values
' ---------------------
Private Function EvalExprNode(node As Map, progScope As ScopeStack) As Variant
    If node Is Nothing Then EvalExprNode = Empty: Exit Function
    Dim tp As String: tp = node.GetValue("type")
    Dim items As Collection
    Dim tmpResult As Variant
    
    Select Case tp
        Case "VBEXPR"
            ' Forced VBAexpression node (from @(...)). The node stores the raw VB expression string in "expr".
            Dim rawVB As String: rawVB = node.GetValue("expr")
            vAssignment tmpResult, EvalVBExpressionWithScope(rawVB, progScope)
            GoTo exitfun
        Case "Object"
            ' Build and return a Map containing the evaluated properties
            Set items = node.GetValue("items")
            Dim om As New Map
            Dim pi As Long
            Dim valNode As Map
            Dim pair As Collection
            Dim key As String
            For pi = 1 To items.Count
                Set pair = items(pi)
                key = CStr(pair(1))
                Set valNode = pair(2)
                om.SetValue key, EvalExprNode(valNode, progScope)
            Next pi
            ' Return Map object (as Variant holding the object)
            vAssignment tmpResult, om
            GoTo exitfun
        Case "Literal"
            vAssignment tmpResult, node.GetValue("value")
            GoTo exitfun
        Case "Variable"
            vAssignment tmpResult, progScope.GetValue(node.GetValue("name"))
            GoTo exitfun
        Case "Member"
            ' Member(base, prop)  evaluate base, then property access
            Dim baseExpr As Map: Set baseExpr = node.GetValue("base")
            Dim propStr As String: propStr = CStr(node.GetValue("prop"))
            Dim baseEvaluated As Variant
            baseEvaluated = EvalExprNode(baseExpr, progScope)
            ' special-case array length: if prop == "length" and base is array, return length
            If propStr = "length" Then
                If IsArray(baseEvaluated) Then
                    Dim ub2 As Long
                    ub2 = UBound(baseEvaluated)
                    If ub2 < LBound(baseEvaluated) Then
                        vAssignment tmpResult, 0
                    Else
                        vAssignment tmpResult, ub2 - LBound(baseEvaluated) + 1
                    End If
                    GoTo exitfun
                End If
            End If
            ' if base is Map, return stored property
            If TypeName(baseEvaluated) = "Map" Then
                Dim bm As Map: Set bm = baseEvaluated
                vAssignment tmpResult, bm.GetValue(propStr)
                GoTo exitfun
            End If
            ' otherwise no property -> Empty
            vAssignment tmpResult, Empty
            GoTo exitfun
        Case "Array"
            Set items = node.GetValue("items")
            If items.Count = 0 Then
                vAssignment tmpResult, Array()
                GoTo exitfun
            End If
            Dim a() As Variant
            ReDim a(1 To items.Count)
            Dim ii As Long
            For ii = 1 To items.Count
                a(ii) = EvalExprNode(items(ii), progScope)
            Next ii
            vAssignment tmpResult, a
            GoTo exitfun
        Case "Index"
            Dim base As Map: Set base = node.GetValue("base")
            Dim idxNode As Map: Set idxNode = node.GetValue("index")
            If base.GetValue("type") = "Variable" Then
                Dim arr As Variant: arr = progScope.GetValue(base.GetValue("name"))
                If Not IsArray(arr) Then vAssignment tmpResult, Empty: GoTo exitfun
                Dim pos As Long: pos = CLng(EvalExprNode(idxNode, progScope))
                vAssignment tmpResult, arr(LBound(arr) + pos - 1)
                GoTo exitfun
            Else
                vAssignment tmpResult, Empty: GoTo exitfun
            End If
        Case "Call"
            Dim fname As String: fname = node.GetValue("name")
            ' builtin length function
            If fname = ".__len__" Then
                Dim argn As Collection: Set argn = node.GetValue("args")
                Dim av As Variant: av = EvalExprNode(argn(1), progScope)
                If Not IsArray(av) Then
                    vAssignment tmpResult, 0
                Else
                    vAssignment tmpResult, UBound(av) - LBound(av) + 1
                End If
                GoTo exitfun
            End If

            Dim argsColl As Collection: Set argsColl = node.GetValue("args")
            Dim evaluated As New Collection
            Dim k As Long
            For k = 1 To argsColl.Count
                evaluated.Add EvalExprNode(argsColl(k), progScope)
            Next k

            ' resolve function by name via gFuncTable
            If gFuncTable.Exists(fname) Then
                Dim funcIdx As Long: funcIdx = CLng(gFuncTable.GetValue(fname))
                vAssignment tmpResult, CallFuncByIndex_AST(funcIdx, evaluated)
            Else
                vAssignment tmpResult, Empty
                ' Fallback: forward call to VBAexpressions by injecting arguments into VBAexpressions scope
                vAssignment tmpResult, EvalVBFunctionCall(fname, evaluated, progScope)
            End If
            GoTo exitfun

        Case "Unary"
            Dim op As String: op = node.GetValue("op")
            Dim ev As Variant: ev = EvalExprNode(node.GetValue("expr"), progScope)
            If op = "!" Then
                vAssignment tmpResult, Not IsTruthy(ev)
            ElseIf op = "-" Then
                vAssignment tmpResult, -CDbl(ev)
            Else
                vAssignment tmpResult, ev
            End If
            GoTo exitfun
        Case "Ternary"
            Dim cnd As Variant: cnd = EvalExprNode(node.GetValue("cond"), progScope)
            If IsTruthy(cnd) Then
                vAssignment tmpResult, EvalExprNode(node.GetValue("trueExpr"), progScope)
            Else
                vAssignment tmpResult, EvalExprNode(node.GetValue("falseExpr"), progScope)
            End If
            GoTo exitfun
        Case "Binary"
            Dim lop As Variant: lop = EvalExprNode(node.GetValue("left"), progScope)
            Dim rop As Variant
            Dim op2 As String: op2 = node.GetValue("op")
            If op2 = "&&" Then
                If Not IsTruthy(lop) Then vAssignment tmpResult, False: GoTo exitfun
                rop = EvalExprNode(node.GetValue("right"), progScope)
                vAssignment tmpResult, (IsTruthy(lop) And IsTruthy(rop))
                GoTo exitfun
            ElseIf op2 = "||" Then
                If IsTruthy(lop) Then vAssignment tmpResult, True: GoTo exitfun
                rop = EvalExprNode(node.GetValue("right"), progScope)
                vAssignment tmpResult, (IsTruthy(lop) Or IsTruthy(rop))
                GoTo exitfun
            Else
                rop = EvalExprNode(node.GetValue("right"), progScope)
                Select Case op2
                    Case "+"
                        vAssignment tmpResult, SafeAdd(lop, rop)
                    Case "-": vAssignment tmpResult, lop - rop
                    Case "*": vAssignment tmpResult, lop * rop
                    Case "/"
                        If rop = 0 Then err.Raise vbObjectError + 2001, "VM.EvalExprNode", "Division by zero" Else vAssignment tmpResult, lop / rop
                    Case "%": vAssignment tmpResult, lop Mod rop
                    Case "^": vAssignment tmpResult, lop ^ rop
                    Case "==", "=": vAssignment tmpResult, (lop = rop)
                    Case "!=": vAssignment tmpResult, (lop <> rop)
                    Case "<": vAssignment tmpResult, (lop < rop)
                    Case ">": vAssignment tmpResult, (lop > rop)
                    Case "<=": vAssignment tmpResult, (lop <= rop)
                    Case ">=": vAssignment tmpResult, (lop >= rop)
                    Case Else
                        vAssignment tmpResult, Empty
                End Select
                GoTo exitfun
            End If
    End Select

    vAssignment tmpResult, Empty
exitfun:
    If IsObject(tmpResult) Then
        Set EvalExprNode = tmpResult
    Else
        EvalExprNode = tmpResult
    End If
End Function

' Call function program by index (AST). "args" is Collection of evaluated arg values.
Private Function CallFuncByIndex_AST(funcIdx As Long, args As Collection) As Variant
    Dim p As Variant: p = gPrograms(funcIdx)
    Dim rawScope As Collection: Set rawScope = p(2)
    Dim callScope As New ScopeStack
    Dim i As Long
    callScope.LoadRaw rawScope
    callScope.Push
    Dim fname As String: fname = p(0)
    ' set params from gFuncParams
    If gFuncParams.Exists(fname) Then
        Dim pa As Variant: pa = gFuncParams.GetValue(fname)
        For i = LBound(pa) To UBound(pa)
            If i - LBound(pa) + 1 <= args.Count Then
                callScope.SetValue CStr(pa(i)), args(i - LBound(pa) + 1)
            Else
                callScope.SetValue CStr(pa(i)), Empty
            End If
        Next i
    End If

    Dim stmts As Collection: Set stmts = p(1)
    For i = 1 To stmts.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(stmts(i), callScope)
        If ctrl = "RETURN" Then
            CallFuncByIndex_AST = callScope.GetValue("__return")
            callScope.Pop
            Exit Function
        ElseIf ctrl = "ERR" Then
            err.Raise vbObjectError + 3000, "VM.CallFunc", "Error during function execution"
        End If
    Next i
    CallFuncByIndex_AST = Empty
    callScope.Pop
End Function

' ---------------------
' Utilities adapted from your previous VM
' ---------------------
Private Function IsTruthy(v As Variant) As Boolean
    If IsObject(v) Then IsTruthy = Not v Is Nothing: Exit Function
    If IsNull(v) Then IsTruthy = False: Exit Function
    If IsEmpty(v) Then IsTruthy = False: Exit Function
    If VarType(v) = vbBoolean Then IsTruthy = CBool(v): Exit Function
    If IsNumeric(v) Then IsTruthy = (CDbl(v) <> 0): Exit Function
    If VarType(v) = vbString Then
        If IsBoolean(CStr(v)) Then IsTruthy = CBool(v) Else IsTruthy = (CStr(v) <> "")
        Exit Function
    End If
    IsTruthy = True
End Function

Private Function IsBoolean(ByRef expression As String) As Boolean
    IsBoolean = (LCase(expression) = "true")
    If Not IsBoolean Then IsBoolean = (LCase(expression) = "false")
End Function

Private Function SafeAdd(a As Variant, b As Variant) As Variant
    If IsNumeric(a) And IsNumeric(b) Then SafeAdd = a + b Else SafeAdd = CStr(a) & CStr(b)
End Function

Private Function ValueToStringForPrint(v As Variant) As String
    Dim ub As Long, s As String, i As Long
    If Not IsArray(v) Then
        If IsNull(v) Then ValueToStringForPrint = "NULL": Exit Function
        If IsEmpty(v) Then ValueToStringForPrint = "": Exit Function
        ' pretty-print Map objects as {k: v, ...}
        If TypeName(v) = "Map" Then
            Dim outMap As String: outMap = "{"
            Dim keysCol As Collection
            Set keysCol = v.keys
            Dim kk As Long
            For kk = 1 To keysCol.Count
                If kk > 1 Then outMap = outMap & ", "
                Dim kname As String: kname = CStr(keysCol(kk))
                Dim kval As Variant: kval = v.GetValue(kname)
                outMap = outMap & kname & ": " & ValueToStringForPrint(kval)
            Next kk
            outMap = outMap & "}"
            ValueToStringForPrint = outMap
            Exit Function
        End If
        ValueToStringForPrint = CStr(v): Exit Function
    End If
    ub = UBound(v)
    If ub < 0 Then ValueToStringForPrint = "[]": Exit Function
    s = "["
    For i = LBound(v) To ub
        If i > LBound(v) Then s = s & ", "
        s = s & CStr(v(i))
    Next i
    ValueToStringForPrint = s & "]"
End Function

 ' VBAexpressions integration helpers
 ' ---------------------
 ' Evaluate a raw VBAexpressions expression string using a VBAexpressions instance,
 ' seeding it with the current ASF scope variables so VB expressions can reference ASF variables.
Private Function EvalVBExpressionWithScope(expr As String, progScope As ScopeStack) As Variant
     On Error GoTo ErrHandler
     Dim exprEval As VBAexpressions
     Set exprEval = New VBAexpressions

     ' Create expression in evaluator
     exprEval.Create expr

     ' Inject variables from progScope (shadowing: global frames first, then locals)
     Dim frame As Variant
     Dim m As Map
     Dim keyCol As Collection
     Dim key As Variant
     For Each frame In progScope.Raw
         Set m = frame
         Set keyCol = m.keys
         For Each key In keyCol
             exprEval.VarValue(CStr(key)) = m.GetValue(CStr(key))
         Next key
     Next frame

     ' Evaluate
     exprEval.Eval
     If exprEval.ErrorType = 0 Then
         EvalVBExpressionWithScope = exprEval.result
     Else
         ' On error, raise to caller; the try/catch at Exec layer can handle it
         err.Raise vbObjectError + 7001, "VM.EvalVBExpressionWithScope", "VBAexpressions eval error"
     End If
     Exit Function
ErrHandler:
     ' convert to runtime log and return Empty
     gRuntimeLog.Add "VBAexpr error: " & err.Description
     err.Clear
     EvalVBExpressionWithScope = Empty
End Function

 ' Evaluate a function call in VBAexpressions. Args is a Collection of evaluated values.
 ' We create a temporary variable for each argument inside the VBAexpressions environment
 ' to avoid needing to serialize complex values into textual literals.
Private Function EvalVBFunctionCall(fname As String, args As Collection, progScope As ScopeStack) As Variant
     On Error GoTo ErrHandler
     Dim exprEval As VBAexpressions
     Set exprEval = New VBAexpressions

     ' Seed evaluator with ASF scope variables
     Dim frame As Variant
     Dim m As Map
     Dim keyCol As Collection
     Dim key As Variant
     For Each frame In progScope.Raw
         Set m = frame
         Set keyCol = m.keys
         For Each key In keyCol
             exprEval.VarValue(CStr(key)) = m.GetValue(CStr(key))
         Next key
     Next frame

     ' Inject arguments as temporary variables: __asf_vbarg_1, __asf_vbarg_2, ...
     Dim i As Long
     Dim tmpNames As New Collection
     For i = 1 To args.Count
         Dim tname As String: tname = "__asf_vbarg_" & CStr(i)
         tmpNames.Add tname
         exprEval.VarValue(tname) = args(i)
     Next i

     ' build call string referencing temp names
     Dim callStr As String: callStr = fname & "("
     For i = 1 To tmpNames.Count
         If i > 1 Then callStr = callStr & ","
         callStr = callStr & tmpNames(i)
     Next i
     callStr = callStr & ")"

     ' Evaluate
     exprEval.Create callStr
     exprEval.Eval
     If exprEval.ErrorType = 0 Then
         EvalVBFunctionCall = exprEval.result
     Else
         err.Raise vbObjectError + 7002, "VM.EvalVBFunctionCall", "VBAexpressions function call error"
     End If
     Exit Function
ErrHandler:
     gRuntimeLog.Add "VBAexpr function-call error: " & err.Description
     err.Clear
     EvalVBFunctionCall = Empty
End Function
