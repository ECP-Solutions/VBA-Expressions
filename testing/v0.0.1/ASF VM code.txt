VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "VM"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
' ---------------------
' VM class
' ---------------------
' Class Module: VM (AST executor)
Option Explicit
Private lastIndexBaseSlot As Long
Private lastIndexBaseName As String
Private Const VTP_MAX_DEPTH As Long = 8    ' safety depth limit
Private Const VTP_MAX_ITEMS_INLINE As Long = 8 ' prefer inline for small containers
Private VERBOSE_ As Boolean
Private GLOBALS_ As Globals
Private OUTPUT__ As Variant
Private Const OP_NOP = 0
Private Const OP_PUSH_CONST = 1
Private Const OP_LOAD_FAST = 2
Private Const OP_STORE_FAST = 3
Private Const OP_LOAD_NAME = 4
Private Const OP_STORE_NAME = 5
Private Const OP_BINARY = 6
Private Const OP_MAKE_ARRAY = 7
Private Const OP_PRINT = 8
Private Const OP_POP = 9
Private Const OP_JUMP = 10
Private Const OP_JUMP_IF_FALSE = 11
Private Const OP_PUSH_AST_NODE = 12
Private Const OP_LOAD_MEMBER_KEEP_BASE = 13
Private Const OP_MEMBER_SET = 14
Private Const OP_INDEX_GET = 15
Private Const OP_INDEX_SET = 16
Private Const OP_BUILTIN_FAST = 17
Private Const OP_CALL = 18
Private Const OP_CALL_FUNC = 19
Private Const OP_CALL_FUNC_WITH_THIS = 20
Private Const OP_RETURN = 21
Private Const OP_MEMBER_OF_VALUE = 22
Private Const OP_LOAD_MEMBER_FROM_VALUE_KEEP_BASE = 23
' Executes AST nodes produced by Compiler (AST).
' Uses Map node types and ScopeStack. Logs to gRuntimeLog.

Public Sub SetGlobals(aGlobals As Globals)
    Set GLOBALS_ = aGlobals
End Sub
Public Property Get OUTPUT_() As Variant
    vAssignment OUTPUT_, OUTPUT__
End Property
Public Property Get verbose() As Boolean
    verbose = VERBOSE_
End Property
Public Property Let verbose(aValue As Boolean)
    VERBOSE_ = aValue
End Property

' Node helpers (Map-based)
Private Function MakeNode(nodeType As String) As Map
    Dim M As New Map
    M.Add "type", nodeType
    Set MakeNode = M
End Function

Public Sub RunProgramByIndex(idx As Long)
    GLOBALS_.ASF_InitGlobals
    If idx < 1 Or idx > GLOBALS_.gPrograms.Count Then Exit Sub
    Dim p As Variant: p = GLOBALS_.gPrograms(idx)
    Dim progName As String: progName = p(0)
    Dim stmts As Collection: Set stmts = p(1)
    Dim rawScope As Collection: Set rawScope = p(2)
    Dim optionBase As Long: optionBase = IIf(UBound(p) >= 3, p(3), 1)
    Dim progScope As New ScopeStack
    progScope.LoadRaw rawScope
    progScope.SetValue "__option_base", optionBase
    progScope.Push
    If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "RUN Program: " & progName
    If GLOBALS_.gProgramsBytecode.Count Then
        If idx >= 1 And idx <= GLOBALS_.gProgramsBytecode.Count Then
            Me.RunCompactBytecodeProgram idx, progScope, verbose
            Exit Sub
        End If
    End If
    Dim i As Long
    For i = 1 To stmts.Count
        Dim ctrl As String
        ctrl = ExecuteStmtNode(stmts(i), progScope)
        If ctrl = "RETURN" Then
            vAssignment OUTPUT__, progScope.GetValue("__return")
            Exit For
        End If
        If ctrl = "ERR" Then Exit For
    Next i
    progScope.Pop
End Sub

' Execute a statement node (Map). Return control signals: "", "BREAK", "CONTINUE", "RETURN", "ERR"
Private Function ExecuteStmtNode(node As Map, progScope As ScopeStack) As String
    On Error GoTo ErrHandler
    Dim tp As String: tp = node.GetValue("type")
    Dim rval As Variant
    Dim i As Long
    Select Case tp
        Case "Print"
            Dim args As Collection: Set args = node.GetValue("args")
            Dim outParts As New Collection
            For i = 1 To args.Count
                Dim v As Variant: vAssignment v, EvalExprNode(args(i), progScope)
                outParts.Add ValueToStringForPrint(v)
            Next i
            Dim sb As String: sb = ""
            For i = 1 To outParts.Count
                If i > 1 Then sb = sb & ", "
                sb = sb & outParts(i)
            Next i
            If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "PRINT:" & sb
            Debug.Print sb
            ExecuteStmtNode = ""
            Exit Function

        Case "Assign"
            Dim left As Map: Set left = node.GetValue("left")
            Dim right As Map: Set right = node.GetValue("right")
            vAssignment rval, EvalExprNode(right, progScope)
            HandleAssignment left, rval, progScope
            If left.GetValue("type") = "Variable" Then
                Dim lName As String: lName = left.GetValue("name")
            End If
            ExecuteStmtNode = ""
            Exit Function

        Case "ExprStmt"
            Dim res As Variant: res = EvalExprNode(node.GetValue("expr"), progScope)
            ExecuteStmtNode = ""
            Exit Function

        Case "If"
            ExecuteStmtNode = ExecIfNode(node, progScope)
            Exit Function

        Case "For"
            ExecuteStmtNode = ExecForNode(node, progScope)
            Exit Function

        Case "While"
            ExecuteStmtNode = ExecWhileNode(node, progScope)
            Exit Function

        Case "Break"
            ExecuteStmtNode = "BREAK": Exit Function
        Case "Continue"
            ExecuteStmtNode = "CONTINUE": Exit Function

        Case "Return"
            Dim rex As Map: Set rex = node.GetValue("expr")
            If Not rex Is Nothing Then vAssignment rval, EvalExprNode(rex, progScope) Else rval = Empty
            progScope.SetValue "__return", rval
            ExecuteStmtNode = "RETURN": Exit Function

        Case "TryCatch"
            ExecuteStmtNode = ExecTryCatchNode(node, progScope)
            Exit Function

        Case "Switch"
            ExecuteStmtNode = ExecSwitchNode(node, progScope)
            Exit Function

        Case Else
            ' unknown node type
            If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "Unknown statement node: " & tp
            ExecuteStmtNode = ""
            Exit Function
    End Select

ErrHandler:
    If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "VM statement error: " & err.Description
    err.Clear
    ExecuteStmtNode = "ERR"
End Function

' Reuse your AssignToArray logic
Private Sub AssignToArray(arrName As String, idxv As Variant, val As Variant, progScope As ScopeStack)
    Dim arr As Variant
    Dim pos As Long
    Dim ub As Long
    Dim lb As Long
    Dim optionBase As Long: optionBase = progScope.GetValue("__option_base")
    
    arr = progScope.GetValue(arrName)
    pos = CLng(idxv)
    If pos < optionBase Then
        err.Raise vbObjectError + 5001, "VM.AssignToArray", "Invalid array index (must be >=1)"
    End If
    If Not IsArray(arr) Then
        If IsEmpty(arr) Then
            arr = Array()
        Else
            err.Raise vbObjectError + 5002, "VM.AssignToArray", "Not an array"
        End If
    End If
    ub = -1
    If IsArray(arr) Then
        ub = UBound(arr)
    End If
    If ub < 0 Then
        ReDim arr(1 To pos)
    Else
        lb = LBound(arr)
        If pos > (ub - lb + 1) Then
            ReDim Preserve arr(lb To lb + (pos - optionBase))
        End If
    End If
    arr(LBound(arr) + (pos - optionBase)) = val
    progScope.SetValue arrName, arr
End Sub

Private Function EvalMemberNode(node As Map, progScope As ScopeStack) As Variant
    If Not node.Exists("prop") And Not node.Exists("property") Then err.Raise vbObjectError + 5010, "VM.EvalMemberNode", "Missing prop/property in Member node"
    Dim propKey As String: propKey = IIf(node.Exists("prop"), "prop", "property")  ' Twist: auto-detect
    Dim prop As String: prop = node.GetValue(propKey)
    Dim baseVal As Variant
    vAssignment baseVal, EvalExprNode(node.GetValue("base"), progScope)
    If TypeName(baseVal) <> "Map" Then err.Raise vbObjectError + 5007, "VM.EvalMemberNode", "Cannot access property on non-map"
    vAssignment EvalMemberNode, baseVal.GetValue(prop)
End Function

Private Function EvalIndexNode(node As Map, progScope As ScopeStack) As Variant
    If Not node.Exists("index") Then err.Raise vbObjectError + 5011, "VM.EvalIndexNode", "Missing index in Index node"
    Dim baseVal As Variant
    vAssignment baseVal, EvalExprNode(node.GetValue("base"), progScope)
    Dim idxv As Variant: vAssignment idxv, EvalExprNode(node.GetValue("index"), progScope)
    Dim pos As Long: pos = CLng(idxv)
    Dim optionBase As Long: optionBase = progScope.GetValue("__option_base")
    If pos < optionBase Then err.Raise vbObjectError + 5001, "VM.EvalIndexNode", "Invalid index (must >= base)"
    If IsArray(baseVal) Then
        Dim lb As Long: lb = LBound(baseVal)
        Dim ub As Long: ub = UBound(baseVal)
        Dim adjustedPos As Long: adjustedPos = lb + (pos - optionBase)
        If adjustedPos > ub Then err.Raise vbObjectError + 5005, "VM.EvalIndexNode", "Index out of bounds"
        vAssignment EvalIndexNode, baseVal(adjustedPos)
    ElseIf TypeName(baseVal) = "Map" Then
        vAssignment EvalIndexNode, baseVal.GetValue(pos)
    Else
        err.Raise vbObjectError + 5006, "VM.EvalIndexNode", "Cannot index non-array/non-map"
    End If
End Function

Private Function EvalArrayNode(node As Map, progScope As ScopeStack) As Variant
    Dim items As Collection: Set items = node.GetValue("items")
    Dim arr As Variant
    Dim optionBase As Long: optionBase = progScope.GetValue("__option_base")
    If items Is Nothing Or items.Count = 0 Then
        ReDim arr(optionBase To optionBase)
    Else
        ReDim arr(optionBase To optionBase + items.Count - 1)
        Dim ii As Long
        For ii = 1 To items.Count
            vAssignment arr(optionBase + ii - 1), EvalExprNode(items(ii), progScope)
        Next ii
    End If
    vAssignment EvalArrayNode, arr
End Function

Private Function ParsePath(ByVal path As String) As Collection
    Dim col As New Collection
    Dim pos As Long: pos = 1
    Dim lenP As Long: lenP = Len(path)
    Dim currentPart As String
    While pos <= lenP
        Dim ch As String: ch = Mid(path, pos, 1)
        If ch = "." Then
            If currentPart <> "" Then col.Add currentPart
            currentPart = ""
            pos = pos + 1
        ElseIf ch = "[" Then
            If currentPart <> "" Then col.Add currentPart
            currentPart = ""
            Dim startB As Long: startB = pos
            pos = pos + 1
            While pos <= lenP And Mid(path, pos, 1) <> "]"
                pos = pos + 1
            Wend
            If pos > lenP Then err.Raise vbObjectError + 5003, "VM.ParsePath", "Unmatched bracket in path"
            currentPart = Mid(path, startB, pos - startB + 1)
            col.Add currentPart
            currentPart = ""
            pos = pos + 1
        Else
            currentPart = currentPart & ch
            pos = pos + 1
        End If
    Wend
    If currentPart <> "" Then col.Add currentPart
    Set ParsePath = col
End Function

Private Function ResolvePath(node As Map, progScope As ScopeStack, Optional forAssign As Boolean = False) As Map
    Dim res As New Map
    Dim tp As String: tp = node.GetValue("type")
    If tp = "Variable" Then
        If (InStr(node.GetValue("name"), ".") > 0 Or InStr(node.GetValue("name"), "[") > 0) Then
            ' Fallback for flat names (if Compiler didn't nest)
            Dim path As String: path = node.GetValue("name")
            Dim parts As Collection: Set parts = ParsePath(path) ' Add ParsePath from previous patch
            Dim current As Variant
            vAssignment current, progScope.GetValue(CStr(parts(1)))
            Dim ii As Long
            For ii = 2 To parts.Count - IIf(forAssign, 1, 0)
                Dim part As String: part = parts(ii)
                If left(part, 1) = "[" Then
                    Dim indexStr As String: indexStr = Mid(part, 2, Len(part) - 2)
                    Dim indexV As Variant: indexV = EvalVBExpressionWithScope(indexStr, progScope) ' Twist: use VBEXPR for fallback computed
                    current = GetIndexedValue(current, indexV, progScope)
                Else
                    If TypeName(current) = "Map" Then
                        vAssignment current, current.GetValue(part)
                    Else
                        err.Raise vbObjectError + 5007, "VM.ResolvePath", "Cannot access property on non-map"
                    End If
                End If
            Next ii
            If forAssign Then
                res.SetValue "container", current
                res.SetValue "key", parts(parts.Count)
                res.SetValue "kind", IIf(left(parts(parts.Count), 1) = "[", "index", "prop")
            Else
                res.SetValue "value", current
            End If
        Else
            If forAssign Then
                res.SetValue "container", progScope
                res.SetValue "key", node.GetValue("name")
                res.SetValue "kind", "scopeVar"
            Else
                res.SetValue "value", progScope.GetValue(node.GetValue("name"))
            End If
        End If
    Else
        ' Nested nodes (preferred)
        Select Case tp
            Case "Member"
                Dim baseRes As Map: Set baseRes = ResolvePath(node.GetValue("base"), progScope, forAssign)
                If forAssign Then
                    res.SetValue "container", baseRes("container")
                    res.SetValue "key", node.GetValue("prop")
                    res.SetValue "kind", "prop"
                    Dim pKey As String
                    Dim pKind As String
                    ' carry forward parent property/key info if present on the base resolution
                    If baseRes.Exists("key") Then
                        pKey = baseRes("key")
                        res.SetValue "parentKey", pKey
                    End If
                    If baseRes.Exists("kind") Then
                        pKind = baseRes("kind")
                        res.SetValue "parentKind", pKind
                    End If
                    res.SetValue "parentObj", baseRes
                Else
                    res.SetValue "value", EvalMemberNode(node, progScope)
                End If
            Case "Index"
                Dim baseRes2 As Map: Set baseRes2 = ResolvePath(node.GetValue("base"), progScope, forAssign)
                If forAssign Then
                    ' We need to preserve the parent container _and_ the parent property name (if any)
                    ' so that assignments to an indexed property (e.g. o.a[2]) can write back correctly.
                    res.SetValue "container", baseRes2("container")
                    res.SetValue "key", EvalExprNode(node.GetValue("index"), progScope)
                    res.SetValue "kind", "index"
                    ' carry forward parent property/key info if present on the base resolution
                    If baseRes2.Exists("key") Then res.SetValue "parentKey", baseRes2("key")
                    If baseRes2.Exists("kind") Then res.SetValue "parentKind", baseRes2("kind")
                    res.SetValue "parentObj", baseRes2
                Else
                    res.SetValue "value", EvalIndexNode(node, progScope)
                End If
        End Select
    End If
    Set ResolvePath = res
End Function

Private Function GetIndexedValue(baseVal As Variant, idxv As Variant, progScope As ScopeStack) As Variant
    Dim pos As Long: pos = CLng(idxv)
    Dim optionBase As Long: optionBase = progScope.GetValue("__option_base")
    If pos < optionBase Then err.Raise vbObjectError + 5001, "VM.GetIndexedValue", "Invalid index"
    If IsArray(baseVal) Then
        Dim lb As Long: lb = LBound(baseVal)
        Dim adjustedPos As Long: adjustedPos = lb + (pos - optionBase)
        If adjustedPos > UBound(baseVal) Then err.Raise vbObjectError + 5005, "VM.GetIndexedValue", "Index out of bounds"
        vAssignment GetIndexedValue, baseVal(adjustedPos)
    ElseIf TypeName(baseVal) = "Map" Then
        vAssignment GetIndexedValue, baseVal.GetValue(pos)
    Else
        err.Raise vbObjectError + 5006, "VM.GetIndexedValue", "Cannot index non-array/non-map"
    End If
End Function

Private Function ResolveLValue(node As Map, progScope As ScopeStack) As Map
    Set ResolveLValue = ResolvePath(node, progScope, True)
    If node.GetValue("type") = "Index" Then
        If node.GetValue("index").GetValue("type") <> "Literal" Then
            ResolveLValue.Add "computed", True ' Twist: flag for lazy
        End If
    End If
End Function

' ---------------------
' ExecIfNode: Evaluate condition, then execute proper block
' ---------------------
Private Function ExecIfNode(node As Map, progScope As ScopeStack) As String
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    If IsTruthy(EvalExprNode(condNode, progScope)) Then
        Dim thenStmts As Collection: Set thenStmts = node.GetValue("then")
        Dim si As Long
        For si = 1 To thenStmts.Count
            Dim ctrl As String: ctrl = ExecuteStmtNode(thenStmts(si), progScope)
            If ctrl <> "" Then ExecIfNode = ctrl: Exit Function
        Next si
        ExecIfNode = ""
        Exit Function
    End If
    Dim elseifConds As Collection: Set elseifConds = node.GetValue("elseif_conds")
    Dim elseifBlocks As Collection: Set elseifBlocks = node.GetValue("elseif_blocks")
    Dim idx As Long
    For idx = 1 To elseifConds.Count
        If IsTruthy(EvalExprNode(elseifConds(idx), progScope)) Then
            Dim bl As Collection: Set bl = elseifBlocks(idx)
            Dim si2 As Long
            For si2 = 1 To bl.Count
                Dim ctrl2 As String: ctrl2 = ExecuteStmtNode(bl(si2), progScope)
                If ctrl2 <> "" Then ExecIfNode = ctrl2: Exit Function
            Next si2
            ExecIfNode = ""
            Exit Function
        End If
    Next idx
    If node.GetValue("hasElse") Then
        Dim els As Collection: Set els = node.GetValue("else")
        Dim ee As Long
        For ee = 1 To els.Count
            Dim ctrl3 As String: ctrl3 = ExecuteStmtNode(els(ee), progScope)
            If ctrl3 <> "" Then ExecIfNode = ctrl3: Exit Function
        Next ee
    End If
    ExecIfNode = ""
End Function

' ---------------------
' ExecForNode
' ---------------------
Private Function ExecForNode(node As Map, progScope As ScopeStack) As String
    Dim initNode As Map: Set initNode = node.GetValue("init")
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    Dim stepNode As Map: Set stepNode = node.GetValue("step")
    Dim body As Collection: Set body = node.GetValue("body")
    Dim condOk As Boolean
    
    If Not initNode Is Nothing Then
        Dim initType As String
        initType = initNode.GetValue("type")
        Select Case initType
            Case "Assign", "Print", "If", "For", "While", "TryCatch", "Switch", "Return", "Break", "Continue", "ExprStmt"
                ' Already a statement node — execute directly so side-effects happen.
                ExecuteStmtNode initNode, progScope
            Case Else
                ' Expression node — wrap into ExprStmt for side-effect evaluation.
                ExecuteStmtNode MakeNodeExprStmt(initNode), progScope
        End Select
    End If

ForStart:
    condOk = True
    If Not condNode Is Nothing Then
        condOk = IsTruthy(EvalExprNode(condNode, progScope))
    End If
    If Not condOk Then GoTo ForEnd

    Dim s As Long
    For s = 1 To body.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(body(s), progScope)
        If ctrl = "BREAK" Then GoTo ForEnd
        If ctrl = "CONTINUE" Then Exit For
        If ctrl = "RETURN" Or ctrl = "ERR" Then ExecForNode = ctrl: Exit Function
    Next s

    If Not stepNode Is Nothing Then
        Dim stepType As String
        stepType = stepNode.GetValue("type")
        Select Case stepType
            Case "Assign", "Print", "If", "For", "While", "TryCatch", "Switch", "Return", "Break", "Continue", "ExprStmt"
                ExecuteStmtNode stepNode, progScope
            Case Else
                ExecuteStmtNode MakeNodeExprStmt(stepNode), progScope
        End Select
    End If
    GoTo ForStart

ForEnd:
    ExecForNode = ""
End Function

' Helper to wrap an expression node into an ExprStmt node
Private Function MakeNodeExprStmt(expr As Map) As Map
    Dim M As Map: Set M = MakeNode("ExprStmt")
    M.SetValue "expr", expr
    Set MakeNodeExprStmt = M
End Function

' ---------------------
' ExecWhileNode
' ---------------------
Private Function ExecWhileNode(node As Map, progScope As ScopeStack) As String
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    Dim body As Collection: Set body = node.GetValue("body")

WhileStart:
    If Not IsTruthy(EvalExprNode(condNode, progScope)) Then GoTo WhileEnd
    Dim i As Long
    For i = 1 To body.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(body(i), progScope)
        If ctrl = "BREAK" Then GoTo WhileEnd
        If ctrl = "CONTINUE" Then Exit For
        If ctrl = "RETURN" Or ctrl = "ERR" Then ExecWhileNode = ctrl: Exit Function
    Next i
    GoTo WhileStart

WhileEnd:
    ExecWhileNode = ""
End Function

' ---------------------
' ExecTryCatchNode
' ---------------------
Private Function ExecTryCatchNode(node As Map, progScope As ScopeStack) As String
    On Error GoTo TryErr
    Dim tryStmts As Collection: Set tryStmts = node.GetValue("try")
    Dim i As Long
    For i = 1 To tryStmts.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(tryStmts(i), progScope)
        If ctrl = "RETURN" Or ctrl = "ERR" Then
            ExecTryCatchNode = ctrl
            If ctrl = "ERR" Then GoTo TryErr
            Exit Function
        End If
    Next i
    ExecTryCatchNode = ""
    Exit Function

TryErr:
    err.Clear
    Dim catchStmts As Collection: Set catchStmts = node.GetValue("catch")
    If Not catchStmts Is Nothing Then
        Dim j As Long
        For j = 1 To catchStmts.Count
            Dim cctrl As String: cctrl = ExecuteStmtNode(catchStmts(j), progScope)
            If cctrl = "RETURN" Or cctrl = "ERR" Then ExecTryCatchNode = cctrl: Exit Function
        Next j
    End If
    ExecTryCatchNode = ""
End Function

' ---------------------
' ExecSwitchNode
' ---------------------
Private Function ExecSwitchNode(node As Map, progScope As ScopeStack) As String
    Dim switchVal As Variant: switchVal = EvalExprNode(node.GetValue("expr"), progScope)
    Dim cases As Collection: Set cases = node.GetValue("cases")
    Dim i As Long
    Dim match As Boolean
    For i = 1 To cases.Count
        Dim pair As Collection: Set pair = cases(i)
        Dim caseExpr As Map: Set caseExpr = pair(1)
        Dim blockStmts As Collection: Set blockStmts = pair(2)
        match = (EvalExprNode(caseExpr, progScope) = switchVal)
        If match Then
            Dim s As Long
            For s = 1 To blockStmts.Count
                Dim ctrl As String: ctrl = ExecuteStmtNode(blockStmts(s), progScope)
                If ctrl = "BREAK" Then ExecSwitchNode = "": Exit Function
                If ctrl = "RETURN" Or ctrl = "ERR" Then ExecSwitchNode = ctrl: Exit Function
            Next s
        End If
    Next i
    If Not match Then
        Dim defBlk As Collection: Set defBlk = node.GetValue("default")
        If Not defBlk Is Nothing Then
            Dim d As Long
            For d = 1 To defBlk.Count
                Dim ctrl2 As String: ctrl2 = ExecuteStmtNode(defBlk(d), progScope)
                If ctrl2 = "BREAK" Then ExecSwitchNode = "": Exit Function
                If ctrl2 = "RETURN" Or ctrl2 = "ERR" Then ExecSwitchNode = ctrl2: Exit Function
            Next d
        End If
    End If
    ExecSwitchNode = ""
End Function

Private Sub vAssignment(ByRef var As Variant, ByRef vValue As Variant)
    If IsObject(vValue) Then
        Set var = vValue
    Else
        var = vValue
    End If
End Sub
' ---------------------
' Expression evaluator: Evaluate Expr AST nodes to runtime values
' ---------------------
Private Function EvalExprNode(node As Map, progScope As ScopeStack) As Variant
    If node Is Nothing Then EvalExprNode = Empty: Exit Function
    Dim tp As String: tp = node.GetValue("type")
    Dim items As Collection
    Dim tmpResult As Variant
    Dim pi As Long
    Dim funcIdx As Long
    Dim baseExpr As Map
    
    Select Case tp
        Case "FuncLiteral", "AnonFunc"
            ' Create closure (capture env by reference for shared-write closures)
            Dim cparams As Collection: vAssignment cparams, node.GetValue("params")
            Dim cbody As Collection: vAssignment cbody, node.GetValue("body")
            Dim cmap As Map
            Set cmap = New Map
            Dim envCopy As ScopeStack
            cmap.Add "type", "Closure"
            cmap.SetValue "params", cparams
            cmap.SetValue "body", cbody
            ' capture current scope reference (shared-write)
            Set envCopy = New ScopeStack
            envCopy.LoadRawByRef progScope.RawByRef
            cmap.SetValue "env", envCopy
            vAssignment tmpResult, cmap
            GoTo exitfun
        Case "VBAexpr"
            ' Forced VBAexpression node (from @(...)). The node stores the raw VB expression string in "expr".
            Dim rawVB As String: rawVB = node.GetValue("expr")
            vAssignment tmpResult, EvalVBExpressionWithScope(rawVB, progScope)
            GoTo exitfun
        Case "Object"
            ' Build and return a Map containing the evaluated properties
            Set items = node.GetValue("items")
            Dim om As New Map
            Dim valNode As Map
            Dim pair As Collection
            Dim key As String
            For pi = 1 To items.Count
                Set pair = items(pi)
                key = CStr(pair(1))
                Set valNode = pair(2)
                om.SetValue key, EvalExprNode(valNode, progScope)
            Next pi
            ' Return Map object (as Variant holding the object)
            vAssignment tmpResult, om
            GoTo exitfun
        Case "Member"
            vAssignment tmpResult, EvalMemberNode(node, progScope)
            GoTo exitfun
        Case "Index"
            vAssignment tmpResult, EvalIndexNode(node, progScope)
            GoTo exitfun
        Case "Array"
            vAssignment tmpResult, EvalArrayNode(node, progScope)
            GoTo exitfun
        Case "Literal"
            vAssignment tmpResult, node.GetValue("value")
            GoTo exitfun
        Case "Variable"
            ' Robust variable resolution:
            '  - return actual value from scope (covers closures stored as Map AST nodes)
            '  - if scope has no value, fallback to named functions table (gFuncTable)
            '  - optional fallback to gFuncObjects registry
            Dim vname As String: vname = CStr(node.GetValue("name"))
            Dim vval As Variant
            vAssignment vval, progScope.GetValue(vname)

            ' If scope contains a non-empty value, return it — this covers closures
            ' stored as Map/AST nodes (FuncLiteral/Closure/etc.).
            If Not IsEmpty(vval) Then
                ' If it's a Map and looks like a function node, return as callable
                On Error Resume Next
                If TypeName(vval) = "Map" Then
                    Dim maybeType As Variant
                    maybeType = Empty
                    On Error Resume Next
                    maybeType = vval.GetValue("type")
                    On Error GoTo 0
                    If Not IsEmpty(maybeType) Then
                        Dim tt As String: tt = CStr(maybeType)
                        ' Common names for function-like AST nodes / closures:
                        If tt = "FuncLiteral" Or tt = "Function" Or tt = "Closure" Or tt = "AnonFunction" Then
                            vAssignment tmpResult, vval
                            GoTo exitfun
                        End If
                    End If
                End If
                ' Not necessarily a function-like Map — still return stored value.
                vAssignment tmpResult, vval
                GoTo exitfun
            End If

            ' Not in scope (or Empty). Fallback: named compiled function table.
            On Error Resume Next
            If GLOBALS_.gFuncTable.Exists(vname) Then
                Dim fIdxVal As Variant: fIdxVal = GLOBALS_.gFuncTable.GetValue(vname)
                On Error GoTo 0
                If Not IsEmpty(fIdxVal) Then
                    funcIdx = CLng(fIdxVal)

                    ' Build a Closure map with the shape CallClosure expects:
                    ' "type" = "Closure", "params" = Collection, "body" = Collection, "env" = ScopeStack
                    Dim closureMap As New Map
                    closureMap.Add "type", "Closure"

                    ' params: convert stored gFuncParams (likely an array) into a Collection
                    Dim paramsCol As Collection
                    Set paramsCol = New Collection
                    If GLOBALS_.gFuncParams.Exists(vname) Then
                        Dim paVar As Variant: paVar = GLOBALS_.gFuncParams.GetValue(vname)
                        If IsArray(paVar) Then
                            If ArrayIsInit(paVar) Then
                                For pi = LBound(paVar) To UBound(paVar)
                                    paramsCol.Add CStr(paVar(pi))
                                Next pi
                            Else
                                paramsCol.Add vbNullString
                            End If
                        ElseIf TypeName(paVar) = "Collection" Then
                            ' already a collection — copy it
                            Dim it As Variant
                            For Each it In paVar
                                paramsCol.Add it
                            Next it
                        End If
                    End If
                    closureMap.SetValue "params", paramsCol

                    ' body and env come from gPrograms(funcIdx)
                    Dim pinfo As Variant
                    On Error Resume Next
                    pinfo = GLOBALS_.gPrograms(funcIdx)
                    If err.Number <> 0 Then
                        err.Clear
                        ' fallback: no program info — return Empty
                        EvalExprNode = Empty
                        Exit Function
                    End If
                    On Error GoTo 0

                    ' pinfo layout: Array(name, stmtsCollection, rawScopeCollection)
                    Dim bodyStmts As Collection
                    Set bodyStmts = pinfo(1)
                    closureMap.SetValue "body", bodyStmts

                    ' env: create ScopeStack and LoadRaw with stored raw scope (so closure has env object)
                    Dim envScope As ScopeStack
                    Set envScope = New ScopeStack
                    envScope.LoadRawByRef progScope.RawByRef
                    Set pinfo(2) = envScope.RawByRef
                    closureMap.SetValue "env", envScope

                    ' optionally store a name/funcIdx for debugging
                    closureMap.SetValue "name", vname
                    closureMap.SetValue "funcIdx", funcIdx

                    vAssignment tmpResult, closureMap
                    GoTo exitfun
                End If
            End If
            On Error GoTo 0

            ' Not found — log and return Empty
            If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "VM: Variable '" & vname & "' is undefined or not callable (returned Empty)."
            vAssignment tmpResult, Empty
            GoTo exitfun
        Case "Call"
            ' Call can be either:
            '  - Call with "name" (string) and args (legacy)
            '  - Call with "callee" (an expression node) and args
            '       (new: allows variable holding closures)

            Dim fname As String
            Dim hasCalleeExpr As Boolean
            If node.Exists("name") Then
                fname = CStr(node.GetValue("name"))
            End If
            If fname = "" Then
                ' try to derive name from callee expression when callee is a simple Variable node
                If node.Exists("callee") Then
                    hasCalleeExpr = True
                    Dim calleeExpr As Map: Set calleeExpr = node.GetValue("callee")
                    If Not calleeExpr Is Nothing Then
                        If calleeExpr.GetValue("type") = "Variable" Then
                            fname = CStr(calleeExpr.GetValue("name"))
                        End If
                    End If
                End If
            End If
            ' builtin length function
            If fname = ".__len__" Then
                Dim argn As Collection: Set argn = node.GetValue("args")
                Dim av As Variant: vAssignment av, EvalExprNode(argn(1), progScope)
                If Not IsArray(av) Then
                    vAssignment tmpResult, 0
                Else
                    vAssignment tmpResult, UBound(av) - LBound(av) + 1
                End If
                GoTo exitfun
            End If

            Dim argsColl As Collection: Set argsColl = node.GetValue("args")
            Dim evaluated As Collection
            Set evaluated = New Collection
            Dim k As Long
            For k = 1 To argsColl.Count
                evaluated.Add EvalExprNode(argsColl(k), progScope)
            Next k

            If Not hasCalleeExpr Then
                ' named call (existing behavior + fallback to VBAexpressions)
                If GLOBALS_.gFuncTable.Exists(fname) Then
                    funcIdx = CLng(GLOBALS_.gFuncTable.GetValue(fname))
                    vAssignment tmpResult, CallFuncByIndex_AST(funcIdx, evaluated)
                End If
            Else
                ' dynamic callee: evaluate callee expression -> it must yield a closure map or call via VB
                Dim calleeVal As Variant
                Dim hasThisVal As Boolean: hasThisVal = False
                Dim thisVal As Variant
                ' If callee is a member or index expression, compute base as `this` for method call binding.
                If Not calleeExpr Is Nothing Then
                    Dim ct As String: ct = IIf(calleeExpr.Exists("type"), CStr(calleeExpr.GetValue("type")), "")
                    If ct = "Member" Or ct = "Index" Then
                        hasThisVal = True
                        Set baseExpr = calleeExpr.GetValue("base")
                        vAssignment thisVal, EvalExprNode(baseExpr, progScope)
                    End If
                End If
                vAssignment calleeVal, EvalExprNode(calleeExpr, progScope)
                If TypeName(calleeVal) = "Map" Then
                    Dim cm As Map: Set cm = calleeVal
                    If cm.GetValue("type") = "Closure" Then
                        If hasThisVal Then
                            vAssignment tmpResult, CallClosure(cm, evaluated, thisVal)
                        Else
                            vAssignment tmpResult, CallClosure(cm, evaluated)
                        End If
                    Else
                        ' not a closure -> fail gracefully
                        vAssignment tmpResult, Empty
                    End If
                Else
                    vAssignment tmpResult, Empty
                End If
            End If
            GoTo exitfun

        Case "Unary"
            Dim op As String: op = node.GetValue("op")
            Dim ev As Variant: ev = EvalExprNode(node.GetValue("expr"), progScope)
            If op = "!" Then
                vAssignment tmpResult, Not IsTruthy(ev)
            ElseIf op = "-" Then
                vAssignment tmpResult, -CDbl(ev)
            Else
                vAssignment tmpResult, ev
            End If
            GoTo exitfun
        Case "Ternary"
            Dim cnd As Variant: cnd = EvalExprNode(node.GetValue("cond"), progScope)
            If IsTruthy(cnd) Then
                vAssignment tmpResult, EvalExprNode(node.GetValue("trueExpr"), progScope)
            Else
                vAssignment tmpResult, EvalExprNode(node.GetValue("falseExpr"), progScope)
            End If
            GoTo exitfun
        Case "Binary"
            Dim lop As Variant: lop = EvalExprNode(node.GetValue("left"), progScope)
            Dim rop As Variant
            Dim op2 As String: op2 = node.GetValue("op")
            If op2 = "&&" Then
                If Not IsTruthy(lop) Then vAssignment tmpResult, False: GoTo exitfun
                vAssignment rop, EvalExprNode(node.GetValue("right"), progScope)
                vAssignment tmpResult, (IsTruthy(lop) And IsTruthy(rop))
                GoTo exitfun
            ElseIf op2 = "||" Then
                If IsTruthy(lop) Then vAssignment tmpResult, True: GoTo exitfun
                vAssignment rop, EvalExprNode(node.GetValue("right"), progScope)
                vAssignment tmpResult, (IsTruthy(lop) Or IsTruthy(rop))
                GoTo exitfun
            Else
                vAssignment rop, EvalExprNode(node.GetValue("right"), progScope)
                Select Case op2
                    Case "+"
                        vAssignment tmpResult, SafeAdd(lop, rop)
                    Case "-": vAssignment tmpResult, lop - rop
                    Case "*": vAssignment tmpResult, lop * rop
                    Case "/"
                        If rop = 0 Then err.Raise vbObjectError + 2001, "VM.EvalExprNode", "Division by zero" Else vAssignment tmpResult, lop / rop
                    Case "%": vAssignment tmpResult, lop Mod rop
                    Case "^": vAssignment tmpResult, lop ^ rop
                    Case "==", "=": vAssignment tmpResult, (lop = rop)
                    Case "!=": vAssignment tmpResult, (lop <> rop)
                    Case "<": vAssignment tmpResult, (lop < rop)
                    Case ">": vAssignment tmpResult, (lop > rop)
                    Case "<=": vAssignment tmpResult, (lop <= rop)
                    Case ">=": vAssignment tmpResult, (lop >= rop)
                    Case "<<": vAssignment tmpResult, lshift(lop, rop)
                    Case ">>": vAssignment tmpResult, rshift(lop, rop)
                    Case Else
                        vAssignment tmpResult, Empty
                End Select
                GoTo exitfun
            End If
    End Select

    vAssignment tmpResult, Empty
exitfun:
    vAssignment EvalExprNode, tmpResult
End Function

Private Function ReturnCollection(ByRef aColl As Variant) As Collection
    Set ReturnCollection = aColl
End Function
Private Function ArrayIsInit(aArray As Variant) As Boolean
    Dim ub As Long
    ArrayIsInit = True
    On Error GoTo err_Handler
    ub = UBound(aArray)
    Exit Function
err_Handler:
    err.Clear
    ArrayIsInit = False
End Function
' Call function program by index (AST). "args" is Collection of evaluated arg values.
Private Function CallFuncByIndex_AST(funcIdx As Long, args As Collection) As Variant
    Dim p As Variant: p = GLOBALS_.gPrograms(funcIdx)
    Dim rawScope As Collection: Set rawScope = p(2)
    Dim callScope As New ScopeStack
    Dim i As Long
    callScope.LoadRaw rawScope
    callScope.Push
    Dim fname As String: fname = p(0)
    ' set params from gFuncParams
    If GLOBALS_.gFuncParams.Exists(fname) Then
        Dim pa As Variant: pa = GLOBALS_.gFuncParams.GetValue(fname)
        For i = LBound(pa) To UBound(pa)
            If i - LBound(pa) + 1 <= args.Count Then
                callScope.SetLocalValue CStr(pa(i)), args(i - LBound(pa) + 1)
            Else
                callScope.SetLocalValue CStr(pa(i)), Empty
            End If
        Next i
    End If

    Dim stmts As Collection: Set stmts = p(1)
    For i = 1 To stmts.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(stmts(i), callScope)
        If ctrl = "RETURN" Then
            CallFuncByIndex_AST = callScope.GetValue("__return")
            callScope.Pop
            Exit Function
        ElseIf ctrl = "ERR" Then
            err.Raise vbObjectError + 3000, "VM.CallFunc", "Error during function execution"
        End If
    Next i
    CallFuncByIndex_AST = Empty
    callScope.Pop
End Function

' ---------------------
' Utilities adapted from your previous VM
' ---------------------
Private Function IsTruthy(v As Variant) As Boolean
    If IsObject(v) Then IsTruthy = Not v Is Nothing: Exit Function
    If IsNull(v) Then IsTruthy = False: Exit Function
    If IsEmpty(v) Then IsTruthy = False: Exit Function
    If VarType(v) = vbBoolean Then IsTruthy = CBool(v): Exit Function
    If IsNumeric(v) Then IsTruthy = (CDbl(v) <> 0): Exit Function
    If VarType(v) = vbString Then
        If IsBoolean(CStr(v)) Then IsTruthy = CBool(v) Else IsTruthy = (CStr(v) <> "")
        Exit Function
    End If
    IsTruthy = True
End Function

Private Function IsBoolean(ByRef expression As String) As Boolean
    IsBoolean = (LCase(expression) = "true")
    If Not IsBoolean Then IsBoolean = (LCase(expression) = "false")
End Function

Private Function SafeAdd(a As Variant, b As Variant) As Variant
    If IsNumeric(a) And IsNumeric(b) Then SafeAdd = a + b Else SafeAdd = CStr(a) & CStr(b)
End Function

Private Function lshift(a As Variant, b As Variant) As Variant 'a<<b
    If IsNumeric(a) And IsNumeric(b) Then
        lshift = Floor(Floor(a) * (2 ^ Abs(Floor(b))))
    Else
        Exit Function
    End If
End Function

Private Function rshift(a As Variant, b As Variant) As Variant 'a>>b
    If IsNumeric(a) And IsNumeric(b) Then
        rshift = Floor(Floor(a) / (2 ^ Abs(Floor(b))))
    Else
        Exit Function
    End If
End Function

Private Function Floor(ByRef value As Variant) As Long
    Dim tmpResult As Double
    tmpResult = CDbl(Fix(value))
    Floor = CLng(tmpResult + ((CDbl(value) <> tmpResult) And (CDbl(value) < 0)))
End Function

Private Function ValueToStringForPrint(v As Variant) As String
    Dim visited As New Collection
    ValueToStringForPrint = ValueToStringWithCtx(v, visited, 0)
End Function
' core recursive printer with context
Private Function ValueToStringWithCtx(v As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler

    ' Depth guard
    If depth > VTP_MAX_DEPTH Then
        ValueToStringWithCtx = "..."
        Exit Function
    End If
    ' Null / Empty
    If IsNull(v) Then
        ValueToStringWithCtx = "NULL": Exit Function
    End If
    If IsEmpty(v) Then
        ValueToStringWithCtx = "": Exit Function
    End If

    ' Scalars
    If VarType(v) = vbString Then
        ValueToStringWithCtx = CStr(v): Exit Function
    End If
    If VarType(v) = vbBoolean Then
        If CBool(v) Then ValueToStringWithCtx = "True" Else ValueToStringWithCtx = "False"
        Exit Function
    End If
    If IsNumeric(v) Then
        ValueToStringWithCtx = CStr(v): Exit Function
    End If

    ' Arrays (native VBA arrays)
    If IsArray(v) Then
        ValueToStringWithCtx = ArrayToString(v, visited, depth)
        Exit Function
    End If

    ' Objects
    If IsObject(v) Then
        Dim tn As String: tn = TypeName(v)
        Select Case tn
            Case "Map"
                ' cycle detection by object identity
                Dim i As Long
                For i = 1 To visited.Count
                    If visited(i) Is v Then
                        ValueToStringWithCtx = "[Circular]": Exit Function
                    End If
                Next i
                visited.Add v
                ValueToStringWithCtx = MapToString(v, visited, depth + 1)
                visited.Remove visited.Count
                Exit Function

            Case "Collection"
                ' cycle detection
                Dim j As Long
                For j = 1 To visited.Count
                    If visited(j) Is v Then
                        ValueToStringWithCtx = "[Circular]": Exit Function
                    End If
                Next j
                visited.Add v
                ValueToStringWithCtx = CollectionToString(v, visited, depth + 1)
                visited.Remove visited.Count
                Exit Function

            Case Else
                ' generic objects: try to call a ToString-like property if present, else fallback
                ValueToStringWithCtx = ObjectToString(v, visited, depth + 1)
                Exit Function
        End Select
    End If

    ' Fallback
    ValueToStringWithCtx = CStr(v)
    Exit Function

ErrHandler:
    ' On any unexpected error, return a safe placeholder and continue
    On Error Resume Next
    ValueToStringWithCtx = "[error: " & err.Number & "]"
    err.Clear
End Function

' Convert Map -> string
Private Function MapToString(M As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler
    Dim keyS As Collection: Set keyS = M.keyS
    Dim kcnt As Long: kcnt = keyS.Count

    If kcnt = 0 Then
        MapToString = "{}": Exit Function
    End If

    ' For small maps and shallow depth prefer inline representation
    If kcnt <= VTP_MAX_ITEMS_INLINE And depth <= 2 Then
        Dim parts() As String
        ReDim parts(1 To kcnt)
        Dim i As Long
        For i = 1 To kcnt
            Dim key As String: key = CStr(keyS(i))
            Dim val As Variant: val = M.GetValue(key)
            parts(i) = CStr(key) & ": " & ValueToStringWithCtx(val, visited, depth)
        Next i
        MapToString = "{ " & Join(parts, ", ") & " }"
        Exit Function
    End If

    ' Multi-line pretty print
    Dim sb As String
    Dim indent As String: indent = String(depth * 2, " ")
    Dim innerIndent As String: innerIndent = String((depth + 1) * 2, " ")
    sb = "{"
    Dim first As Boolean: first = True
    Dim kk As Variant
    For Each kk In keyS
        If Not first Then sb = sb & vbCrLf
        sb = sb & innerIndent & CStr(kk) & ": " & ValueToStringWithCtx(M.GetValue(CStr(kk)), visited, depth + 1)
        first = False
    Next kk
    sb = sb & vbCrLf & indent & "}"
    MapToString = sb
    Exit Function

ErrHandler:
    MapToString = "{<error>}"
    err.Clear
End Function

' Convert Collection -> string (treat as list)
Private Function CollectionToString(col As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler
    Dim n As Long: n = col.Count
    If n = 0 Then CollectionToString = "[]": Exit Function
    If n <= VTP_MAX_ITEMS_INLINE And depth <= 2 Then
        Dim tmp() As String: ReDim tmp(1 To n)
        Dim ii As Long
        For ii = 1 To n
            tmp(ii) = ValueToStringWithCtx(col(ii), visited, depth)
        Next ii
        CollectionToString = "[ " & Join(tmp, ", ") & " ]"
        Exit Function
    End If

    Dim sb As String: sb = "["
    Dim i As Long
    Dim indent As String: indent = String((depth + 1) * 2, " ")
    For i = 1 To n
        If i > 1 Then sb = sb & vbCrLf
        sb = sb & indent & ValueToStringWithCtx(col(i), visited, depth + 1)
    Next i
    sb = sb & vbCrLf & String(depth * 2, " ") & "]"
    CollectionToString = sb
    Exit Function

ErrHandler:
    CollectionToString = "[<error>]"
    err.Clear
End Function

' Convert native VBA array -> string
Private Function ArrayToString(arr As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler
    Dim lb As Long, ub As Long
    lb = LBound(arr): ub = UBound(arr)
    Dim n As Long: n = ub - lb + 1
    If n <= 0 Then ArrayToString = "[]": Exit Function
    If n <= VTP_MAX_ITEMS_INLINE And depth <= 2 Then
        Dim tmp() As String: ReDim tmp(1 To n)
        Dim i As Long
        For i = lb To ub
            tmp(i - lb + 1) = ValueToStringWithCtx(arr(i), visited, depth)
        Next i
        ArrayToString = "[ " & Join(tmp, ", ") & " ]"
        Exit Function
    End If

    Dim sb As String: sb = "["
    Dim indent As String: indent = String((depth + 1) * 2, " ")
    Dim ii As Long
    For ii = lb To ub
        If ii > lb Then sb = sb & vbCrLf
        sb = sb & indent & ValueToStringWithCtx(arr(ii), visited, depth + 1)
    Next ii
    sb = sb & vbCrLf & String(depth * 2, " ") & "]"
    ArrayToString = sb
    Exit Function

ErrHandler:
    ArrayToString = "[<error>]"
    err.Clear
End Function

' Generic object to string fallback:
' - If the object is a Map-like (has Keys and GetValue), will attempt to treat it as Map.
' - Else TypeName + simple to-string
Private Function ObjectToString(obj As Variant, visited As Collection, depth As Long) As String
    On Error GoTo Fallback
    Dim tn As String: tn = TypeName(obj)

    ' Attempt Map-like duck typing: presence of Keys and GetValue
    ' (use On Error to bail out if methods missing)
    Dim dummy As Collection
    Dim tryKeys As Collection
    On Error GoTo Fallback2
    Set tryKeys = obj.keyS
    ' if successful, treat as Map
    Dim i As Long
    For i = 1 To visited.Count
        If visited(i) Is obj Then
            ObjectToString = "[Circular]": Exit Function
        End If
    Next i
    visited.Add obj
    ObjectToString = MapToString(obj, visited, depth)
    visited.Remove visited.Count
    Exit Function

Fallback2:
    ' Not a Map-like object: try default string
    On Error GoTo Fallback
    ObjectToString = "<" & tn & ">"
    Exit Function

Fallback:
    ObjectToString = "<object>"
    err.Clear
End Function

' Utility to escape short strings for printing if you want (optional)
Private Function EscapeStringForPrint(s As String) As String
    ' currently returns s raw; adapt if you want quoted output
    EscapeStringForPrint = s
End Function
 ' VBAexpressions integration helpers
 ' ---------------------
 ' Evaluate a raw VBAexpressions expression string using a VBAexpressions instance,
 ' seeding it with the current ASF scope variables so VB expressions can reference ASF variables.
Private Function EvalVBExpressionWithScope(expr As String, progScope As ScopeStack) As Variant
     On Error GoTo ErrHandler
     With GLOBALS_.gExprEvaluator
         ' Create expression in evaluator
         .Create expr
    
         ' Inject variables from progScope (shadowing: global frames first, then locals)
         Dim frame As Variant
         Dim M As Map
         Dim keyCol As Collection
         Dim key As Variant
         For Each frame In progScope.Raw
             Set M = frame
             Set keyCol = M.keyS
             For Each key In keyCol
                 .VarValue(CStr(key)) = M.GetValue(CStr(key))
             Next key
         Next frame
    
         ' Evaluate
         .Eval
         If .ErrorType = 0 Then
             EvalVBExpressionWithScope = .result
         Else
             ' On error, raise to caller; the try/catch at Exec layer can handle it
             err.Raise vbObjectError + 7001, "VM.EvalVBExpressionWithScope", "VBAexpressions eval error"
         End If
     End With
     Exit Function
ErrHandler:
     ' convert to runtime log and return Empty
     If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "VBAexpr error: " & err.Description
     err.Clear
     EvalVBExpressionWithScope = Empty
End Function

 ' ---------------------
 ' Closure / function-value support (runtime helpers)
 ' ---------------------

 ' Create and call closures (closureMap is a Map with keys:
 '  "type" = "Closure", "params" = Collection, "body" = Collection (stmts), "env" = ScopeStack)
 Private Function CallClosure(closureMap As Map, evaluatedArgs As Collection, Optional thisVal As Variant) As Variant
     On Error GoTo ErrHandler
     Dim env As ScopeStack
     Set env = closureMap.GetValue("env") ' shared reference (shared-write semantics)

     ' push a new frame for this call
     env.Push
     Dim i As Long
     Dim pa As Variant
     Dim elm As Variant
     Dim fc As Boolean
     
     vAssignment pa, closureMap.GetValue("params")
     If IsObject(pa) Then
        fc = (Not pa Is Nothing)
     Else
        fc = Not IsEmpty(pa)
     End If
     If fc Then
         For Each elm In pa
             i = i + 1
             If i <= evaluatedArgs.Count Then
                 env.SetLocalValue CStr(elm), evaluatedArgs(i)
             Else
                 env.SetLocalValue CStr(elm), Empty
             End If
         Next elm
     End If

     ' set 'this' if provided
     If Not IsMissing(thisVal) Then
         env.SetLocalValue "this", thisVal
     End If

     ' execute body
     Dim stmts As Collection: Set stmts = closureMap.GetValue("body")
     Dim ctrl As String
     Dim stmtIdx As Long
     For stmtIdx = 1 To stmts.Count
         ctrl = ExecuteStmtNode(stmts(stmtIdx), env)
         If ctrl = "RETURN" Then
             vAssignment CallClosure, env.GetValue("__return")
             env.Pop
             Exit Function
         ElseIf ctrl = "ERR" Then
             err.Raise vbObjectError + 8001, "VM.CallClosure", "Error during closure execution"
         End If
     Next stmtIdx

     ' normal return -> Empty
     env.Pop
     CallClosure = Empty
     Exit Function
ErrHandler:
     If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "CallClosure error: " & err.Description
     err.Clear
     CallClosure = Empty
 End Function
 ' ----------------- LValue resolution and helpers -----------------

Private Sub HandleAssignment(left As Map, ByVal rval As Variant, progScope As ScopeStack)
    Dim lval As Map: Set lval = ResolveLValue(left, progScope)
    Dim key As Variant: vAssignment key, lval("key")
    If lval.Exists("computed") Then vAssignment key, EvalExprNode(left.GetValue("index"), progScope) ' Lazy compute
    Dim container As Variant: vAssignment container, lval("container")
    Select Case lval("kind")
        Case "scopeVar"
            progScope.SetValue CStr(key), rval
        Case "prop"
            If TypeName(container) <> "Map" Then
                Dim tValue As Variant
                vAssignment tValue, ResolveIndexProp(lval)
                tValue.SetValue CStr(key), rval
            Else
                container.SetValue CStr(key), rval
            End If
        Case "index"
            Dim pos As Long: pos = CLng(key)
            Dim optionBase As Long: optionBase = progScope.GetValue("__option_base")
            If pos < optionBase Then err.Raise vbObjectError + 5001, "VM.HandleAssignment", "Invalid index"
        
            ' If ResolvePath provided parentKey this means the array is stored under a property/variable:
            Dim parentKey As Variant
            If lval.Exists("parentKey") Then vAssignment parentKey, lval("parentKey") Else parentKey = Empty
        
            If Not IsEmpty(parentKey) Then
                ' parent container holds the array under parentKey (could be progScope or Map)
                Dim arrVal As Variant
                If TypeName(container) = "Map" Then
                    vAssignment arrVal, container.GetValue(CStr(parentKey))
                ElseIf TypeName(container) = "ScopeStack" Then
                    vAssignment arrVal, container.GetValue(CStr(parentKey))
                Else
                    ' fallback: maybe container itself is the array
                    vAssignment arrVal, container
                End If
        
                ' Ensure arrVal is an array we can index into (AssignToArrayValueInPlace will create/resize).
                Call AssignToArrayValueInPlace(arrVal, pos, rval)
        
                ' Write the updated array back into the parent container
                If TypeName(container) = "Map" Then
                    container.SetValue CStr(parentKey), arrVal
                ElseIf TypeName(container) = "ScopeStack" Then
                    container.SetValue CStr(parentKey), arrVal
                Else
                    ' if container itself was an array variable (rare), try to overwrite it:
                    container = arrVal
                End If
            Else
                ' container is the array itself
                If IsArray(container) Then
                    Call AssignToArrayValueInPlace(container, pos, rval)
                Else
                    err.Raise vbObjectError + 5002, "VM.HandleAssignment", "Cannot index non-array/non-map for set"
                End If
            End If
        Case "Member"
            Dim baseVal As Variant: vAssignment baseVal, EvalExprNode(left.GetValue("base"), progScope)
            If TypeName(baseVal) <> "Map" Then err.Raise vbObjectError + 5007, "VM.HandleAssignment", "Cannot set property on non-map"
            Dim propKey As String: propKey = IIf(left.Exists("prop"), "prop", "property")
            baseVal.SetValue left.GetValue(propKey), rval
    End Select
End Sub
Private Function ResolveIndexProp(ByRef lval) As Variant
    Dim baseVariable As String
    Dim pObject As Variant
    Dim keyS As New Collection
    Dim i As Long
    vAssignment pObject, lval("parentObj")
    Do While pObject.Exists("parentObj")
        keyS.Add pObject("key")
        vAssignment pObject, pObject("parentObj")
        If Not pObject.Exists("parentKey") Then
            Exit Do
        End If
    Loop
    baseVariable = pObject("key")
    Dim container As Variant: vAssignment container, lval("container")
    vAssignment pObject, container.GetValue(baseVariable)
    For i = keyS.Count To 2 Step -1
        vAssignment pObject, pObject.GetValue(keyS(i))
    Next
    vAssignment ResolveIndexProp, pObject(keyS(1))
End Function
 Sub AssignToArrayByName(arrVarName As String, idx As Long, newValue As Variant, progScope As ScopeStack)
     Dim arrVal As Variant: arrVal = progScope.GetValue(arrVarName)
     If IsEmpty(arrVal) Then
         Dim tmpA() As Variant
         ReDim tmpA(1 To 0)
         arrVal = tmpA
     End If
     Call AssignToArrayValueInPlace(arrVal, idx, newValue)
     progScope.SetValue arrVarName, arrVal
 End Sub

 Sub AssignToArrayValueInPlace(ByRef arrVal As Variant, idx As Long, newValue As Variant)
     If Not IsArray(arrVal) Then
         Dim na() As Variant
         ReDim na(1 To idx)
         na(idx) = newValue
         arrVal = na
         Exit Sub
     End If
     Dim lb As Long: lb = LBound(arrVal)
     Dim ub As Long: ub = UBound(arrVal)
     Dim pos As Long: pos = lb + idx - 1
     If pos < lb Then
         err.Raise vbObjectError + 9120, "VM.AssignToArrayValueInPlace", "Index out of bounds (below LBound)"
     End If
     If pos > ub Then
         ReDim Preserve arrVal(lb To pos)
     End If
     vAssignment arrVal(pos), newValue
 End Sub
'-----------------------------------------------------------------------
' GetElementMapFromIndexNode
' Given an Index AST node, resolve the array container and return the actual
' element Map stored at the index (creating a Map element if empty).
'-----------------------------------------------------------------------
Function GetElementMapFromIndexNode(indexNode As Map, progScope As ScopeStack) As Map
    Dim resolved As Variant
    resolved = ResolveLValue(indexNode, progScope)
    If IsEmpty(resolved) Then
        Set GetElementMapFromIndexNode = Nothing
        Exit Function
    End If
    Dim kind As String: kind = CStr(resolved(0))
    Select Case kind
    Case "arrayInScope"
        Dim arrName As String: arrName = CStr(resolved(1))
        Dim idx As Long: idx = CLng(resolved(2))
        Dim arrVal As Variant: arrVal = progScope.GetValue(arrName)
        If IsEmpty(arrVal) Then
            Dim tmpA() As Variant
            ReDim tmpA(1 To 0)
            arrVal = tmpA
        End If
        Dim lb As Long: lb = LBound(arrVal)
        Dim pos As Long: pos = lb + idx - 1
        If pos > UBound(arrVal) Then
            ' extend array so the slot exists
            ReDim Preserve arrVal(lb To pos)
        End If
        Dim elem As Variant: elem = arrVal(pos)
        If IsEmpty(elem) Then
            Dim nm As Map: Set nm = MakeNode("Map")
            arrVal(pos) = nm
            progScope.SetValue arrName, arrVal
            Set GetElementMapFromIndexNode = nm
            Exit Function
        ElseIf TypeName(elem) = "Map" Then
            Set GetElementMapFromIndexNode = elem
            Exit Function
        Else
            ' not a Map stored in the array slot
            err.Raise vbObjectError + 9021, "VM.GetElementMapFromIndexNode", "Array element is not an object"
        End If
    Case "arrayInMap"
        ' resolved shape: Array("arrayInMap", mapObj, index, propName)
        Dim mapObj As Map: Set mapObj = resolved(1)
        Dim theIdx As Long: theIdx = CLng(resolved(2))
        Dim propName As String: propName = CStr(resolved(3))
        Dim arrVal2 As Variant: arrVal2 = mapObj.GetValue(propName)
        If IsEmpty(arrVal2) Then
            Dim tmpb() As Variant
            ReDim tmpb(1 To 0)
            arrVal2 = tmpb
        End If
        Dim lb2 As Long: lb2 = LBound(arrVal2)
        Dim pos2 As Long: pos2 = lb2 + theIdx - 1
        If pos2 > UBound(arrVal2) Then
            ReDim Preserve arrVal2(lb2 To pos2)
        End If
        Dim elem2 As Variant: elem2 = arrVal2(pos2)
        If IsEmpty(elem2) Then
            Dim nm2 As Map: Set nm2 = MakeNode("Map")
            arrVal2(pos2) = nm2
            mapObj.SetValue propName, arrVal2
            Set GetElementMapFromIndexNode = nm2
            Exit Function
        ElseIf TypeName(elem2) = "Map" Then
            Set GetElementMapFromIndexNode = elem2
            Exit Function
        Else
            err.Raise vbObjectError + 9022, "VM.GetElementMapFromIndexNode", "Array element is not an object (map)"
        End If
    Case Else
        err.Raise vbObjectError + 9023, "VM.GetElementMapFromIndexNode", "Unsupported resolved kind for index -> " & kind
    End Select
End Function
 ' ----------------- end LValue helpers -----------------

Private Sub DoBinaryOp(op As String, stk As ASFstack)
    Dim b As Variant: b = stk.Pop()
    Dim a As Variant: a = stk.Pop()
    Dim res As Variant
    Select Case op
        Case "+"
            If IsNumeric(a) And IsNumeric(b) Then res = CDbl(a) + CDbl(b) Else res = CStr(a) & CStr(b)
        Case "-": res = CDbl(a) - CDbl(b)
        Case "*": res = CDbl(a) * CDbl(b)
        Case "/": If CDbl(b) = 0 Then res = Null Else res = CDbl(a) / CDbl(b)
        Case "%": res = CLng(a) Mod CLng(b)
        Case "^": res = a ^ b
        Case "==", "=": res = (a = b)
        Case "!": res = (Not IsTruthy(b))
        Case "!=": res = (a <> b)
        Case "<": res = (a < b)
        Case ">": res = (a > b)
        Case "<=": res = (a <= b)
        Case ">=": res = (a >= b)
        Case ">>": res = rshift(a, b)
        Case "<<": res = lshift(a, b)
        Case "&&": res = (IsTruthy(a) And IsTruthy(b))
        Case "||": res = (IsTruthy(a) Or IsTruthy(b))
        Case Else: res = Null
    End Select
    stk.Push res
End Sub

Private Sub BytecodePrintHelper(stk As ASFstack, nArgs As Long)
    If nArgs <= 0 Then
        If IsObject(GLOBALS_.gRuntimeLog) Then GLOBALS_.gRuntimeLog.Add "PRINT: "
        Debug.Print ""
        Exit Sub
    End If
    Dim tmp() As Variant: ReDim tmp(1 To nArgs)
    Dim i As Long
    For i = nArgs To 1 Step -1
        tmp(i) = stk.Pop()
    Next i
    Dim outS As String: outS = ""
    Dim visited__ As Collection
    Set visited__ = New Collection
    For i = 1 To nArgs
        If i = 1 Then
            outS = ValueToStringWithCtx(tmp(i), visited__, 0) & IIf(i < nArgs, " ", "")
        Else
            outS = outS & ", " & ValueToStringWithCtx(tmp(i), visited__, 0) & IIf(i < nArgs, " ", "")
        End If
    Next i
    If IsObject(GLOBALS_.gRuntimeLog) Then GLOBALS_.gRuntimeLog.Add "PRINT: " & outS
    If Not IsObject(GLOBALS_.gAppender) Then Debug.Print outS Else GLOBALS_.gAppender.Add outS
End Sub

' -------------------- compact bytecode runner --------------------
Public Sub RunCompactBytecodeProgram(progIdx As Long, progScope As ScopeStack, Optional verbose As Boolean = False)
    If Not IsObject(GLOBALS_.gProgramsBytecode) Then Exit Sub
    If progIdx < 1 Or progIdx > GLOBALS_.gProgramsBytecode.Count Then Exit Sub
    Dim bcMap As Map: Set bcMap = GLOBALS_.gProgramsBytecode(progIdx)
    If bcMap Is Nothing Then Exit Sub

    Dim codes() As Long: codes = bcMap.GetValue("codes")
    Dim args() As Variant: args = bcMap.GetValue("args")
    Dim symbols As Map: Set symbols = bcMap.GetValue("symbols")
    Dim jj As Long
    
    Dim codeLen As Long: codeLen = UBound(codes)
    Dim nSlots As Long: nSlots = 0
    If Not symbols Is Nothing Then
        If symbols.Exists("__slot_count") Then nSlots = CLng(symbols.GetValue("__slot_count"))
    End If
    Dim locals() As Variant
    If nSlots > 0 Then
        ReDim locals(1 To nSlots): Dim ii As Long
        For ii = 1 To nSlots
            locals(ii) = Empty
        Next ii
    End If
    Dim stk As ASFstack: Set stk = New ASFstack
    Dim pc As Long: pc = 1
    Dim fIdx As Long
    Dim operand As Variant
    Dim nArgs As Long
    Dim op As Long
    Dim localsVersion As Long: localsVersion = 0
    Dim lastSyncedVersion As Long: lastSyncedVersion = -1
    Dim idxNum As Long
    Dim thisVal As Variant
    Dim tmpMap As Map
    Dim lb2 As Long
    Dim ub2 As Long
    Dim cnt As Long
    Dim propLower As String
    Dim k As Variant
    Dim idxc As Long
    Dim idxn As Long
    Dim idxnA As Long
    Dim lb As Long
    Dim ub As Long
    Dim lbA As Long
    Dim ubA As Long
    Dim propNameVal As String
    Dim ai As Long
    Dim idc As Long
    Dim rootObj As Variant
    Dim idxn3 As Long
    Dim lb3 As Long
    Dim ub3 As Long
    Dim ai3 As Long
    Dim rootSlot As Long
    Dim pathColl As Collection
    Dim indexVal As Variant
    Dim parentContainer As Variant
    Dim parentContainerSet As Variant
    Dim parentObj As Variant
    Dim idxn2 As Long
    Dim ai2 As Long
    Dim idc2 As Long
    Dim parentElem As Variant
    Dim rootObjSet As Variant
    Dim lbV As Long
    Dim ubV As Long
    Dim lbL As Long
    Dim ubL As Long
    Dim lbB As Long
    Dim ubB As Long
    
    Do While pc <= codeLen
        op = CLng(codes(pc))
        vAssignment operand, args(pc)
        Select Case op
            Case OP_PUSH_CONST
                stk.Push operand
                pc = pc + 1

            Case OP_LOAD_FAST
                Dim sidx As Long: sidx = CLng(operand)
                Dim v As Variant
                v = Empty
            
                If nSlots > 0 Then
                    On Error Resume Next
                    If Not IsEmpty(locals) Then
                        If sidx >= LBound(locals) And sidx <= UBound(locals) Then
                            vAssignment v, locals(sidx)
                        End If
                    End If
                    On Error GoTo 0
                End If
            
                ' If locals slot is empty, try progScope (fallback) and cache into locals
                If (IsEmpty(v) Or IsNull(v)) Then
                    Dim symNameFL As String
                    symNameFL = ""
                    On Error Resume Next
                    If IsObject(symbols) Then
                        symNameFL = GetSymbolNameBySlot(symbols, sidx)
                    End If
                    On Error GoTo 0
            
                    If Len(symNameFL) > 0 Then
                        Dim fromScopeLoad As Variant
                        fromScopeLoad = Empty
                        On Error Resume Next
                        If IsObject(progScope) Then
                            vAssignment fromScopeLoad, progScope.GetValue(symNameFL)
                        End If
                        On Error GoTo 0
            
                        If Not (IsEmpty(fromScopeLoad) Or IsNull(fromScopeLoad)) Then
                            vAssignment v, fromScopeLoad
                            ' ensure locals array exists and can hold the slot, then cache
                            On Error Resume Next
                            If IsEmpty(locals) Then
                                Dim newL() As Variant
                                ReDim newL(1 To sidx)
                                Dim iiFL As Long
                                For iiFL = 1 To sidx
                                    newL(iiFL) = Empty
                                Next iiFL
                                vAssignment locals, newL
                            Else
                                If Not IsArray(locals) Then
                                    Dim tmpLocalArr() As Variant
                                    ReDim tmpLocalArr(1 To sidx)
                                    Dim tFL As Long
                                    For tFL = 1 To sidx
                                        tmpLocalArr(tFL) = Empty
                                    Next tFL
                                    vAssignment locals, tmpLocalArr
                                Else
                                    If sidx > UBound(locals) Then
                                        lbL = LBound(locals): ubL = UBound(locals)
                                        ReDim Preserve locals(lbL To sidx)
                                        Dim fillFL As Long
                                        For fillFL = ubL + 1 To sidx
                                            locals(fillFL) = Empty
                                        Next fillFL
                                    End If
                                End If
                            End If
                            On Error GoTo 0
            
                            On Error Resume Next
                            vAssignment locals(sidx), v
                            If err.Number <> 0 Then err.Clear
                            On Error GoTo 0
                        End If
                    End If
                End If
            
                stk.Push v
                pc = pc + 1

            Case OP_STORE_FAST
                Dim slotIdxSF As Long
                slotIdxSF = 0
                On Error Resume Next
                If IsNumeric(operand) Then slotIdxSF = CLng(operand)
                On Error GoTo 0
            
                Dim valSF As Variant
                valSF = Empty
                If stk.Count > 0 Then vAssignment valSF, stk.Pop()
            
                ' ensure locals exists and covers slotIdxSF
                On Error Resume Next
                If IsEmpty(locals) Then
                    Dim tmpL() As Variant
                    ReDim tmpL(1 To slotIdxSF)
                    Dim iiSF As Long
                    For iiSF = 1 To slotIdxSF
                        tmpL(iiSF) = Empty
                    Next iiSF
                    vAssignment locals, tmpL
                Else
                    If Not IsArray(locals) Then
                        Dim tmpA() As Variant
                        ReDim tmpA(1 To slotIdxSF)
                        Dim tx As Long
                        For tx = 1 To slotIdxSF
                            tmpA(tx) = Empty
                        Next tx
                        vAssignment locals, tmpA
                    Else
                        If slotIdxSF > UBound(locals) Then
                            Dim oldLB_SF As Long, oldUB_SF As Long
                            oldLB_SF = LBound(locals)
                            oldUB_SF = UBound(locals)
                            ReDim Preserve locals(oldLB_SF To slotIdxSF)
                            Dim kSF As Long
                            For kSF = oldUB_SF + 1 To slotIdxSF
                                locals(kSF) = Empty
                            Next kSF
                        End If
                    End If
                End If
                On Error GoTo 0
            
                ' Defensive copy for arrays: ensure we store a stable array value
                Dim finalVal As Variant
                vAssignment finalVal, valSF
                On Error Resume Next
                If IsArray(valSF) Then
                    If IsArrayAllocated(valSF) Then
                        lbV = LBound(valSF)
                        ubV = UBound(valSF)
                        Dim copyArr() As Variant
                        ReDim copyArr(lbV To ubV)
                        Dim ciSF As Long
                        For ciSF = lbV To ubV
                            copyArr(ciSF) = valSF(ciSF)
                        Next ciSF
                        finalVal = copyArr
                    Else
                        finalVal = Empty
                    End If
                End If
                If err.Number <> 0 Then err.Clear
                On Error GoTo 0
            
                ' assign into locals slot (direct)
                On Error Resume Next
                vAssignment locals(slotIdxSF), finalVal
                If err.Number <> 0 Then
                    err.Clear
                End If
                On Error GoTo 0
            
                ' If we have a symbol name for this slot, also write-through to progScope for consistency
                Dim symNameSF As String
                symNameSF = ""
                On Error Resume Next
                If IsObject(symbols) Then
                    symNameSF = GetSymbolNameBySlot(symbols, slotIdxSF)
                End If
                On Error GoTo 0
            
                If Len(symNameSF) > 0 Then
                    On Error Resume Next
                    If IsObject(progScope) Then progScope.SetLocalValue symNameSF, finalVal
                    If err.Number <> 0 Then err.Clear
                    On Error GoTo 0
                End If
            
                ' Verification (diagnostics)
                Dim ver As Variant
                ver = Empty
                On Error Resume Next
                If Not IsEmpty(locals) Then
                    If slotIdxSF >= LBound(locals) And slotIdxSF <= UBound(locals) Then
                        vAssignment ver, locals(slotIdxSF)
                    End If
                End If
                On Error GoTo 0
            
                If IsArray(valSF) Then
                    If (IsEmpty(ver) Or Not IsArray(ver)) Then
                        ' try an alternate wrapper layout and store that
                        On Error Resume Next
                        If IsArrayAllocated(valSF) Then
                            Dim olb As Long, oub As Long
                            olb = LBound(valSF): oub = UBound(valSF)
                            Dim wrapper() As Variant
                            ReDim wrapper(1 To (oub - olb + 1))
                            Dim wi As Long
                            For wi = 1 To (oub - olb + 1)
                                wrapper(wi) = valSF(olb + wi - 1)
                            Next wi
                            vAssignment locals(slotIdxSF), wrapper
                            If Len(symNameSF) > 0 Then
                                On Error Resume Next
                                If IsObject(progScope) Then progScope.SetLocalValue symNameSF, wrapper
                                If err.Number <> 0 Then err.Clear
                                On Error GoTo 0
                            End If
                        End If
                        If err.Number <> 0 Then err.Clear
                        On Error GoTo 0
                    End If
                End If
            
                pc = pc + 1
                
            Case OP_LOAD_NAME
                Dim vnm As Variant: vAssignment vnm, progScope.GetValue(CStr(operand))
                stk.Push vnm
                pc = pc + 1

            Case OP_STORE_NAME
                Dim vval As Variant: vAssignment vval, stk.Pop()
                progScope.SetLocalValue CStr(operand), vval
                pc = pc + 1
                
            Case OP_BINARY
                DoBinaryOp CStr(operand), stk
                pc = pc + 1

            Case OP_MAKE_ARRAY
                Dim nItemsMA As Long: nItemsMA = 0
                On Error Resume Next
                If IsNumeric(operand) Then nItemsMA = CLng(operand)
                On Error GoTo 0
            
                If nItemsMA < 0 Then nItemsMA = 0
                If stk.Count < nItemsMA Then
                    If IsObject(GLOBALS_.gRuntimeLog) Then GLOBALS_.gRuntimeLog.Add "VM: OP_MAKE_ARRAY - stack underflow. expected " & CStr(nItemsMA) & " items, have " & CStr(stk.Count)
                End If
            
                ' Build a *plain* VBA Variant-array for the items.
                Dim innerArr As Variant
                If nItemsMA = 0 Then
                    ' represent empty array as Empty (uninitialized). The INDEX_SET handler will allocate on write.
                    innerArr = Empty
                Else
                    Dim tmpInner() As Variant
                    ReDim tmpInner(1 To nItemsMA)
                    Dim j As Long
                    For j = nItemsMA To 1 Step -1
                        Dim valPop As Variant: valPop = Empty
                        If stk.Count > 0 Then vAssignment valPop, stk.Pop()
                        vAssignment tmpInner(j), valPop
                    Next j
                    vAssignment innerArr, tmpInner
                End If
            
                ' push the plain inner array (or Empty) onto stack
                stk.Push innerArr
                pc = pc + 1

            Case OP_PRINT
                nArgs = CLng(operand)
                BytecodePrintHelper stk, nArgs
                pc = pc + 1

            Case OP_POP
                Dim p_ As Variant: vAssignment p_, stk.Pop()
                pc = pc + 1

            Case OP_JUMP_IF_FALSE
                Dim condVal As Variant
                If stk.Count > 0 Then vAssignment condVal, stk.Pop() Else condVal = Empty
                Dim shouldJump As Boolean
                shouldJump = Not IsTruthy(condVal)
                If shouldJump Then
                    If IsNull(operand) Or IsEmpty(operand) Then
                        err.Raise vbObjectError + 512, "VM", "Invalid jump target (Null/Empty) for JUMP_IF_FALSE at pc=" & CStr(pc)
                    ElseIf Not IsNumeric(operand) Then
                        err.Raise vbObjectError + 513, "VM", "Invalid jump target (non-numeric) for JUMP_IF_FALSE at pc=" & CStr(pc)
                    Else
                        pc = CLng(operand)
                    End If
                Else
                    pc = pc + 1
                End If

            Case OP_JUMP
                If IsNull(operand) Or IsEmpty(operand) Then
                    err.Raise vbObjectError + 514, "VM", "Invalid jump target (Null/Empty) for JUMP at pc=" & CStr(pc)
                ElseIf Not IsNumeric(operand) Then
                    err.Raise vbObjectError + 515, "VM", "Invalid jump target (non-numeric) for JUMP at pc=" & CStr(pc)
                Else
                    pc = CLng(operand)
                End If

            Case OP_PUSH_AST_NODE
                Dim nodeObj As Variant: vAssignment nodeObj, operand
                If TypeName(nodeObj) = "Map" Then
                    Dim nodeObj_ As Map: Set nodeObj_ = nodeObj
                    Dim nType As String: nType = nodeObj_.GetValue("type")
                    If nType = "ExprStmt" Or nType = "Print" Or nType = "Assign" Then
                        If localsVersion <> lastSyncedVersion Then
                            SyncLocalsToScope locals, symbols, progScope
                            lastSyncedVersion = localsVersion
                        End If
                        ExecuteStmtNode nodeObj_, progScope
                        SyncScopeToLocals locals, symbols, progScope
                        localsVersion = localsVersion + 1
                        lastSyncedVersion = localsVersion
                    Else
                        If localsVersion <> lastSyncedVersion Then
                            SyncLocalsToScope locals, symbols, progScope
                            lastSyncedVersion = localsVersion
                        End If
                        stk.Push EvalExprNode(nodeObj_, progScope)
                        SyncScopeToLocals locals, symbols, progScope
                        localsVersion = localsVersion + 1
                        lastSyncedVersion = localsVersion
                    End If
                End If
                pc = pc + 1

            Case OP_LOAD_MEMBER_KEEP_BASE
                ' operand = Array(propName, rootSlot, pathColl, indexVal) or string
                Dim propName As String
                propName = ""
                Dim rootSlotLB As Long
                rootSlotLB = 0
                Dim pathCollLB As Collection
                Set pathCollLB = Nothing
                Dim indexValLB As Variant
                indexValLB = Empty

                ' Always pop the base (emitter pushes base before this op)
                Dim poppedBaseLB As Variant: poppedBaseLB = Empty
                If stk.Count > 0 Then vAssignment poppedBaseLB, stk.Pop()

                On Error Resume Next
                If IsArray(operand) Then
                    propName = CStr(operand(0))
                    rootSlotLB = CLng(operand(1))
                    Set pathCollLB = operand(2)
                    vAssignment indexValLB, operand(3)
                Else
                    propName = CStr(operand)
                End If
                On Error GoTo 0

                If rootSlotLB = 0 Then
                    If lastIndexBaseSlot > 0 Then rootSlotLB = lastIndexBaseSlot
                End If

                If rootSlotLB > 0 Then
                    Dim rootObjLB As Variant: rootObjLB = Empty
                    On Error Resume Next
                    If Not IsEmpty(locals) Then
                        If rootSlotLB >= LBound(locals) And rootSlotLB <= UBound(locals) Then
                            vAssignment rootObjLB, locals(rootSlotLB)
                        End If
                    End If
                    On Error GoTo 0

                    Dim parentContainerLB As Variant
                    vAssignment parentContainerLB, VM_TraversePathFromRoot(rootObjLB, pathCollLB)

                    Dim parentObjLB As Variant
                    vAssignment parentObjLB, parentContainerLB

                    If Not IsEmpty(indexValLB) Then
                        If TypeName(parentContainerLB) = "Map" Then
                            On Error Resume Next
                            vAssignment parentObjLB, parentContainerLB.GetValue(CStr(indexValLB))
                            If err.Number <> 0 Then err.Clear
                            On Error GoTo 0
                        ElseIf IsArray(parentContainerLB) Then
                            If IsArrayAllocated(parentContainerLB) Then
                                On Error Resume Next
                                Dim idxnLB As Long: idxnLB = CLng(indexValLB)
                                Dim lbLB As Long: lbLB = LBound(parentContainerLB)
                                Dim ubLB As Long: ubLB = UBound(parentContainerLB)
                                Dim aiLB As Long: aiLB = lbLB + idxnLB - 1
                                If aiLB >= lbLB And aiLB <= ubLB Then
                                    vAssignment parentObjLB, parentContainerLB(aiLB)
                                Else
                                    parentObjLB = Empty
                                End If
                                If err.Number <> 0 Then err.Clear
                                On Error GoTo 0
                            Else
                                parentObjLB = Empty
                            End If
                        ElseIf TypeName(parentContainerLB) = "Collection" Then
                            On Error Resume Next
                            Dim idcLB As Long: idcLB = CLng(indexValLB)
                            If idcLB >= 1 And idcLB <= parentContainerLB.Count Then
                                vAssignment parentObjLB, parentContainerLB(idcLB)
                            Else
                                parentObjLB = Empty
                            End If
                            If err.Number <> 0 Then err.Clear
                            On Error GoTo 0
                        Else
                            parentObjLB = Empty
                        End If
                    End If

                    ' Array special-case for property names like "length" / "__len__"
                    Dim resolvedValLB As Variant: resolvedValLB = Empty
                    If IsArray(parentObjLB) Then
                        If LCase$(propName) = "length" Or propName = "__len__" Then
                            If IsArrayAllocated(parentObjLB) Then
                                resolvedValLB = CLng(UBound(parentObjLB) - LBound(parentObjLB) + 1)
                            Else
                                resolvedValLB = 0
                            End If
                        Else
                            vAssignment resolvedValLB, VM_GetPropertyValue(parentObjLB, propName)
                        End If
                    Else
                        vAssignment resolvedValLB, VM_GetPropertyValue(parentObjLB, propName)
                    End If

                    stk.Push parentObjLB
                    stk.Push resolvedValLB

                    lastIndexBaseSlot = 0
                    lastIndexBaseName = ""
                    pc = pc + 1
                    Exit Sub
                End If

                ' Fallback: resolve using popped base
                Dim rvLB As Variant
                If IsArray(poppedBaseLB) Then
                    If LCase$(propName) = "length" Or propName = "__len__" Then
                        If IsArrayAllocated(poppedBaseLB) Then
                            rvLB = CLng(UBound(poppedBaseLB) - LBound(poppedBaseLB) + 1)
                        Else
                            rvLB = 0
                        End If
                    Else
                        vAssignment rvLB, VM_GetPropertyValue(poppedBaseLB, propName)
                    End If
                Else
                    vAssignment rvLB, VM_GetPropertyValue(poppedBaseLB, propName)
                End If

                stk.Push poppedBaseLB
                stk.Push rvLB

                lastIndexBaseSlot = 0
                lastIndexBaseName = ""
                pc = pc + 1

            Case OP_MEMBER_OF_VALUE
                Dim propNameV As String: propNameV = ""
                Dim rootSlotV As Long: rootSlotV = 0
                Dim pathCollV As Collection
                Set pathCollV = Nothing
                Dim indexValV As Variant: indexValV = Empty
            
                On Error Resume Next
                If IsArray(operand) Then
                    propNameV = CStr(operand(0))
                    rootSlotV = CLng(operand(1))
                    Set pathCollV = operand(2)
                    vAssignment indexValV, operand(3)
                Else
                    propNameV = CStr(operand)
                End If
                On Error GoTo 0
            
                ' try consuming a popped base value if emitter pushed it
                Dim poppedValV As Variant: poppedValV = Empty
                If stk.Count > 0 Then vAssignment poppedValV, stk.Pop()
            
                Dim outValV As Variant: vAssignment outValV, VM_GetPropertyValue(poppedValV, propNameV)
            
                ' if not found and we have metadata, reconstruct from rootSlot + index
                If (IsEmpty(outValV) Or IsNull(outValV)) Then
                    If rootSlotV = 0 Then
                        If lastIndexBaseSlot > 0 Then rootSlotV = lastIndexBaseSlot
                    End If
                End If
            
                If rootSlotV > 0 Then
                    Dim rootObjV As Variant: rootObjV = Empty
                    On Error Resume Next
                    If Not IsEmpty(locals) Then
                        If rootSlotV >= LBound(locals) And rootSlotV <= UBound(locals) Then
                            vAssignment rootObjV, locals(rootSlotV)
                        End If
                    End If
                    On Error GoTo 0
            
                    ' traverse path
                    Dim parentContainerV As Variant
                    vAssignment parentContainerV, VM_TraversePathFromRoot(rootObjV, pathCollV)
            
                    Dim parentObjV As Variant: parentObjV = Empty
            
                    If Not IsEmpty(indexValV) Then
                        If IsArray(parentContainerV) Then
                            If IsArrayAllocated(parentContainerV) Then
                                Dim idxnV As Long: idxnV = CLng(indexValV)
                                lbV = LBound(parentContainerV)
                                ubV = UBound(parentContainerV)
                                Dim posV As Long: posV = lbV + idxnV - 1
                                If posV >= lbV And posV <= ubV Then
                                    vAssignment parentObjV, parentContainerV(posV)
                                Else
                                    parentObjV = Empty
                                End If
                            Else
                                parentObjV = Empty
                            End If
                        ElseIf TypeName(parentContainerV) = "Map" Then
                            On Error Resume Next
                            vAssignment parentObjV, parentContainerV.GetValue(CStr(indexValV))
                            If err.Number <> 0 Then err.Clear
                            On Error GoTo 0
                        End If
                    End If
            
                    Dim fallbackValV As Variant
                    If IsArray(parentObjV) Then
                        If LCase$(propNameV) = "length" Or propNameV = "__len__" Then
                            If IsArrayAllocated(parentObjV) Then
                                fallbackValV = CLng(UBound(parentObjV) - LBound(parentObjV) + 1)
                            Else
                                fallbackValV = 0
                            End If
                        Else
                            vAssignment fallbackValV, VM_GetPropertyValue(parentObjV, propNameV)
                        End If
                    Else
                        vAssignment fallbackValV, VM_GetPropertyValue(parentObjV, propNameV)
                    End If
                    If Not (IsEmpty(fallbackValV) Or IsNull(fallbackValV)) Then vAssignment outValV, fallbackValV
            
                    lastIndexBaseSlot = 0
                    lastIndexBaseName = ""
                End If
            
                stk.Push outValV
                pc = pc + 1

                ' -----------------------
                ' OP_LOAD_MEMBER_FROM_VALUE_KEEP_BASE (robust + deferred member support)
                ' operand = Array(propName, rootSlot, pathColl, indexVal) or plain string
                ' Pushes: parent/base then methodVal (or deferred marker if indexVal empty)
                ' -----------------------
                Case OP_LOAD_MEMBER_FROM_VALUE_KEEP_BASE
                    propNameVal = ""
                    rootSlot = 0
                    Set pathColl = Nothing
                    indexVal = Empty
                
                    If IsArray(operand) Then
                        On Error Resume Next
                        propNameVal = CStr(operand(0))
                        rootSlot = CLng(operand(1))
                        Set pathColl = operand(2)
                        indexVal = operand(3)
                        On Error GoTo 0
                    Else
                        propNameVal = CStr(operand)
                    End If
                
                    ' Try to pop a base if emitter left it on stack (prefer explicit base)
                    Dim valObjLocal As Variant: valObjLocal = Empty
                    Dim topCandidate As Variant: topCandidate = Empty
                    Dim poppedBaseUsed As Boolean: poppedBaseUsed = False
                
                    If stk.Count > 0 Then
                        On Error Resume Next
                        vAssignment topCandidate, stk.Item(stk.Count)
                        If err.Number <> 0 Then err.Clear
                        On Error GoTo 0
                    End If
                
                    If Not IsEmpty(topCandidate) Then
                        If IsArray(topCandidate) Or TypeName(topCandidate) = "Map" Or TypeName(topCandidate) = "Collection" Then
                            vAssignment valObjLocal, stk.Pop()
                            poppedBaseUsed = True
                        Else
                            poppedBaseUsed = False
                        End If
                    End If
                
                    ' If we didn't pop a base, try reconstructing parentContainer via rootSlot
                    Dim parentContainerLocal As Variant: parentContainerLocal = Empty
                    If Not poppedBaseUsed Then
                        If rootSlot = 0 Then
                            If lastIndexBaseSlot > 0 Then rootSlot = lastIndexBaseSlot
                        End If
                        If rootSlot > 0 Then
                            Dim rootObjLocal As Variant: rootObjLocal = Empty
                            On Error Resume Next
                            If Not IsEmpty(locals) Then
                                If rootSlot >= LBound(locals) And rootSlot <= UBound(locals) Then
                                    vAssignment rootObjLocal, locals(rootSlot)
                                End If
                            End If
                            On Error GoTo 0
                            parentContainerLocal = VM_TraversePathFromRoot(rootObjLocal, pathColl)
                            valObjLocal = parentContainerLocal
                        Else
                            valObjLocal = Empty
                        End If
                    End If
                
                    ' If we have an explicit indexVal, pick the element now and resolve method
                    If Not IsEmpty(indexVal) Then
                        Dim parentElemLocal As Variant: parentElemLocal = valObjLocal
                        If Not IsEmpty(parentElemLocal) Then
                            If TypeName(parentElemLocal) = "Map" Then
                                On Error Resume Next
                                parentElemLocal = parentElemLocal.GetValue(CStr(indexVal))
                                If err.Number <> 0 Then err.Clear
                                On Error GoTo 0
                            ElseIf IsArray(parentElemLocal) Then
                                If IsArrayAllocated(parentElemLocal) Then
                                    Dim idxnL As Long: idxnL = CLng(indexVal)
                                    lbL = LBound(parentElemLocal)
                                    ubL = UBound(parentElemLocal)
                                    Dim aiL As Long: aiL = lbL + idxnL - 1
                                    If aiL >= lbL And aiL <= ubL Then
                                        vAssignment parentElemLocal, parentElemLocal(aiL)
                                    Else
                                        parentElemLocal = Empty
                                    End If
                                Else
                                    parentElemLocal = Empty
                                End If
                            ElseIf TypeName(parentElemLocal) = "Collection" Then
                                On Error Resume Next
                                Dim idcL As Long: idcL = CLng(indexVal)
                                If idcL >= 1 And idcL <= parentElemLocal.Count Then
                                    vAssignment parentElemLocal, parentElemLocal(idcL)
                                Else
                                    parentElemLocal = Empty
                                End If
                                If err.Number <> 0 Then err.Clear
                                On Error GoTo 0
                            End If
                        End If
                        ' resolved method now against the element
                        Dim resolvedMethodNow As Variant
                        resolvedMethodNow = VM_GetPropertyValue(parentElemLocal, propNameVal)
                        stk.Push parentElemLocal
                        stk.Push resolvedMethodNow
                
                        ' clear transient metadata
                        lastIndexBaseSlot = 0
                        lastIndexBaseName = ""
                        pc = pc + 1
                        Exit Sub
                    End If
                
                    ' -----------------------
                    ' Defer resolution: push parent container (base) then a marker with propName.
                    ' Later OP_INDEX_GET will produce the element; OP_CALL (member-call) will detect
                    ' the marker and resolve the property on the element at call-time.
                    ' -----------------------
                    ' If valObjLocal is Empty we still push Empty so stack shape is preserved.
                    stk.Push valObjLocal
                
                    ' Build deferred marker: a small 0-based array with a tag and the property
                    Dim deferredMarker As Variant
                    deferredMarker = Array("__DEFERRED_MEMBER__", propNameVal, rootSlot, pathColl)
                
                    stk.Push deferredMarker
                
                    ' consume transient metadata so fallback logic doesn't leak
                    lastIndexBaseSlot = 0
                    lastIndexBaseName = ""
                
                    pc = pc + 1

            Case OP_MEMBER_SET
                ' operand: Array(propName, rootSlot, pathColl, indexVal) or string
                Dim propNameSet As String
                propNameSet = ""
                Dim rootSlotSet As Long
                rootSlotSet = 0
                Dim pathCollSet As Collection
                Set pathCollSet = Nothing
                Dim indexValSet As Variant
                indexValSet = Empty
            
                On Error Resume Next
                If IsArray(operand) Then
                    propNameSet = CStr(operand(0))
                    rootSlotSet = CLng(operand(1))
                    Set pathCollSet = operand(2)
                    vAssignment indexValSet, operand(3)
                Else
                    propNameSet = CStr(operand)
                End If
                On Error GoTo 0
            
                ' pop value then base (emitter pushed base then RHS)
                Dim valSet As Variant
                valSet = Empty
                Dim baseSet As Variant
                baseSet = Empty
            
                If stk.Count > 0 Then
                    vAssignment valSet, stk.Pop()
                End If
                If stk.Count > 0 Then
                    vAssignment baseSet, stk.Pop()
                End If
            
                If rootSlotSet = 0 Then
                    If lastIndexBaseSlot > 0 Then rootSlotSet = lastIndexBaseSlot
                End If
            
                If rootSlotSet > 0 Then
                    rootObjSet = Empty
                    On Error Resume Next
                    If rootSlotSet >= LBound(locals) And rootSlotSet <= UBound(locals) Then
                        vAssignment rootObjSet, locals(rootSlotSet)
                    End If
                    On Error GoTo 0
            
                    vAssignment parentContainerSet, VM_TraversePathFromRoot(rootObjSet, pathCollSet)
            
                    parentElem = Empty
                    Dim foundIndex As Long
                    foundIndex = -1
                    Dim foundKey As Variant
                    foundKey = Empty
            
                    If Not IsEmpty(indexValSet) Then
                        If TypeName(parentContainerSet) = "Map" Then
                            On Error Resume Next
                            vAssignment parentElem, parentContainerSet.GetValue(CStr(indexValSet))
                            If err.Number <> 0 Then err.Clear
                            On Error GoTo 0
                            foundKey = CStr(indexValSet)
                        ElseIf IsArray(parentContainerSet) Then
                            If IsArrayAllocated(parentContainerSet) Then
                                On Error Resume Next
                                Dim idxnX As Long
                                idxnX = CLng(indexValSet)
                                Dim lbX As Long
                                lbX = LBound(parentContainerSet)
                                Dim ubX As Long
                                ubX = UBound(parentContainerSet)
                                Dim aiX As Long
                                aiX = lbX + idxnX - 1
                                If aiX >= lbX And aiX <= ubX Then
                                    vAssignment parentElem, parentContainerSet(aiX)
                                    foundIndex = aiX
                                Else
                                    parentElem = Empty
                                End If
                                If err.Number <> 0 Then
                                    err.Clear
                                End If
                                On Error GoTo 0
                            End If
                        ElseIf TypeName(parentContainerSet) = "Collection" Then
                            On Error Resume Next
                            Dim idcX As Long
                            idcX = CLng(indexValSet)
                            If idcX >= 1 And idcX <= parentContainerSet.Count Then
                                vAssignment parentElem, parentContainerSet(idcX)
                            Else
                                parentElem = Empty
                            End If
                            If err.Number <> 0 Then
                                err.Clear
                            End If
                            On Error GoTo 0
                        End If
                    Else
                        ' primitive-only search fallback (safe)
                        parentElem = Empty
                        If TypeName(parentContainerSet) = "Map" Then
                            Dim kk3 As Variant
                            On Error Resume Next
                            For Each kk3 In parentContainerSet.keyS
                                Dim cand3 As Variant
                                vAssignment cand3, parentContainerSet.GetValue(kk3)
                                If Not IsObject(cand3) And Not IsObject(baseSet) Then
                                    If Not IsError(cand3) And Not IsError(baseSet) Then
                                        If VarType(cand3) = VarType(baseSet) Then
                                            If cand3 = baseSet Then
                                                vAssignment parentElem, cand3
                                                foundKey = kk3
                                                Exit For
                                            End If
                                        End If
                                    End If
                                End If
                            Next kk3
                            If err.Number <> 0 Then
                                err.Clear
                            End If
                            On Error GoTo 0
                        ElseIf IsArray(parentContainerSet) Then
                            If IsArrayAllocated(parentContainerSet) Then
                                Dim i5 As Long
                                Dim lb5 As Long
                                Dim ub5 As Long
                                lb5 = LBound(parentContainerSet)
                                ub5 = UBound(parentContainerSet)
                                For i5 = lb5 To ub5
                                    Dim cand5 As Variant
                                    vAssignment cand5, parentContainerSet(i5)
                                    If Not IsObject(cand5) And Not IsObject(baseSet) Then
                                        On Error Resume Next
                                        If cand5 = baseSet Then
                                            parentElem = parentContainerSet(i5)
                                            foundIndex = i5
                                            Exit For
                                        End If
                                        If err.Number <> 0 Then
                                            err.Clear
                                        End If
                                        On Error GoTo 0
                                    End If
                                Next i5
                            End If
                        End If
                    End If
            
                    If Not IsEmpty(parentElem) Then
                        VM_SetProperty parentElem, propNameSet, valSet
            
                        If TypeName(parentContainerSet) = "Map" Then
                            If Not IsEmpty(foundKey) Then
                                On Error Resume Next
                                If parentContainerSet.Exists(CStr(foundKey)) Then
                                    parentContainerSet.SetValue CStr(foundKey), parentElem
                                Else
                                    parentContainerSet.Add CStr(foundKey), parentElem
                                End If
                                If err.Number <> 0 Then
                                    err.Clear
                                End If
                                On Error GoTo 0
                            Else
                                If Not IsEmpty(indexValSet) Then
                                    On Error Resume Next
                                    parentContainerSet.SetValue CStr(indexValSet), parentElem
                                    If err.Number <> 0 Then
                                        err.Clear
                                    End If
                                    On Error GoTo 0
                                End If
                            End If
                        ElseIf IsArray(parentContainerSet) Then
                            If foundIndex <> -1 Then
                                If IsArrayAllocated(parentContainerSet) Then
                                    vAssignment parentContainerSet(foundIndex), parentElem
                                End If
                            Else
                                If Not IsEmpty(indexValSet) Then
                                    Dim idxnWrite As Long
                                    idxnWrite = CLng(indexValSet)
                                    Dim lbW As Long
                                    lbW = LBound(parentContainerSet)
                                    Dim ubW As Long
                                    ubW = UBound(parentContainerSet)
                                    Dim aiW As Long
                                    aiW = lbW + idxnWrite - 1
                                    If aiW >= lbW And aiW <= ubW Then
                                        vAssignment parentContainerSet(aiW), parentElem
                                    End If
                                End If
                            End If
                        ElseIf TypeName(parentContainerSet) = "Collection" Then
                            If IsObject(GLOBALS_.gRuntimeLog) Then
                                GLOBALS_.gRuntimeLog.Add "VM: COLLECTION write-back not supported for MEMBER_SET"
                            End If
                        End If
            
                        If rootSlotSet > 0 Then
                            On Error Resume Next
                            vAssignment locals(rootSlotSet), rootObjSet
                            If err.Number <> 0 Then
                                err.Clear
                            End If
                            On Error GoTo 0
                        End If
            
                        lastIndexBaseSlot = 0
                        lastIndexBaseName = ""
                        pc = pc + 1
                        Exit Sub
                    Else
                        If TypeName(parentContainerSet) = "Map" Then
                            On Error Resume Next
                            If Not IsEmpty(indexValSet) Then
                                If parentContainerSet.Exists(CStr(indexValSet)) Then
                                    parentContainerSet.SetValue CStr(indexValSet), valSet
                                Else
                                    parentContainerSet.Add CStr(indexValSet), valSet
                                End If
                            Else
                                VM_SetProperty parentContainerSet, propNameSet, valSet
                            End If
                            If err.Number <> 0 Then
                                err.Clear
                            End If
                            On Error GoTo 0
            
                            lastIndexBaseSlot = 0
                            lastIndexBaseName = ""
                            pc = pc + 1
                            Exit Sub
                        End If
                    End If
                End If
            
                ' fallback: try set on popped baseSet directly
                If TypeName(baseSet) = "Map" Then
                    On Error Resume Next
                    If baseSet.Exists(propNameSet) Then
                        baseSet.SetValue propNameSet, valSet
                    Else
                        baseSet.Add propNameSet, valSet
                    End If
                    If err.Number <> 0 Then
                        err.Clear
                    End If
                    On Error GoTo 0
                ElseIf IsArray(baseSet) Then
                    If IsNumeric(propNameSet) Then
                        If IsArrayAllocated(baseSet) Then
                            idxn3 = CLng(propNameSet)
                            lb3 = LBound(baseSet)
                            ub3 = UBound(baseSet)
                            ai3 = lb3 + idxn3 - 1
                            If ai3 >= lb3 And ai3 <= ub3 Then
                                vAssignment baseSet(ai3), valSet
                            Else
                                If IsObject(GLOBALS_.gRuntimeLog) Then
                                    GLOBALS_.gRuntimeLog.Add "VM: INDEX_SET OOB idx=" & CStr(idxn3)
                                End If
                            End If
                        End If
                    End If
                ElseIf IsObject(baseSet) Then
                    On Error Resume Next
                    baseSet.SetValue propNameSet, valSet
                    If err.Number <> 0 Then
                        err.Clear
                    End If
                    On Error GoTo 0
                Else
                    If IsObject(GLOBALS_.gRuntimeLog) Then
                        GLOBALS_.gRuntimeLog.Add "VM: MEMBER_SET fallback - unable to assign property"
                    End If
                End If
            
                lastIndexBaseSlot = 0
                lastIndexBaseName = ""
                pc = pc + 1

            Case OP_INDEX_GET
                Dim indexOpSlot As Long: indexOpSlot = 0
                Dim indexOpName As String: indexOpName = ""
                On Error Resume Next
                If IsArray(operand) Then
                    Dim lbO As Long, ubO As Long
                    lbO = LBound(operand): ubO = UBound(operand)
                    If (ubO - lbO + 1) >= 2 Then
                        indexOpSlot = CLng(operand(0))
                        indexOpName = CStr(operand(1))
                    End If
                End If
                On Error GoTo 0
            
                Dim idxVal As Variant: idxVal = Empty
                Dim baseVal As Variant: baseVal = Empty
                ' emitter pushes base then index -> pop index then base
                If stk.Count > 0 Then vAssignment idxVal, stk.Pop()
                If stk.Count > 0 Then vAssignment baseVal, stk.Pop()
            
                Dim resolved As Variant: resolved = Empty
            
                ' If base is Empty but operand points to a rootSlot, consult locals(rootSlot)
                If (IsEmpty(baseVal) Or IsNull(baseVal)) And indexOpSlot > 0 Then
                    Dim rootCandidate As Variant: rootCandidate = Empty
                    On Error Resume Next
                    If Not IsEmpty(locals) Then
                        If indexOpSlot >= LBound(locals) And indexOpSlot <= UBound(locals) Then
                            vAssignment rootCandidate, locals(indexOpSlot)
                        End If
                    End If
                    On Error GoTo 0
                    baseVal = rootCandidate
                End If
            
                If IsArray(baseVal) Then
                    If IsNumeric(idxVal) Then
                        Dim ixn As Long
                        ixn = CLng(idxVal)
                        On Error Resume Next
                        lbA = LBound(baseVal)
                        ubA = UBound(baseVal)
                        If err.Number <> 0 Then
                            err.Clear
                            lbA = 1: ubA = 0
                        End If
                        On Error GoTo 0
                        ai = lbA + ixn - 1
                        If lbA <= ubA And ai >= lbA And ai <= ubA Then
                            vAssignment resolved, baseVal(ai)
                        Else
                            resolved = Empty
                            If IsObject(GLOBALS_.gRuntimeLog) Then GLOBALS_.gRuntimeLog.Add "VM: INDEX_GET OOB idx=" & CStr(ixn) & " lb=" & CStr(lbA) & " ub=" & CStr(ubA)
                        End If
                    Else
                        resolved = Empty
                    End If
            
                ElseIf TypeName(baseVal) = "Map" Then
                    On Error Resume Next
                    resolved = baseVal.GetValue(CStr(idxVal))
                    If err.Number <> 0 Then err.Clear
                    On Error GoTo 0
            
                ElseIf TypeName(baseVal) = "Collection" Then
                    If IsNumeric(idxVal) Then
                        Dim ic As Long: ic = CLng(idxVal)
                        If ic >= 1 And ic <= baseVal.Count Then
                            vAssignment resolved, baseVal(ic)
                        Else
                            resolved = Empty
                        End If
                    Else
                        resolved = Empty
                    End If
            
                Else
                    resolved = Empty
                End If
            
                stk.Push resolved
                ' --- ensure deferred-member marker ends above the element (so stack becomes: ..., thisVal, calleeVal) ---
                If stk.Count >= 2 Then
                    Dim maybeMarker As Variant
                    On Error Resume Next
                    vAssignment maybeMarker, stk.Item(stk.Count - 1)   ' second-from-top
                    If err.Number = 0 Then
                        If IsArray(maybeMarker) Then
                            If UBound(maybeMarker) >= 0 Then
                                If CStr(maybeMarker(0)) = "__DEFERRED_MEMBER__" Then
                                    ' swap top and second-top: make element go below the marker
                                    Dim topElem As Variant
                                    Dim markerVal As Variant
                                    vAssignment topElem, stk.Pop()      ' resolved (element)
                                    vAssignment markerVal, stk.Pop()    ' deferred marker
                                    stk.Push topElem
                                    stk.Push markerVal
                                End If
                            End If
                        End If
                    End If
                    On Error GoTo 0
                End If


                ' preserve operand-slot transient info for possible subsequent member operations
                If indexOpSlot > 0 Or Len(indexOpName) > 0 Then
                    lastIndexBaseSlot = indexOpSlot
                    lastIndexBaseName = indexOpName
                Else
                    lastIndexBaseSlot = 0
                    lastIndexBaseName = ""
                End If
            
                pc = pc + 1
            Case OP_INDEX_SET
                rootSlot = 0
                Dim rootName As String: rootName = ""
                On Error Resume Next
                If IsArray(operand) Then
                    Dim lbO2 As Long, ubO2 As Long
                    lbO2 = LBound(operand): ubO2 = UBound(operand)
                    If (ubO2 - lbO2 + 1) >= 2 Then
                        rootSlot = CLng(operand(0))
                        rootName = CStr(operand(1))
                    End If
                End If
                On Error GoTo 0
            
                If stk.Count < 3 Then
                    If IsObject(GLOBALS_.gRuntimeLog) Then GLOBALS_.gRuntimeLog.Add "VM: INDEX_SET stack underflow: need 3, have " & CStr(stk.Count)
                    pc = pc + 1
                    GoTo ExitIdxSet
                End If
            
                Dim rhsVal As Variant: rhsVal = Empty
                Dim idxValS As Variant: idxValS = Empty
                Dim baseContainer As Variant: baseContainer = Empty
            
                vAssignment rhsVal, stk.Pop()
                vAssignment idxValS, stk.Pop()
                vAssignment baseContainer, stk.Pop()
            
                Dim idxnS As Long
                If IsNumeric(idxValS) Then idxnS = CLng(idxValS) Else idxnS = -1
            
                ' If emitter provided a rootSlot, operate *on locals(rootSlot)* as the authoritative root
                If rootSlot > 0 Then
                    rootObjSet = Empty
                    On Error Resume Next
                    If Not IsEmpty(locals) Then
                        If rootSlot >= LBound(locals) And rootSlot <= UBound(locals) Then
                            vAssignment rootObjSet, locals(rootSlot)
                        End If
                    End If
                    On Error GoTo 0
            
                    ' If the root is not an array, allocate a new plain array of required size
                    vAssignment parentContainerSet, rootObjSet
            
                    If idxnS <= 0 Then
                        ' nothing to do for non-numeric index
                        pc = pc + 1
                        GoTo ExitIdxSet
                    End If
            
                    If Not IsArray(parentContainerSet) Then
                        ' allocate 1..idxnS plain array
                        Dim newArr() As Variant
                        ReDim newArr(1 To idxnS)
                        For ii = 1 To idxnS: newArr(ii) = Empty: Next ii
                        parentContainerSet = newArr
                    Else
                        ' ensure capacity
                        Dim lbPS As Long, ubPS As Long
                        On Error Resume Next
                        lbPS = LBound(parentContainerSet)
                        ubPS = UBound(parentContainerSet)
                        If err.Number <> 0 Then
                            err.Clear
                            lbPS = 1: ubPS = 0
                        End If
                        On Error GoTo 0
                        If idxnS > ubPS Then
                            ' expand to idxnS
                            Dim oldUB As Long: oldUB = ubPS
                            If oldUB < lbPS Then oldUB = lbPS - 1
                            Dim newArr2() As Variant
                            ReDim newArr2(lbPS To idxnS)
                            Dim kk As Long
                            For kk = lbPS To oldUB
                                vAssignment newArr2(kk), parentContainerSet(kk)
                            Next kk
                            For kk = oldUB + 1 To idxnS
                                newArr2(kk) = Empty
                            Next kk
                            vAssignment parentContainerSet, newArr2
                        End If
                    End If
            
                    ' finally set element at idxnS (respecting 1-based indexing we've chosen)
                    On Error Resume Next
                    vAssignment parentContainerSet(LBound(parentContainerSet) + idxnS - 1), rhsVal
                    If err.Number <> 0 Then
                        ' fallback: attempt direct 1-based set
                        err.Clear
                        vAssignment parentContainerSet(idxnS), rhsVal
                    End If
                    On Error GoTo 0
            
                    ' write-back into locals(rootSlot)
                    On Error Resume Next
                    vAssignment locals(rootSlot), parentContainerSet
                    If err.Number <> 0 Then err.Clear
                    On Error GoTo 0
            
                    lastIndexBaseSlot = 0
                    lastIndexBaseName = ""
                    pc = pc + 1
                    GoTo ExitIdxSet
                End If
            
                ' If no rootSlot: use the popped baseContainer (it may be an array, Map, etc)
                If IsArray(baseContainer) Then
                    If IsNumeric(idxValS) Then
                        idxn2 = CLng(idxValS)
                        On Error Resume Next
                        lbB = LBound(baseContainer)
                        ubB = UBound(baseContainer)
                        If err.Number <> 0 Then
                            err.Clear
                            lbB = 1: ubB = 0
                        End If
                        On Error GoTo 0
                        If Not (lbB <= ubB And (lbB + idxn2 - 1) >= lbB And (lbB + idxn2 - 1) <= ubB) Then
                            ' expand to fit
                            Dim oldUB2 As Long: oldUB2 = ubB
                            Dim newArr3() As Variant
                            ReDim newArr3(lbB To idxn2)
                            Dim zz As Long
                            For zz = lbB To oldUB2
                                vAssignment newArr3(zz), baseContainer(zz)
                            Next zz
                            For zz = oldUB2 + 1 To idxn2
                                newArr3(zz) = Empty
                            Next zz
                            vAssignment baseContainer, newArr3
                        End If
                        On Error Resume Next
                        vAssignment baseContainer(lbB + idxn2 - 1), rhsVal
                        If err.Number <> 0 Then
                            err.Clear
                            If idxn2 >= 1 And idxn2 <= UBound(baseContainer) Then vAssignment baseContainer(idxn2), rhsVal
                        End If
                        On Error GoTo 0
                    End If
                    ' Note: since this was not a rootSlot, we are mutating a temporary baseContainer (no write-back to locals)
                    ' This behavior mirrors typical semantics: if base was an expression result, mutated result is not stored back.
                    pc = pc + 1
                    GoTo ExitIdxSet
                ElseIf TypeName(baseContainer) = "Map" Then
                    On Error Resume Next
                    baseContainer.SetValue CStr(idxValS), rhsVal
                    If err.Number <> 0 Then err.Clear
                    On Error GoTo 0
                    pc = pc + 1
                    GoTo ExitIdxSet
                Else
                    If IsObject(GLOBALS_.gRuntimeLog) Then GLOBALS_.gRuntimeLog.Add "VM: INDEX_SET - unsupported base type: " & TypeName(baseContainer)
                    pc = pc + 1
                    GoTo ExitIdxSet
                End If
            
ExitIdxSet:

            Case OP_CALL_FUNC
                Dim opCallArr As Variant: vAssignment opCallArr, operand
                fIdx = CLng(opCallArr(0))
                Dim nArgsC As Long: nArgsC = CLng(opCallArr(1))
                Dim aTemp As New Collection, aii As Long
                For aii = nArgsC To 1 Step -1
                    aTemp.Add stk.Pop()
                Next aii
                Dim argsForCall As New Collection
                For aii = aTemp.Count To 1 Step -1
                    argsForCall.Add aTemp(aii)
                Next aii
                Dim resultFunc As Variant: vAssignment resultFunc, CallFuncByIndex_AST(fIdx, argsForCall)
                stk.Push resultFunc
                pc = pc + 1

            Case OP_CALL_FUNC_WITH_THIS
                Dim opCF As Variant: vAssignment opCF, operand
                Dim fIdx2 As Long: fIdx2 = CLng(opCF(0))
                Dim nAC As Long: nAC = CLng(opCF(1))
                Dim tcol As New Collection
                For jj = nAC To 1 Step -1
                    tcol.Add stk.Pop()
                Next jj
                Dim argsL As New Collection
                For jj = tcol.Count To 1 Step -1
                    argsL.Add tcol(jj)
                Next jj
                vAssignment thisVal, stk.Pop()
                Dim finalArgs As New Collection
                finalArgs.Add thisVal
                For jj = 1 To argsL.Count
                    finalArgs.Add argsL(jj)
                Next jj
                Dim r2 As Variant: vAssignment r2, CallFuncByIndex_AST(fIdx2, finalArgs)
                stk.Push r2
                pc = pc + 1

            Case OP_CALL
                nArgs = 0
                Dim callASTNode As Variant: callASTNode = Empty
                Dim isMemberCall As Boolean: isMemberCall = False
            
                On Error Resume Next
                If Not IsEmpty(operand) And IsArray(operand) Then
                    If UBound(operand) >= 0 Then nArgs = CLng(operand(0))
                    If UBound(operand) >= 1 Then vAssignment callASTNode, operand(1)
                    If UBound(operand) >= 2 Then isMemberCall = CBool(operand(2))
                ElseIf IsNumeric(operand) Then
                    nArgs = CLng(operand)
                Else
                    nArgs = 0
                End If
                On Error GoTo 0
            
                ' 1) Pop args from stack in reverse to build a collection in call order
                Dim argsCol As New Collection
                For ai = nArgs To 1 Step -1
                    If stk.Count > 0 Then
                        argsCol.Add stk.Pop()
                    Else
                        argsCol.Add Empty
                    End If
                Next ai
            
                ' 2) Pop callee (in your contract this will typically be the propName string)
                Dim calleeVal As Variant: calleeVal = Empty
                If stk.Count > 0 Then vAssignment calleeVal, stk.Pop() Else calleeVal = Empty
            
                ' 3) If member call, emitter left base under callee -> pop base
                thisVal = Empty
                If isMemberCall Then
                    If stk.Count > 0 Then
                        vAssignment thisVal, stk.Pop()
                    Else
                        thisVal = Empty
                    End If
                End If
                ' Deferred-member resolution (calleeVal might be our deferred marker)
                On Error Resume Next
                If isMemberCall Then
                    If Not IsEmpty(calleeVal) Then
                        If IsArray(calleeVal) Then
                            If UBound(calleeVal) >= 0 Then
                                If CStr(calleeVal(1)) = "__DEFERRED_MEMBER__" Then
                                    Dim deferredPropName As String: deferredPropName = ""
                                    If UBound(calleeVal) >= 1 Then deferredPropName = CStr(calleeVal(2))
                                    ' Resolve the method/property on thisVal now that element is available
                                    Dim resolvedMethod As Variant
                                    resolvedMethod = VM_GetPropertyValue(thisVal, deferredPropName)
                                    calleeVal = resolvedMethod
                                End If
                            End If
                        End If
                    End If
                End If
                On Error GoTo 0


                ' 4) Dispatch call (compiled functions, closures, or fallback to evaluating AST)
                Dim callResult As Variant: callResult = Empty
                Dim didCall As Boolean: didCall = False
            
                ' If calleeVal is a string name that maps to compiled function (call by name)
                If Not IsEmpty(calleeVal) Then
                    If VarType(calleeVal) = vbString Then
                        Dim cname As String: cname = CStr(calleeVal)
                        On Error Resume Next
                        If IsObject(GLOBALS_.gFuncTable) Then
                            If GLOBALS_.gFuncTable.Exists(cname) Then
                                fIdx = GLOBALS_.gFuncTable.GetValue(cname)
                                If Not IsEmpty(fIdx) Then
                                    On Error Resume Next
                                    vAssignment callResult, CallFuncByIndex_AST(CLng(fIdx), argsCol)
                                    If err.Number = 0 Then
                                        didCall = True
                                    Else
                                        err.Clear
                                    End If
                                End If
                            End If
                        End If
                        On Error GoTo 0
                    End If
                End If
            
                ' If calleeVal is closure Map
                If Not didCall Then
                    If IsObject(calleeVal) Then
                        On Error Resume Next
                        If calleeVal.Exists("params") Or calleeVal.Exists("body") Then
                            vAssignment tmpMap, calleeVal
                            vAssignment callResult, CallClosure(tmpMap, argsCol, thisVal)
                            If err.Number = 0 Then
                                didCall = True
                                err.Clear
                            Else
                                err.Clear
                            End If
                        End If
                        On Error GoTo 0
                    End If
                End If
            
                ' Fallback: evaluate call AST if provided
                If Not didCall Then
                    If Not IsEmpty(callASTNode) Then
                        ' Ensure progScope reflects current locals[] before calling EvalExprNode
                        If localsVersion <> lastSyncedVersion Then
                            SyncLocalsToScope locals, symbols, progScope
                            lastSyncedVersion = localsVersion
                        End If
                        vAssignment tmpMap, callASTNode
                        vAssignment callResult, EvalExprNode(tmpMap, progScope)
                        didCall = True
                        ' After EvalExprNode may have mutated scope, copy back into locals[]
                        SyncScopeToLocals locals, symbols, progScope
                        localsVersion = localsVersion + 1
                        lastSyncedVersion = localsVersion
                    Else
                        callResult = Empty
                        didCall = True
                    End If
                End If
            
                stk.Push callResult
                pc = pc + 1

            Case OP_RETURN
                Dim rvv As Variant: rvv = Empty
                If stk.Count > 0 Then vAssignment rvv, stk.Pop()
                progScope.SetValue "__return", rvv
                Exit Do

            Case Else
                pc = pc + 1
        End Select
    Loop
End Sub


' --- Helpers to synchronize locals() (slot array) with progScope using symbols map ---

' Sync locals -> progScope: set each symbol name in the ScopeStack from locals(slot)
Private Sub SyncLocalsToScope(locals() As Variant, symbols As Map, progScope As ScopeStack)
    If Not IsObject(symbols) Then Exit Sub
    If progScope Is Nothing Then Exit Sub
    On Error Resume Next
    Dim i As Long
    Dim key As String
    Dim sidx As Long
    
    ' assume Map exposes a Keys collection via "Keys" or iterate by For Each key In symbols
    For i = 0 To symbols.Count - 1
        key = symbols.key(i)
        If key <> "__slot_count" Then
            sidx = CLng(symbols.GetValue(key))
            If sidx >= LBound(locals) And sidx <= UBound(locals) Then
                progScope.SetLocalValue key, locals(sidx)
            End If
        End If
    Next i
    On Error GoTo 0
End Sub

' Sync progScope -> locals: copy values from progScope into locals array for each slot
Private Sub SyncScopeToLocals(locals() As Variant, symbols As Map, progScope As ScopeStack)
    If Not IsObject(symbols) Then Exit Sub
    If progScope Is Nothing Then Exit Sub
    On Error Resume Next
    Dim i As Long
    Dim key As String
    Dim sidx As Long
    
    For i = 0 To symbols.Count - 1
        key = symbols.key(i)
        If key <> "__slot_count" Then
            sidx = CLng(symbols.GetValue(key))
            If sidx >= LBound(locals) And sidx <= UBound(locals) Then
                locals(sidx) = progScope.GetValue(key)
            End If
        End If
    Next i
    On Error GoTo 0
End Sub
' -------------------------
' Helper: safely check if a Variant array is allocated
' -------------------------
Private Function IsArrayAllocated(arr As Variant) As Boolean
    On Error Resume Next
    If Not IsArray(arr) Then
        IsArrayAllocated = False
        Exit Function
    End If
    If UBound(arr) < 1 Then
        IsArrayAllocated = False
        Exit Function
    End If
    Dim cap As Variant
    cap = arr(2)
    If IsError(cap) Then
        IsArrayAllocated = False
    ElseIf Not IsNumeric(cap) Then
        IsArrayAllocated = False
    Else
        If CLng(cap) >= 0 Then IsArrayAllocated = True Else IsArrayAllocated = False
    End If
    On Error GoTo 0
End Function

' -------------------------
' Helper: ensure an array Variant can hold idx (1-based logical index),
' autosize/grow as needed using optionBase param, and set value there.
' After call arr is updated (ByRef).
' -------------------------
Private Sub EnsureArrayCapacityAndSet(ByRef arr As Variant, ByVal idx As Long, ByVal value As Variant, ByVal optionBase As Long)
    Dim wasAllocated As Boolean
    wasAllocated = False
    If IsArray(arr) Then
        wasAllocated = IsArrayAllocated(arr)
    End If

    If Not wasAllocated Then
        Dim currentLB As Long
        currentLB = optionBase
        Dim requiredActualIndex As Long
        requiredActualIndex = currentLB + idx - 1
        Dim newArr As Variant
        ReDim newArr(currentLB To requiredActualIndex)
        vAssignment newArr(requiredActualIndex), value
        vAssignment arr, newArr
        Exit Sub
    End If

    Dim currentLB2 As Long
    Dim currentUB2 As Long
    currentLB2 = LBound(arr)
    currentUB2 = UBound(arr)
    Dim requiredIdxActual As Long
    requiredIdxActual = currentLB2 + idx - 1

    If requiredIdxActual < currentLB2 Then
        Dim newLB As Long
        newLB = requiredIdxActual
        Dim newUB As Long
        newUB = currentUB2
        Dim tmp As Variant
        ReDim tmp(newLB To newUB)
        Dim i As Long
        For i = currentLB2 To currentUB2
            vAssignment tmp(i), arr(i)
        Next i
        vAssignment tmp(requiredIdxActual), value
        vAssignment arr, tmp
        Exit Sub
    ElseIf requiredIdxActual > currentUB2 Then
        ReDim Preserve arr(currentLB2 To requiredIdxActual)
        vAssignment arr(requiredIdxActual), value
        Exit Sub
    Else
        vAssignment arr(requiredIdxActual), value
        Exit Sub
    End If
End Sub

' -------------------------
' Helper: set element into container and write-back into locals if rootSlot provided
' -------------------------
Private Sub SetArrayElementBySlot(ByRef parentContainer As Variant, ByVal rootSlot As Long, _
                                  ByVal idx As Long, ByVal value As Variant, ByVal optionBase As Long, _
                                  ByRef locals As Variant)
    EnsureArrayCapacityAndSet parentContainer, idx, value, optionBase

    If rootSlot > 0 Then
        On Error Resume Next
        If Not IsEmpty(locals) Then
            If rootSlot >= LBound(locals) And rootSlot <= UBound(locals) Then
                vAssignment locals(rootSlot), parentContainer
            End If
        End If
        If err.Number <> 0 Then
            err.Clear
        End If
        On Error GoTo 0
    End If
End Sub

' -------------------------
' Array-with-meta helpers
' Internal layout (1-based):
'  index 1 -> name (String)  ("" if unknown)
'  index 2 -> capacity (Long) (-1 means UNALLOCATED)
'  index 3.. -> actual elements; element i (logical 1-based) stored at pos (2 + i)
' -------------------------

' Create a new array variant with meta and optionally initial items
Private Function CreateArrayWithMeta(initialCount As Long) As Variant
    Dim arr As Variant
    Dim totalSlots As Long
    If initialCount <= 0 Then
        totalSlots = 2 ' only meta entries
        ReDim arr(1 To totalSlots)
        ' meta: name empty, capacity = -1 (unallocated)
        arr(1) = ""          ' name
        arr(2) = -1          ' capacity = -1 means unallocated
    Else
        totalSlots = 2 + initialCount
        ReDim arr(1 To totalSlots)
        arr(1) = ""          ' name
        arr(2) = CLng(initialCount)  ' capacity = initialCount
        Dim i As Long
        For i = 1 To initialCount
            ' initialize element slots to Empty
            vAssignment arr(2 + i), Empty
        Next i
    End If
    CreateArrayWithMeta = arr
End Function

' Check whether a variant is our array-with-meta and whether it's allocated (capacity != -1)
Private Function IsArrayMetaAllocated(v As Variant) As Boolean
    On Error Resume Next
    If Not IsArray(v) Then
        IsArrayMetaAllocated = False
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim lb As Long
    Dim ub As Long
    lb = LBound(v)
    ub = UBound(v)
    If (ub - lb + 1) < 2 Then
        ' too small to be meta array
        IsArrayMetaAllocated = False
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim capV As Variant
    capV = v(2)
    If IsNumeric(capV) Then
        If CLng(capV) = -1 Then
            IsArrayMetaAllocated = False
        Else
            IsArrayMetaAllocated = True
        End If
    Else
        IsArrayMetaAllocated = False
    End If
    On Error GoTo 0
End Function

' Read capacity (number of logical elements) ; returns -1 if unallocated or not meta
Private Function GetArrayMetaCapacity(arr As Variant) As Long
    On Error Resume Next
    If Not IsArray(arr) Then
        GetArrayMetaCapacity = -1
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim lb As Long
    Dim ub As Long
    lb = LBound(arr)
    ub = UBound(arr)
    If (ub - lb + 1) < 2 Then
        GetArrayMetaCapacity = -1
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim capV As Variant
    capV = arr(2)
    If Not IsNumeric(capV) Then
        GetArrayMetaCapacity = -1
    Else
        GetArrayMetaCapacity = CLng(capV)
    End If
    On Error GoTo 0
End Function

' Get element: returns Empty if unallocated or OOB
Private Function GetArrayMetaElement(arr As Variant, logicalIndex As Long) As Variant
    Dim outv As Variant
    outv = Empty
    On Error Resume Next
    If Not IsArray(arr) Then
        GetArrayMetaElement = Empty
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim cap As Long
    cap = GetArrayMetaCapacity(arr)
    If cap = -1 Then
        ' unallocated
        GetArrayMetaElement = Empty
        Exit Function
    End If
    If logicalIndex < 1 Or logicalIndex > cap Then
        GetArrayMetaElement = Empty
        Exit Function
    End If
    Dim actualPos As Long
    actualPos = 2 + logicalIndex
    vAssignment outv, arr(actualPos)
    GetArrayMetaElement = outv
    On Error GoTo 0
End Function

' Ensure capacity and set element (logical 1-based index). Returns updated array (ByRef)
Private Sub EnsureArrayMetaCapacityAndSet(ByRef arr As Variant, ByVal logicalIndex As Long, ByVal value As Variant, ByVal optionBase As Long)
    ' optionBase is 1 or 0 (we assume emitter and program platform will use 1)
    Dim wasArr As Boolean
    wasArr = False
    If IsArray(arr) Then wasArr = True

    If Not wasArr Then
        ' create new meta-array sized to cover logicalIndex
        Dim newArr As Variant
        ReDim newArr(1 To 2 + logicalIndex)   ' indices: 1..2+logicalIndex
        newArr(1) = ""                        ' name unknown
        newArr(2) = CLng(logicalIndex)       ' capacity now logicalIndex
        Dim i As Long
        For i = 1 To logicalIndex
            vAssignment newArr(2 + i), Empty
        Next i
        ' set value
        vAssignment newArr(2 + logicalIndex), value
        vAssignment arr, newArr
        Exit Sub
    End If

    Dim cap As Long
    cap = GetArrayMetaCapacity(arr)
    If cap = -1 Then
        ' unallocated: allocate to logicalIndex
        Dim newUB As Long
        newUB = 2 + logicalIndex
        Dim tmpArr As Variant
        ReDim tmpArr(1 To newUB)
        ' copy name if present
        Dim nm As Variant
        nm = arr(1)
        tmpArr(1) = IIf(IsEmpty(nm), "", nm)
        ' set capacity
        tmpArr(2) = CLng(logicalIndex)
        Dim i2 As Long
        For i2 = 1 To logicalIndex
            vAssignment tmpArr(2 + i2), Empty
        Next i2
        vAssignment tmpArr(2 + logicalIndex), value
        vAssignment arr, tmpArr
        Exit Sub
    End If

    ' already allocated; maybe need to expand
    If logicalIndex <= cap Then
        ' in bounds
        Dim actualPos2 As Long
        actualPos2 = 2 + logicalIndex
        vAssignment arr(actualPos2), value
        Exit Sub
    Else
        ' expand to new capacity = logicalIndex
        Dim oldLB As Long
        Dim oldUB As Long
        oldLB = LBound(arr)
        oldUB = UBound(arr)
        Dim newUB2 As Long
        newUB2 = 2 + logicalIndex
        ReDim Preserve arr(oldLB To newUB2)
        ' update capacity
        arr(2) = CLng(logicalIndex)
        vAssignment arr(2 + logicalIndex), value
        Exit Sub
    End If
End Sub

' Find symbol name by slot number (scans symbols Map). Returns "" if not found.
Private Function GetSymbolNameBySlot(symbols As Map, slot As Long) As String
    On Error Resume Next
    Dim key As Variant
    For Each key In symbols.keyS
        If CStr(key) = "__slot_count" Then
            ' skip
        Else
            Dim v As Variant
            v = symbols.GetValue(CStr(key))
            If IsNumeric(v) Then
                If CLng(v) = slot Then
                    GetSymbolNameBySlot = CStr(key)
                    Exit Function
                End If
            End If
        End If
    Next key
    GetSymbolNameBySlot = ""
    On Error GoTo 0
End Function
' -------------------------
' Nested array-meta helpers
' Representation (outer array always 3 elements):
'  arr(1) -> name as String ("" if unknown)
'  arr(2) -> capacity (Long) (-1 means UNALLOCATED)
'  arr(3) -> inner array (Variant array) or Empty when unallocated
' Logical element i lives at innerArray(i) where innerArray is 1..capacity
' -------------------------
Private Function CreateArrayNestedMeta(Optional initialCapacity As Long = -1) As Variant
    Dim meta As Variant
    ReDim meta(1 To 3)
    meta(1) = ""
    If initialCapacity <= 0 Then
        meta(2) = -1
        meta(3) = Empty
    Else
        meta(2) = CLng(initialCapacity)
        Dim inner() As Variant
        ReDim inner(1 To initialCapacity)
        Dim ii As Long
        For ii = 1 To initialCapacity: inner(ii) = Empty: Next ii
        meta(3) = inner
    End If
    CreateArrayNestedMeta = meta
End Function


Private Function IsArrayNestedAllocated(v As Variant) As Boolean
    On Error Resume Next
    If Not IsArray(v) Then
        IsArrayNestedAllocated = False
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim lb As Long
    Dim ub As Long
    lb = LBound(v)
    ub = UBound(v)
    If (ub - lb + 1) < 3 Then
        IsArrayNestedAllocated = False
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim capV As Variant
    capV = v(2)
    If Not IsNumeric(capV) Then
        IsArrayNestedAllocated = False
    Else
        If CLng(capV) = -1 Then
            IsArrayNestedAllocated = False
        Else
            ' also check inner array exists and is an array
            If IsArray(v(3)) Then
                IsArrayNestedAllocated = True
            Else
                IsArrayNestedAllocated = False
            End If
        End If
    End If
    On Error GoTo 0
End Function

Private Function GetArrayNestedCapacity(arr As Variant) As Long
    On Error Resume Next
    If Not IsArray(arr) Then GetArrayNestedCapacity = -1: Exit Function
    If Not (LBound(arr) <= 2 And UBound(arr) >= 2) Then GetArrayNestedCapacity = -1: Exit Function
    Dim c As Variant: c = arr(2)
    If IsNumeric(c) Then
        GetArrayNestedCapacity = CLng(c)
    Else
        GetArrayNestedCapacity = -1
    End If
    On Error GoTo 0
End Function

Private Function GetArrayNestedElement(arr As Variant, logicalIndex As Long) As Variant
    Dim outv As Variant
    outv = Empty
    On Error Resume Next
    If Not IsArray(arr) Then
        GetArrayNestedElement = Empty
        err.Clear
        On Error GoTo 0
        Exit Function
    End If
    Dim cap As Long
    cap = GetArrayNestedCapacity(arr)
    If cap = -1 Then
        GetArrayNestedElement = Empty
        Exit Function
    End If
    If logicalIndex < 1 Or logicalIndex > cap Then
        GetArrayNestedElement = Empty
        Exit Function
    End If
    Dim inner As Variant
    inner = arr(3)
    vAssignment outv, inner(logicalIndex)
    GetArrayNestedElement = outv
    On Error GoTo 0
End Function

' Ensure arrMeta exists and has sufficient capacity, then set element at logicalIndex (1-based logical)
Private Sub EnsureArrayNestedCapacityAndSet(ByRef arrMeta As Variant, ByVal logicalIndex As Long, ByVal value As Variant, ByVal optionBase As Long)
    If Not IsArray(arrMeta) Then
        arrMeta = CreateArrayNestedMeta(0)
    End If

    Dim cap As Long: cap = GetArrayNestedCapacity(arrMeta)
    If cap = -1 Then
        Dim need As Long: need = logicalIndex
        If need < 1 Then need = 1
        Dim inner() As Variant
        ReDim inner(1 To need)
        Dim p As Long
        For p = 1 To need
            inner(p) = Empty
        Next p
        arrMeta(2) = need
        arrMeta(3) = inner
    Else
        If logicalIndex < 1 Then logicalIndex = 1
        If logicalIndex > cap Then
            Dim oldInner As Variant: oldInner = arrMeta(3)
            Dim oldCap As Long: oldCap = cap
            Dim newCap As Long: newCap = logicalIndex
            Dim newInner() As Variant
            ReDim newInner(1 To newCap)
            Dim ii As Long
            For ii = 1 To newCap
                If ii <= oldCap Then
                    newInner(ii) = oldInner(ii)
                Else
                    newInner(ii) = Empty
                End If
            Next ii
            arrMeta(2) = newCap
            arrMeta(3) = newInner
        End If
    End If

    ' set element
    Dim ai As Long: ai = logicalIndex
    Dim inn As Variant: inn = arrMeta(3)
    vAssignment inn(ai), value
    arrMeta(3) = inn
End Sub
' Get property value from base-like object
Private Function VM_GetPropertyValue(baseObj As Variant, propName As String) As Variant
    Dim out As Variant: out = Empty
    On Error Resume Next
    If TypeName(baseObj) = "Map" Then
        vAssignment out, baseObj.GetValue(propName)
        If err.Number <> 0 Then err.Clear: out = Empty
    ElseIf IsArray(baseObj) Then
        If IsNumeric(propName) Then
            If IsArrayAllocated(baseObj) Then
                Dim idxn As Long: idxn = CLng(propName)
                Dim lb As Long: lb = LBound(baseObj)
                Dim ub As Long: ub = UBound(baseObj)
                Dim actualIdx As Long: actualIdx = lb + idxn - 1
                If actualIdx >= lb And actualIdx <= ub Then out = baseObj(actualIdx) Else out = Empty
            Else
                out = Empty
            End If
        Else
            out = Empty
        End If
    ElseIf TypeName(baseObj) = "Collection" Then
        If IsNumeric(propName) Then
            Dim idc As Long: idc = CLng(propName)
            If idc >= 1 And idc <= baseObj.Count Then out = baseObj(idc) Else out = Empty
        Else
            out = Empty
        End If
    ElseIf IsObject(baseObj) Then
        On Error Resume Next
        vAssignment out, baseObj.GetValue(propName)
        If err.Number <> 0 Then err.Clear: out = Empty
    Else
        out = Empty
    End If
    On Error GoTo 0
    vAssignment VM_GetPropertyValue, out
End Function

' Traverse path collection from rootObj; returns the object at end of path or Empty
Private Function VM_TraversePathFromRoot(rootObj As Variant, pathColl As Collection) As Variant
    Dim cur As Variant: vAssignment cur, rootObj
    If pathColl Is Nothing Then vAssignment VM_TraversePathFromRoot, cur: Exit Function
    Dim i As Long
    For i = 1 To pathColl.Count
        Dim p As String: p = CStr(pathColl(i))
        vAssignment cur, VM_GetPropertyValue(cur, p)
        If IsEmpty(cur) Then Exit For
    Next i
    vAssignment VM_TraversePathFromRoot, cur
End Function

' Set a property on parentObj according to type (Map, Array element, object)
Private Sub VM_SetProperty(parentObj As Variant, propName As String, value As Variant)
    On Error Resume Next
    If TypeName(parentObj) = "Map" Then
        If parentObj.Exists(propName) Then
            parentObj.SetValue propName, value
        Else
            parentObj.Add propName, value
        End If
    ElseIf IsArray(parentObj) Then
        If IsNumeric(propName) Then
            If IsArrayAllocated(parentObj) Then
                Dim idxn As Long: idxn = CLng(propName)
                Dim lb As Long: lb = LBound(parentObj)
                Dim ub As Long: ub = UBound(parentObj)
                Dim actualIdx As Long: actualIdx = lb + idxn - 1
                If actualIdx >= lb And actualIdx <= ub Then
                    vAssignment parentObj(actualIdx), value
                Else
                    If VERBOSE_ Then
                        If IsObject(GLOBALS_.gRuntimeLog) Then
                            GLOBALS_.gRuntimeLog.Add "VM: INDEX_SET OOB idx=" & _
                                            CStr(idxn) & " bounds=[" & CStr(lb) & "," & CStr(ub) & "]"
                        End If
                    End If
                End If
            End If
        End If
    ElseIf TypeName(parentObj) = "Collection" Then
        ' Collection can't set element by index in-place; log
        If VERBOSE_ Then
            If IsObject(GLOBALS_.gRuntimeLog) Then
                GLOBALS_.gRuntimeLog.Add "VM: COLLECTION set not supported prop=" & propName
            End If
        End If
    ElseIf IsObject(parentObj) Then
        On Error Resume Next
        parentObj.SetValue propName, value
        If err.Number <> 0 Then err.Clear
    End If
    On Error GoTo 0
End Sub

' ---------------------
' End VM class
' ---------------------

