VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "Compiler"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
' ---------------------
' Compiler class
' ---------------------
' Class Module: Compiler
Option Explicit
Private GLOBALS_ As Globals
Private Const OP_NOP = 0
Private Const OP_PUSH_CONST = 1
Private Const OP_LOAD_FAST = 2
Private Const OP_STORE_FAST = 3
Private Const OP_LOAD_NAME = 4
Private Const OP_STORE_NAME = 5
Private Const OP_BINARY = 6
Private Const OP_MAKE_ARRAY = 7
Private Const OP_PRINT = 8
Private Const OP_POP = 9
Private Const OP_JUMP = 10
Private Const OP_JUMP_IF_FALSE = 11
Private Const OP_PUSH_AST_NODE = 12
Private Const OP_LOAD_MEMBER_KEEP_BASE = 13
Private Const OP_MEMBER_SET = 14
Private Const OP_INDEX_GET = 15
Private Const OP_INDEX_SET = 16
Private Const OP_BUILTIN_FAST = 17
Private Const OP_CALL = 18
Private Const OP_CALL_FUNC = 19
Private Const OP_CALL_FUNC_WITH_THIS = 20
Private Const OP_RETURN = 21
Private Const OP_MEMBER_OF_VALUE = 22
Private Const OP_LOAD_MEMBER_FROM_VALUE_KEEP_BASE = 23

' Module state used during emission
Private m_codesCol As Collection
Private m_argsCol As Collection
Private m_symbolMap As Map
Private m_nextSlot As Long
Private m_progTempCounter As Long
Private m_loopStack As Collection

' Produces AST (Maps) for program and functions.
' Relies on Parser.Tokenize, Map, ScopeStack and globals:
'   ProgramCache, gPrograms (Collection), gFuncTable (Map), gFuncParams (Map)

Public Sub SetGlobals(ByRef aGlobals As Globals)
    Set GLOBALS_ = aGlobals
End Sub

' Node helpers (Map-based)
Private Function MakeNode(nodeType As String) As Map
    Dim M As New Map
    M.Add "type", nodeType
    Set MakeNode = M
End Function

' ---------------------
' Utility: deep-clone a Collection of Maps or primitive values
' ---------------------
Private Function CloneCollectionOfVariants(src As Variant) As Collection
    Dim out As New Collection
    Dim it As Variant
    For Each it In src
        If IsObject(it) Then
            If TypeName(it) = "Map" Then
                out.Add it.Clone
            ElseIf TypeName(it) = "Collection" Then
                out.Add CloneCollectionOfVariants(it)
            Else
                out.Add it
            End If
        Else
            out.Add it
        End If
    Next it
    Set CloneCollectionOfVariants = out
End Function

' ---------------------

Public Function CompileProgram(src As String, Optional progName As String = "@anon") As Long
    Dim p As Parser
    Dim toks As Collection
    Dim progScope As ScopeStack
    Dim stmtsAST As Collection
    Dim stmtTokens As Collection
    Dim i As Long
    Dim node As Map
    
    GLOBALS_.ASF_InitGlobals

    If GLOBALS_.ProgramCache.Exists(src) Then
        CompileProgram = GLOBALS_.ProgramCache.GetValue(src)
        Exit Function
    End If

    Set p = New Parser
    With p
        .SetGlobals GLOBALS_
        Set toks = .Tokenize(src)
    End With
    
    Set progScope = New ScopeStack
    progScope.Push

    Set stmtsAST = New Collection
    i = 1

Compiler_MainLoop:
    Do While i <= toks.count
        ' skip comments at top level
        If toks(i)(0) = "COMMENT" Then
            i = i + 1
            GoTo Compiler_MainLoop
        End If

        ' Function definition at top-level
        If toks(i)(0) = "IDENT" And LCase$(toks(i)(1)) = "fun" Then
            i = i + 1
            ' skip comments
            Do While i <= toks.count And toks(i)(0) = "COMMENT"
                i = i + 1
            Loop
            If i > toks.count Then err.Raise vbObjectError + 1, , "Unexpected end after fun"
            Dim fname As String: fname = toks(i)(1)
            i = i + 1
            Do While i <= toks.count And toks(i)(0) = "COMMENT"
                i = i + 1
            Loop

            Dim argList As New Collection
            If i <= toks.count And toks(i)(0) = "PAREN" And toks(i)(1) = "(" Then
                i = i + 1
                Do While i <= toks.count And Not (toks(i)(0) = "PAREN" And toks(i)(1) = ")")
                    If toks(i)(0) = "COMMENT" Then
                        i = i + 1
                    Else
                        If toks(i)(0) = "IDENT" Then argList.Add toks(i)(1)
                        i = i + 1
                    End If
                Loop
                If i <= toks.count And toks(i)(0) = "PAREN" And toks(i)(1) = ")" Then i = i + 1
            End If

            Do While i <= toks.count And toks(i)(0) = "COMMENT"
                i = i + 1
            Loop
            If i > toks.count Or Not (toks(i)(0) = "PAREN" And toks(i)(1) = "{") Then
                err.Raise vbObjectError + 2, , "Expected function body"
            End If
            i = i + 1
            Dim depth As Long: depth = 0
            Dim bodyTokens As New Collection
            Do While i <= toks.count
                If toks(i)(0) = "PAREN" Then
                    If toks(i)(1) = "{" Then
                        depth = depth + 1
                    ElseIf toks(i)(1) = "}" Then
                        If depth = 0 Then
                            Exit Do
                        Else
                            depth = depth - 1
                        End If
                    End If
                End If
                bodyTokens.Add toks(i)
                i = i + 1
            Loop

            Dim funcIdx As Long
            funcIdx = CompileFunctionAST(fname, argList, bodyTokens)
            GLOBALS_.gFuncTable.Add fname, funcIdx

            Dim pa() As String
            If argList.count > 0 Then ReDim pa(0 To argList.count - 1)
            Dim j As Long
            For j = 1 To argList.count
                pa(j - 1) = argList(j)
            Next j
            GLOBALS_.gFuncParams.Add fname, pa

            If i <= toks.count Then i = i + 1 ' skip the trailing '}' if present
            GoTo Compiler_MainLoop
        Else
            ' collect a top-level statement tokens (nesting-aware) then parse to AST node
            Dim braceDepth As Long: braceDepth = 0
            Dim parenDepth As Long: parenDepth = 0
            Dim bracketDepth As Long: bracketDepth = 0
            
            Set stmtTokens = New Collection
            
            Do While i <= toks.count
                If toks(i)(0) = "COMMENT" Then
                    i = i + 1
                    GoTo CollectNextTop
                End If

                If toks(i)(0) = "PAREN" Then
                    Select Case toks(i)(1)
                        Case "{"
                            braceDepth = braceDepth + 1
                        Case "}"
                            If braceDepth > 0 Then
                                braceDepth = braceDepth - 1
                            End If
                        Case "("
                            parenDepth = parenDepth + 1
                        Case ")"
                            If parenDepth > 0 Then
                                parenDepth = parenDepth - 1
                            End If
                        Case "["
                            bracketDepth = bracketDepth + 1
                        Case "]"
                            If bracketDepth > 0 Then
                                bracketDepth = bracketDepth - 1
                            End If
                    End Select
                End If

                ' Top-level statement separator: semicolon (commas are argument separators) if we are not nested
                If toks(i)(0) = "SEP" And toks(i)(1) = ";" And braceDepth = 0 And parenDepth = 0 And bracketDepth = 0 Then
                    i = i + 1
                    Exit Do
                End If

                stmtTokens.Add toks(i)
                i = i + 1
CollectNextTop:
            Loop

            If stmtTokens.count > 0 Then
                Set node = ParseStatementTokensToAST(stmtTokens)
                If Not node Is Nothing Then
                    ' add a clone to avoid accidental reference reuse
                    stmtsAST.Add node.Clone
                End If
            End If
            GoTo Compiler_MainLoop
        End If
    Loop
    Dim optionBase As Long: optionBase = 1
    Dim filteredStmts As New Collection
    For i = 1 To stmtsAST.count
        Dim stmt As Map: Set stmt = stmtsAST(i)
        If stmt.GetValue("type") = "OptionBase" Then
            optionBase = CLng(stmt.GetValue("value"))
        Else
            filteredStmts.Add stmt
        End If
    Next i
    Set stmtsAST = filteredStmts
    Dim pIndex As Long
    Dim normalizedStmts As Collection
    ' Normalize assignment-like expression-statements into proper Assign AST nodes
    Set normalizedStmts = NormalizeAssignsInStmts(stmtsAST)
    ' Normalize collapsed identifiers (e.g. a.b, a[2], a.b[3].c) into Member/Index AST nodes
    Set normalizedStmts = NormalizeCollapsedIdentsInStmts(normalizedStmts)
    pIndex = GLOBALS_.gPrograms.count + 1
    GLOBALS_.gPrograms.Add Array(progName, normalizedStmts, progScope.Raw, optionBase)
    EmitCompactBytecodeForProgram pIndex, normalizedStmts
    ' In EmitterFinishStore (temporary)
    If IsObject(GLOBALS_.gRuntimeLog) Then
        Dim outS As String: outS = "BYTECODE: "
        Dim codes As Variant
        Dim argsArr As Variant
        codes = GLOBALS_.gProgramsBytecode(1).GetValue("codes")
        argsArr = GLOBALS_.gProgramsBytecode(1).GetValue("args")
        For i = 1 To UBound(codes)
            outS = outS & CStr(codes(i)) & "(" & TypeName(argsArr(i)) & ") "
        Next i
        GLOBALS_.gRuntimeLog.Add outS
    End If
    GLOBALS_.ProgramCache.Add src, pIndex
    CompileProgram = pIndex
End Function

' Compile a function body (AST) and register it as separate program
Private Function CompileFunctionAST(fname As String, argList As Collection, bodyTokens As Collection) As Long
    Dim funcScope As ScopeStack
    Dim i As Long
    Dim bodyStmtsAST As Collection
    Set funcScope = New ScopeStack
    funcScope.Push
    For i = 1 To argList.count
        funcScope.SetValue argList(i), Empty
    Next i
    Dim idx As Long
    Set bodyStmtsAST = ParseTokensToAST(bodyTokens)
    ' Normalize assignments inside function body as well
    Set bodyStmtsAST = NormalizeAssignsInStmts(bodyStmtsAST)
    ' Normalize collapsed identifiers (e.g. a.b, a[2], a.b[3].c) into Member/Index AST nodes
    Set bodyStmtsAST = NormalizeCollapsedIdentsInStmts(bodyStmtsAST)
    idx = GLOBALS_.gPrograms.count + 1
    GLOBALS_.gPrograms.Add Array(fname, bodyStmtsAST, funcScope.Raw)
    CompileFunctionAST = idx
End Function

' Parse a list of tokens representing a block into AST statements (returns Collection of Map nodes)
Private Function ParseTokensToAST(toks As Collection) As Collection
    Dim out As Collection
    Dim stmtTokens As Collection
    Set out = New Collection
    Dim i As Long: i = 1
    Dim closedTopLevelBlock As Boolean
    
ParseMain:
    Do While i <= toks.count
        If toks(i)(0) = "COMMENT" Then
            i = i + 1
            GoTo ParseMain
        End If
        Set stmtTokens = New Collection
        Dim braceDepth As Long: braceDepth = 0
        Dim parenDepth As Long: parenDepth = 0
        Dim bracketDepth As Long: bracketDepth = 0

ParseInner:
        Do While i <= toks.count
            If toks(i)(0) = "COMMENT" Then
                i = i + 1
                GoTo ParseInner
            End If
            If toks(i)(0) = "PAREN" Then
                Select Case toks(i)(1)
                    Case "{"
                        braceDepth = braceDepth + 1
                    Case "}"
                        ' decrement only if we have an inner brace to close
                        If braceDepth > 0 Then
                            braceDepth = braceDepth - 1
                        End If
                        ' If we've just closed a top-level block (braceDepth now 0),
                        ' that usually signals the end of a statement (e.g. end of an if/for/while block).
                        ' Finalize the current statement tokens so adjacent statements are parsed separately.
                        If braceDepth = 0 Then
                            ' include this '}' token into the current stmtTokens and finish the statement
                            stmtTokens.Add toks(i)
                            i = i + 1
                            ' mark that we closed a top-level block for follow-up checks
                            closedTopLevelBlock = True
                            Exit Do
                        End If
                    Case "("
                        parenDepth = parenDepth + 1
                    Case ")"
                        If parenDepth > 0 Then
                            parenDepth = parenDepth - 1
                        End If
                    Case "["
                        bracketDepth = bracketDepth + 1
                    Case "]"
                        If bracketDepth > 0 Then
                            bracketDepth = bracketDepth - 1
                        End If
                End Select
            End If

            ' Only a semicolon (;) is a top-level statement separator.
            If toks(i)(0) = "SEP" And toks(i)(1) = ";" And braceDepth = 0 And parenDepth = 0 And bracketDepth = 0 Then
                i = i + 1
                Exit Do
            End If
    
            ' default: append current token and continue
            stmtTokens.Add toks(i)
            i = i + 1
        Loop

        If stmtTokens.count > 0 Then
            Dim tmpNode As Map
            Set tmpNode = ParseStatementTokensToAST(stmtTokens)
            If Not tmpNode Is Nothing Then
                ' If we closed a top-level block and the next token is not a semicolon,
                ' warn the user (do not silently swallow).
                If closedTopLevelBlock Then
                    If i <= toks.count Then
                        If Not (toks(i)(0) = "SEP" And toks(i)(1) = ";") Then
                            ' If the next token is not a comment and not end-of-input, log warning.
                            If Not (toks(i)(0) = "COMMENT") Then
                                On Error Resume Next
                                ' best-effort: add to runtime log if present, and print to Immediate
                                If Not GLOBALS_.gRuntimeLog Is Nothing Then GLOBALS_.gRuntimeLog.Add "COMPILER: missing ';' after block near token index " & CStr(i)
                                On Error GoTo 0
                            End If
                        Else
                            ' consume explicit semicolon
                            i = i + 1
                        End If
                    End If
                    closedTopLevelBlock = False
                End If
                out.Add tmpNode.Clone
            End If
        End If
        GoTo ParseMain
    Loop

    Set ParseTokensToAST = out
End Function

' Parse a single statement token collection into an AST node (Map)
Private Function ParseStatementTokensToAST(stmtTokens As Collection) As Map
    If stmtTokens.count = 0 Then
        Set ParseStatementTokensToAST = Nothing
        Exit Function
    End If

    ' quick check for print
    If stmtTokens.count >= 2 Then
        If stmtTokens(1)(0) = "IDENT" And LCase$(stmtTokens(1)(1)) = "print" Then
            Dim k As Long: k = 2
            Do While k <= stmtTokens.count And Not (stmtTokens(k)(0) = "PAREN" And stmtTokens(k)(1) = "(")
                k = k + 1
            Loop
            If k <= stmtTokens.count Then
                Dim opened As Long: opened = 1
                k = k + 1
                Dim innerToks As Collection
                Set innerToks = New Collection
                Do While k <= stmtTokens.count And opened > 0
                    If stmtTokens(k)(0) = "PAREN" Then
                        If stmtTokens(k)(1) = "(" Then
                            opened = opened + 1
                        ElseIf stmtTokens(k)(1) = ")" Then
                            opened = opened - 1
                        End If
                    End If
                    If opened > 0 Then innerToks.Add stmtTokens(k)
                    k = k + 1
                Loop
                Dim args As Collection: Set args = ParseArgsTokensToExprNodes(innerToks)
                Dim node As Map: Set node = MakeNode("Print")
                node.SetValue "args", args
                Set ParseStatementTokensToAST = node
                Exit Function
            End If
        End If
    End If

    ' keywords
    If stmtTokens(1)(0) = "IDENT" Then
        Dim kw As String: kw = LCase$(stmtTokens(1)(1))
        Select Case kw
            Case "if"
                Set ParseStatementTokensToAST = ParseIfAST(stmtTokens)
                Exit Function
            Case "for"
                Set ParseStatementTokensToAST = ParseForAST(stmtTokens)
                Exit Function
            Case "while"
                Set ParseStatementTokensToAST = ParseWhileAST(stmtTokens)
                Exit Function
            Case "try"
                Set ParseStatementTokensToAST = ParseTryCatchAST(stmtTokens)
                Exit Function
            Case "switch"
                Set ParseStatementTokensToAST = ParseSwitchAST(stmtTokens)
                Exit Function
            Case "break"
                Dim b As Map: Set b = MakeNode("Break")
                Set ParseStatementTokensToAST = b
                Exit Function
            Case "continue"
                Dim c As Map: Set c = MakeNode("Continue")
                Set ParseStatementTokensToAST = c
                Exit Function
            Case "return"
                Dim rv As Map: Set rv = MakeNode("Return")
                If stmtTokens.count >= 2 Then
                    Dim rhs As New Collection, M As Long
                    For M = 2 To stmtTokens.count
                        rhs.Add stmtTokens(M)
                    Next M
                    Dim rexpr As Map: Set rexpr = ParseExprTokensToNode(rhs)
                    rv.SetValue "expr", rexpr
                Else
                    rv.SetValue "expr", Nothing
                End If
                Set ParseStatementTokensToAST = rv
                Exit Function
            Case "option"
                If stmtTokens.count >= 3 And LCase$(stmtTokens(2)(1)) = "base" Then
                    If stmtTokens.count >= 4 And stmtTokens(3)(0) = "NUMBER" Then
                        Dim baseVal As Long: baseVal = CLng(stmtTokens(3)(1))
                        If baseVal = 0 Or baseVal = 1 Then
                            ' Set as program flag - return special node
                            Dim optNode As Map: Set optNode = MakeNode("OptionBase")
                            optNode.SetValue "value", baseVal
                            Set ParseStatementTokensToAST = optNode
                            Exit Function
                        End If
                    End If
                End If
        End Select
    End If

    ' assignment: find top-level "=" operator position or compound-assignment like "+=", "-=", "*=", etc.
    Dim assignPos As Long: assignPos = 0
    Dim compoundOp As String: compoundOp = ""
    Dim ii As Long
    Dim depthB As Long, depthP As Long, depthBr As Long
    For ii = 1 To stmtTokens.count
        If stmtTokens(ii)(0) = "PAREN" Then
            Select Case stmtTokens(ii)(1)
                Case "{"
                    depthB = depthB + 1
                Case "}"
                    If depthB > 0 Then depthB = depthB - 1
                Case "("
                    depthP = depthP + 1
                Case ")"
                    If depthP > 0 Then depthP = depthP - 1
                Case "["
                    depthBr = depthBr + 1
                Case "]"
                    If depthBr > 0 Then depthBr = depthBr - 1
            End Select
        End If
        If depthB = 0 And depthP = 0 And depthBr = 0 And stmtTokens(ii)(0) = "OP" Then
            Dim opv As String: opv = CStr(stmtTokens(ii)(1))
            ' plain assignment
            If opv = "=" Then
                assignPos = ii
                Exit For
            End If
            ' compound assignment operators we support
            Select Case opv
                Case "+=", "-=", "*=", "/=", "%=", "^=", "&=", "|=", "<<=", ">>="
                    assignPos = ii
                    compoundOp = opv
                    Exit For
            End Select
        End If
    Next ii

    If assignPos > 0 Then
        Dim lhsT As Collection, rhsT As Collection, t As Long
        Set lhsT = New Collection: Set rhsT = New Collection
        For t = 1 To assignPos - 1
            lhsT.Add stmtTokens(t)
        Next t
        For t = assignPos + 1 To stmtTokens.count
            rhsT.Add stmtTokens(t)
        Next t
        Dim lhsNode As Map
        If lhsT.count = 1 And lhsT(1)(0) = "IDENT" Then
            Dim nm As String: nm = lhsT(1)(1)
            If InStr(nm, "[") > 0 Then
                Dim baseName As String: baseName = left$(nm, InStr(nm, "[") - 1)
                Dim idxStr As String: idxStr = Mid$(nm, InStr(nm, "[") + 1, Len(nm) - InStr(nm, "[") - 1)
                Dim idxNode As Map: Set idxNode = ParseExprFromStringToNode(idxStr)
                Set lhsNode = MakeNode("Index")
                Dim tmpVar As Map: Set tmpVar = MakeNode("Variable")
                tmpVar.SetValue "name", baseName
                lhsNode.SetValue "base", tmpVar
                lhsNode.SetValue "index", idxNode
            Else
                Set lhsNode = MakeNode("Variable")
                lhsNode.SetValue "name", nm
            End If
        Else
            Set lhsNode = ParseExprTokensToNode(lhsT)
        End If

        Dim rhsNode As Map
        If compoundOp <> "" Then
            ' For compound assignments like "a += 3" produce:
            ' Assign { left: lhsNode, right: Binary { left: (clone of lhsNode), op: <op>, right: <rhsExpr> } }
            Dim innerOp As String: innerOp = left$(compoundOp, Len(compoundOp) - 1)
            Dim rightExpr As Map: Set rightExpr = ParseExprTokensToNode(rhsT)
            Dim lhsClone As Map: Set lhsClone = lhsNode.Clone
            Dim bin As Map: Set bin = MakeNode("Binary")
            bin.SetValue "left", lhsClone
            bin.SetValue "op", innerOp
            bin.SetValue "right", rightExpr
            Set rhsNode = bin
        Else
            Set rhsNode = ParseExprTokensToNode(rhsT)
        End If

        Dim asn As Map: Set asn = MakeNode("Assign")
        asn.SetValue "left", lhsNode
        asn.SetValue "right", rhsNode
        Set ParseStatementTokensToAST = asn
        Exit Function
    End If
    ' fallback: expression statement
    Dim exprNode As Map
    Set exprNode = ParseExprTokensToNode(stmtTokens)
    Dim es As Map: Set es = MakeNode("ExprStmt")
    es.SetValue "expr", exprNode
    Set ParseStatementTokensToAST = es
End Function

' ---------------------
' Expression parsing -> Expr AST nodes
' ---------------------

Private Function ParseArgsTokensToExprNodes(argTokens As Collection) As Collection
    Dim out As New Collection
    If argTokens.count = 0 Then
        Set ParseArgsTokensToExprNodes = out
        Exit Function
    End If
    Dim i As Long: i = 1
    Dim braceDepth As Long: braceDepth = 0
    Dim parenDepth As Long: parenDepth = 0
    Dim bracketDepth As Long: bracketDepth = 0
    Dim cur As New Collection
ParseArgsMain:
    Do While i <= argTokens.count
        If argTokens(i)(0) = "PAREN" Then
            Select Case argTokens(i)(1)
                Case "{"
                    braceDepth = braceDepth + 1
                Case "}"
                    If braceDepth > 0 Then braceDepth = braceDepth - 1
                Case "("
                    parenDepth = parenDepth + 1
                Case ")"
                    If parenDepth > 0 Then parenDepth = parenDepth - 1
                Case "["
                    bracketDepth = bracketDepth + 1
                Case "]"
                    If bracketDepth > 0 Then bracketDepth = bracketDepth - 1
            End Select
        End If
        ' Argument/element separator: comma only (semicolon is NOT an argument separator)
        If argTokens(i)(0) = "SEP" And argTokens(i)(1) = "," And braceDepth = 0 And parenDepth = 0 And bracketDepth = 0 Then
            If cur.count > 0 Then out.Add ParseExprTokensToNode(cur)
            Set cur = New Collection
            i = i + 1
            GoTo ParseArgsMain
        End If

        cur.Add argTokens(i)
        i = i + 1
    Loop
    If cur.count > 0 Then out.Add ParseExprTokensToNode(cur)
    Set ParseArgsTokensToExprNodes = out
End Function

Private Function ParseExprFromStringToNode(exprStr As String) As Map
    Dim p As Parser
    Set p = New Parser
    Dim toks As Collection
    Set toks = p.Tokenize(exprStr)
    Set ParseExprFromStringToNode = ParseExprTokensToNode(toks)
End Function

Private Function ParseExprTokensToNode(toks As Collection) As Map
    Dim n As Long: n = toks.count
    If n = 0 Then
        Set ParseExprTokensToNode = MakeNode("Literal"): ParseExprTokensToNode.SetValue "value", Empty
        Exit Function
    End If

    Dim types() As String, vals() As Variant, i As Long
    ReDim types(0 To n - 1)
    ReDim vals(0 To n - 1)
    For i = 1 To n
        types(i - 1) = toks(i)(0)
        vals(i - 1) = toks(i)(1)
    Next i

    Dim idx As Long: idx = 0
    Set ParseExprTokensToNode = ParseTernaryNode(types, vals, n, idx)
End Function

' Recursive descent building nodes

Private Function ParseTernaryNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    ' parse cond ? trueExpr : falseExpr (right-assoc)
    Dim cond As Map
    Set cond = ParseLogicalOrNode(types, vals, n, idx)
    If idx < n Then
        If types(idx) = "OP" And vals(idx) = "?" Then
            idx = idx + 1
            Dim trueExpr As Map
            Set trueExpr = ParseTernaryNode(types, vals, n, idx) ' right-assoc: allow nested ternary
            ' expect ':'
            If idx < n And types(idx) = "OP" And vals(idx) = ":" Then
                idx = idx + 1
            Else
                err.Raise vbObjectError + 8001, "Compiler.ParseTernaryNode", "Expected ':' in ternary expression"
            End If
            Dim falseExpr As Map
            Set falseExpr = ParseTernaryNode(types, vals, n, idx)
            Dim tn As New Map
            tn.Add "type", "Ternary"
            tn.SetValue "cond", cond
            tn.SetValue "trueExpr", trueExpr
            tn.SetValue "falseExpr", falseExpr
            Set ParseTernaryNode = tn
            Exit Function
        End If
    End If
    Set ParseTernaryNode = cond
End Function

Private Function ParseLogicalOrNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim right_ As Map
    Dim node As Map
    Dim op As String
    Set left_ = ParseLogicalAndNode(types, vals, n, idx)
    Do While idx < n
        If Not (types(idx) = "OP" And vals(idx) = "||") Then Exit Do
        op = vals(idx)
        idx = idx + 1
        Set right_ = ParseLogicalAndNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", op
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParseLogicalOrNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParseLogicalAndNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim right_ As Map
    Dim node As Map
    Set left_ = ParseEqualityNode(types, vals, n, idx)
    Do While idx < n
        If Not (types(idx) = "OP" And vals(idx) = "&&") Then Exit Do
        idx = idx + 1
        Set right_ = ParseEqualityNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", "&&"
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParseLogicalAndNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParseEqualityNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim right_ As Map
    Dim node As Map
    Dim op As String
    Set left_ = ParseRelationalNode(types, vals, n, idx)
    Do While idx < n
        If Not (types(idx) = "OP" And (vals(idx) = "==" Or vals(idx) = "=" Or vals(idx) = "!=")) Then Exit Do
        op = vals(idx)
        idx = idx + 1
        Set right_ = ParseRelationalNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", op
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParseEqualityNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParseRelationalNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim right_ As Map
    Dim node As Map
    Dim op As String
    Set left_ = ParseShiftNode(types, vals, n, idx)
    Do While idx < n
        If Not (types(idx) = "OP" And (vals(idx) = "<" Or vals(idx) = ">" Or vals(idx) = "<=" Or vals(idx) = ">=")) Then Exit Do
        op = vals(idx)
        idx = idx + 1
        Set right_ = ParseShiftNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", op
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParseRelationalNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParseShiftNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim right_ As Map
    Dim node As Map
    Dim op As String
    Set left_ = ParseAddNode(types, vals, n, idx)
    Do While idx < n
        If Not (types(idx) = "OP" And (vals(idx) = "<<" Or vals(idx) = ">>")) Then Exit Do
        op = vals(idx)
        idx = idx + 1
        Set right_ = ParseAddNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", op
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParseShiftNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParseAddNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim op As String
    Dim right_ As Map
    Dim node As Map
    Set left_ = ParseMulNode(types, vals, n, idx)
    Do While idx < n
        If Not (types(idx) = "OP" And (vals(idx) = "+" Or vals(idx) = "-")) Then Exit Do
        op = vals(idx)
        idx = idx + 1
        Set right_ = ParseMulNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", op
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParseAddNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParseMulNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim right_ As Map
    Dim node As Map
    Dim op As String
    Set left_ = ParsePowNode(types, vals, n, idx)
    Do While idx < n
        If Not (types(idx) = "OP" And (vals(idx) = "*" Or vals(idx) = "/" Or vals(idx) = "%")) Then Exit Do
        op = vals(idx)
        idx = idx + 1
        Set right_ = ParsePowNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", op
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParseMulNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParsePowNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    Dim left_ As Map
    Dim right_ As Map
    Dim node As Map
    Set left_ = ParseUnaryNode(types, vals, n, idx)
    Do While idx < n
        ' Right-associative exponentiation:
        ' if we see '^' after the left operand, parse the RHS with ParsePow
        ' so a ^ b ^ c => a ^ (b ^ c)
        If Not (types(idx) = "OP" And vals(idx) = "^") Then Exit Do
        idx = idx + 1
        ' parse the right-hand side with ParsePow to ensure right-assoc
        Set right_ = ParsePowNode(types, vals, n, idx)
        Set node = MakeNode("Binary")
        node.SetValue "op", "^"
        node.SetValue "left", left_.Clone
        node.SetValue "right", right_.Clone
        Set left_ = node
    Loop
    Set ParsePowNode = left_.Clone
    Set left_ = Nothing
    Set right_ = Nothing
    Set node = Nothing
End Function

Private Function ParseUnaryNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    If idx < n And types(idx) = "OP" Then
        Dim op As String: op = vals(idx)
        If op = "!" Or op = "-" Then
            idx = idx + 1
            Dim v As Map: Set v = ParseUnaryNode(types, vals, n, idx)
            Dim node As Map: Set node = MakeNode("Unary")
            node.SetValue "op", op
            node.SetValue "expr", v
            Set ParseUnaryNode = node
            Exit Function
        End If
    End If
    Set ParseUnaryNode = ParsePrimaryNode(types, vals, n, idx)
End Function

Private Function ParsePrimaryNode(types() As String, vals() As Variant, n As Long, ByRef idx As Long) As Map
    If idx >= n Then
        Set ParsePrimaryNode = MakeNode("Literal")
        ParsePrimaryNode.SetValue "value", Empty
        Exit Function
    End If
    Dim t As String: t = types(idx)
    Dim v As Variant: v = vals(idx)
    Dim currentNode As Map
    Dim mem As Map
    Dim indexNode As Map
    Dim propName As String
    
    Select Case t
        Case "NUMBER"
            Dim nNode As Map: Set nNode = MakeNode("Literal")
            nNode.SetValue "value", CDbl(v)
            idx = idx + 1
            Set ParsePrimaryNode = nNode
            Exit Function
        Case "STRING"
            Dim sNode As Map: Set sNode = MakeNode("Literal")
            sNode.SetValue "value", v
            idx = idx + 1
            Set ParsePrimaryNode = sNode
            Exit Function
        Case "VBEXPR"
            ' Special token produced by the parser for @(...) or direct VBAexpressions block.
            ' Create a VBExpr node with the raw expression string (to be evaluated by VBAexpressions at runtime).
            Dim vbNode As Map: Set vbNode = MakeNode("VBAexpr")
            vbNode.SetValue "expr", CStr(v)
            idx = idx + 1
            Set ParsePrimaryNode = vbNode
            Exit Function
        Case "IDENT"
            Dim name As String: name = v
            If LCase$(name) = "true" Then
                Dim bt As Map: Set bt = MakeNode("Literal")
                bt.SetValue "value", True
                idx = idx + 1
                Set ParsePrimaryNode = bt
                Exit Function
            ElseIf LCase$(name) = "false" Then
                Dim bf As Map: Set bf = MakeNode("Literal")
                bf.SetValue "value", False
                idx = idx + 1
                Set ParsePrimaryNode = bf
                Exit Function
            End If

            ' Expression-level anonymous function literal: fun (p1, p2) { ... }
            ' This reuses the same 'fun' token used for top-level function declarations but emits
            ' a FuncLiteral node usable inside expressions.
            If LCase$(name) = "fun" Then
                ' advance past 'fun'
                idx = idx + 1
                ' expect parameter list
                Dim params As Collection
                Set params = New Collection
                If idx < n And types(idx) = "PAREN" And vals(idx) = "(" Then
                    idx = idx + 1
                    Do While idx < n And Not (types(idx) = "PAREN" And vals(idx) = ")")
                        If types(idx) = "IDENT" Then
                            params.Add CStr(vals(idx))
                            idx = idx + 1
                            If idx < n And types(idx) = "SEP" And vals(idx) = "," Then idx = idx + 1
                        ElseIf types(idx) = "SEP" And vals(idx) = "," Then
                            idx = idx + 1
                        Else
                            ' skip unexpected tokens until ')'
                            idx = idx + 1
                        End If
                    Loop
                    If idx < n And types(idx) = "PAREN" And vals(idx) = ")" Then idx = idx + 1
                End If

                ' parse body { ... }
                If idx < n And types(idx) = "PAREN" And vals(idx) = "{" Then
                    idx = idx + 1
                    Dim depthBody As Long: depthBody = 0
                    Dim bodyTok As Collection
                    Set bodyTok = New Collection
                    Do While idx < n
                        If types(idx) = "PAREN" Then
                            If vals(idx) = "{" Then
                                depthBody = depthBody + 1
                            ElseIf vals(idx) = "}" Then
                                If depthBody = 0 Then
                                    Exit Do
                                Else
                                    depthBody = depthBody - 1
                                End If
                            End If
                        End If
                        bodyTok.Add Array(types(idx), vals(idx))
                        idx = idx + 1
                    Loop
                    ' consume closing '}'
                    If idx < n And types(idx) = "PAREN" And vals(idx) = "}" Then idx = idx + 1
                    Dim bodyStmts As Collection: Set bodyStmts = ParseTokensToAST(bodyTok)
                    Dim fnode As Map: Set fnode = MakeNode("FuncLiteral")
                    fnode.SetValue "params", params
                    fnode.SetValue "body", bodyStmts
                    Set ParsePrimaryNode = fnode.Clone
                    Exit Function
                Else
                    ' no body found -> emit empty function literal
                    Dim fnode2 As Map: Set fnode2 = MakeNode("FuncLiteral")
                    fnode2.SetValue "params", params
                    Dim emptyCol As New Collection
                    fnode2.SetValue "body", emptyCol
                    Set ParsePrimaryNode = fnode2
                    Exit Function
                End If
            End If

            Dim lenCall As Map
            Dim builtinLen As Map
            Dim al As Collection
            ' If the identifier contains '.' or '[' we may have a collapsed dotted/indexed form
            ' like:  o.a[2].v  or  a[3]  or  some.deep.path[2].length
            ' Parse the string here into nested Member/Index/Variable AST nodes so the rest
            ' of the parser/VM works with explicit nodes instead of a plain Variable "o.a".
            Set currentNode = Nothing
            If InStr(name, ".") > 0 Or InStr(name, "[") > 0 Then
                Dim s As String: s = CStr(name)
                Dim posS As Long: posS = 1
                Dim l As Long: l = Len(s)
                ' Helper: read an identifier starting at posS
                Dim ident As String
                ident = ""
                Do While posS <= l
                    Dim ch0 As String: ch0 = Mid$(s, posS, 1)
                    If ch0 = "." Or ch0 = "[" Then Exit Do
                    ident = ident & ch0
                    posS = posS + 1
                Loop
                ' start with a Variable for the leading identifier
                Set currentNode = MakeNode("Variable")
                currentNode.SetValue "name", ident

                Do While posS <= l
                   Dim ch As String: ch = Mid$(s, posS, 1)
                    If ch = "." Then
                        ' member access .prop
                        posS = posS + 1
                        ' read identifier after dot
                        propName = ""
                        Do While posS <= l
                            Dim ch2 As String: ch2 = Mid$(s, posS, 1)
                            If ch2 = "." Or ch2 = "[" Then Exit Do
                            propName = propName & ch2
                            posS = posS + 1
                        Loop
                        ' Special-case ".length" on a previous Index result -> builtin len call
                        If LCase$(propName) = "length" Then
                            Set lenCall = MakeNode("Call")
                            Set builtinLen = MakeNode("Variable")
                            builtinLen.SetValue "name", ".__len__"
                            lenCall.SetValue "callee", builtinLen
                            lenCall.SetValue "name", ".__len__"
                            Set al = New Collection
                            al.Add currentNode.Clone
                            lenCall.SetValue "args", al
                            idx = idx + 1
                            Set ParsePrimaryNode = lenCall
                            Exit Function
                        End If
                        Set mem = MakeNode("Member")
                        mem.SetValue "base", currentNode.Clone
                        mem.SetValue "prop", propName
                        Set currentNode = mem
                    ElseIf ch = "[" Then
                        ' find matching closing bracket (support nested brackets)
                        Dim depthBr As Long: depthBr = 0
                        Dim startIdx As Long: startIdx = posS
                        Dim posClose As Long: posClose = 0
                        Dim iCh As Long
                        For iCh = posS To l
                            Dim cch As String: cch = Mid$(s, iCh, 1)
                            If cch = "[" Then
                                depthBr = depthBr + 1
                            ElseIf cch = "]" Then
                                depthBr = depthBr - 1
                                If depthBr = 0 Then
                                    posClose = iCh
                                    Exit For
                                End If
                            End If
                        Next iCh
                        If posClose = 0 Then
                            err.Raise vbObjectError + 8002, "Compiler.ParsePrimary", "Invalid collapsed identifier: missing ']' in " & s
                        End If
                        Dim idxStr As String: idxStr = Mid$(s, posS + 1, posClose - posS - 1)
                        Dim idxNodeFromStr As Map: Set idxNodeFromStr = ParseExprFromStringToNode(idxStr)
                        Set indexNode = MakeNode("Index")
                        indexNode.SetValue "base", currentNode.Clone
                        indexNode.SetValue "index", idxNodeFromStr
                        Set currentNode = indexNode
                        posS = posClose + 1
                    Else
                        ' unknown char Â— stop parsing the collapsed form
                        Exit Do
                    End If
                Loop

                ' consume the IDENT token so postfix loop sees following tokens like '.' 'v'
                idx = idx + 1
                ' Leave currentNode set so the postfix loop below will
                ' attach any subsequent `.prop`, `[...]` or `(args)` tokens.
            End If
            
            ' create initial variable node for an IDENT (only if collapsed form didn't create it)
            If currentNode Is Nothing Then
                Set currentNode = MakeNode("Variable")
                currentNode.SetValue "name", name
                idx = idx + 1
            End If
            ' Postfix loop: handle .prop, [...], func calls (...) as postfixes chaining onto currentNode
            Do While idx < n
                ' member access a.b (with special-case for ".length" -> builtin __len__ call)
                If types(idx) = "SYM" And vals(idx) = "." Then
                    idx = idx + 1
                    If idx < n And types(idx) = "IDENT" Then
                        propName = CStr(vals(idx))
                        ' If user asks for ".length" transform into a call to builtin __len__
                        ' at compile time: a[3].length  -->  __len__( a[3] )
                        Select Case LCase$(propName)
                            Case "length"
                                Dim lenCallNode As Map: Set lenCallNode = MakeNode("Call")
                                Dim builtinLenVar As Map: Set builtinLenVar = MakeNode("Variable")
                                builtinLenVar.SetValue "name", ".__len__"
                                lenCallNode.SetValue "callee", builtinLenVar
                                lenCallNode.SetValue "name", ".__len__"
                                Dim lenArgs As New Collection
                                lenArgs.Add currentNode.Clone
                                lenCallNode.SetValue "args", lenArgs
                                Set currentNode = lenCallNode.Clone
                                idx = idx + 1
                            Case Else
                                Set mem = MakeNode("Member")
                                mem.SetValue "base", currentNode
                                mem.SetValue "prop", propName
                                Set currentNode = mem.Clone
                                idx = idx + 1
                        End Select
                        ' continue loop
                    Else
                        ' invalid member access; stop postfixing
                        Exit Do
                    End If
                ' index access a[expr]
                ElseIf types(idx) = "PAREN" And vals(idx) = "[" Then
                    idx = idx + 1
                    Dim idxTok As Collection
                    Set idxTok = New Collection
                    Dim depthIdx As Long: depthIdx = 0
                    Do While idx < n
                        If types(idx) = "PAREN" Then
                            If vals(idx) = "[" Then
                                depthIdx = depthIdx + 1
                            ElseIf vals(idx) = "]" Then
                                If depthIdx = 0 Then
                                    Exit Do
                                Else
                                    depthIdx = depthIdx - 1
                                End If
                            End If
                        End If
                        idxTok.Add Array(types(idx), vals(idx))
                        idx = idx + 1
                    Loop
                    Dim idxExprNode As Map: Set idxExprNode = ParseExprTokensToNode(idxTok)
                    If idx < n And types(idx) = "PAREN" And vals(idx) = "]" Then idx = idx + 1
                    Set indexNode = MakeNode("Index")
                    indexNode.SetValue "base", currentNode
                    indexNode.SetValue "index", idxExprNode
                    Set currentNode = indexNode.Clone
                ' function / method call: ( arglist )
                ElseIf types(idx) = "PAREN" And vals(idx) = "(" Then
                    ' parse args with nested depth counters (borrowed pattern from previous call parsing logic)
                    idx = idx + 1
                    Dim argNodes As Collection
                    Dim argTok As Collection
                    Dim argTokDepthParen As Long
                    Dim argTokDepthBr As Long
                    Dim argTokDepthB As Long
                    Set argNodes = New Collection
                    Do
                        Set argTok = New Collection
                        argTokDepthParen = 0
                        argTokDepthBr = 0
                        argTokDepthB = 0
                        Do While idx < n
                            If types(idx) = "PAREN" Then
                                Select Case CStr(vals(idx))
                                    Case "("
                                        argTokDepthParen = argTokDepthParen + 1
                                    Case ")"
                                        If argTokDepthParen = 0 Then Exit Do Else argTokDepthParen = argTokDepthParen - 1
                                    Case "["
                                        argTokDepthBr = argTokDepthBr + 1
                                    Case "]"
                                        If argTokDepthBr = 0 Then Exit Do Else argTokDepthBr = argTokDepthBr - 1
                                    Case "{"
                                        argTokDepthB = argTokDepthB + 1
                                    Case "}"
                                        If argTokDepthB = 0 Then Exit Do Else argTokDepthB = argTokDepthB - 1
                                End Select
                            ElseIf types(idx) = "SEP" And vals(idx) = "," And argTokDepthParen = 0 And argTokDepthBr = 0 And argTokDepthB = 0 Then
                                Exit Do
                            End If
                            argTok.Add Array(types(idx), vals(idx))
                            idx = idx + 1
                        Loop
                        If argTok.count > 0 Then
                            argNodes.Add ParseExprTokensToNode(argTok)
                        Else
                            Dim litEmpty As Map: Set litEmpty = MakeNode("Literal")
                            litEmpty.SetValue "value", Empty
                            argNodes.Add litEmpty.Clone
                        End If
                        If idx < n Then
                            If types(idx) = "SEP" And vals(idx) = "," Then
                                idx = idx + 1
                                ' continue parsing next arg
                            ElseIf types(idx) = "PAREN" And vals(idx) = ")" Then
                                idx = idx + 1
                                Exit Do
                            Else
                                ' unexpected token -> stop args parsing
                                Exit Do
                            End If
                        Else
                            Exit Do
                        End If
                    Loop
                    Dim callNode As Map: Set callNode = MakeNode("Call")
                    callNode.SetValue "callee", currentNode
                    callNode.SetValue "args", argNodes
                    Set currentNode = callNode.Clone
                Else
                    Exit Do
                End If
            Loop
            Set ParsePrimaryNode = currentNode.Clone
            Exit Function
        Case "PAREN"
            If v = "(" Then
                idx = idx + 1
                Dim innerNode As Map: Set innerNode = ParseLogicalOrNode(types, vals, n, idx)
                If idx < n And types(idx) = "PAREN" And vals(idx) = ")" Then idx = idx + 1
                Set ParsePrimaryNode = innerNode.Clone
                Exit Function
            ElseIf v = "[" Then
                idx = idx + 1
                Dim arrList As Collection
                Dim elemTok As Collection
                Set arrList = New Collection
                Do While idx < n And Not (types(idx) = "PAREN" And vals(idx) = "]")
                    Set elemTok = New Collection
                    ' Collect element tokens until a comma (element separator) or closing bracket
                    Do While idx < n And Not ((types(idx) = "SEP" And vals(idx) = ",") Or (types(idx) = "PAREN" And vals(idx) = "]"))
                        elemTok.Add Array(types(idx), vals(idx))
                        idx = idx + 1
                    Loop
                    arrList.Add ParseExprTokensToNode(elemTok)
                    If idx < n And types(idx) = "SEP" And vals(idx) = "," Then idx = idx + 1
                Loop
                If idx < n And types(idx) = "PAREN" And vals(idx) = "]" Then idx = idx + 1
                Dim arrNode As Map: Set arrNode = MakeNode("Array")
                arrNode.SetValue "items", arrList
                Set ParsePrimaryNode = arrNode.Clone
                Exit Function
            ElseIf v = "{" Then
                ' object literal: { key: value, key2: value2 }
                idx = idx + 1
                Dim objItems As Collection
                Dim pair As Collection
                Set objItems = New Collection
                ' key can be IDENT or STRING
                Dim keyTok As String
                Do While idx < n And Not (types(idx) = "PAREN" And vals(idx) = "}")
                    If types(idx) = "IDENT" Or types(idx) = "STRING" Then
                        keyTok = CStr(vals(idx))
                        idx = idx + 1
                    Else
                        err.Raise vbObjectError + 8002, "Compiler.ParsePrimary", "Invalid object key"
                    End If
                    ' expect ':'
                    If idx < n And types(idx) = "OP" And vals(idx) = ":" Then
                        idx = idx + 1
                    Else
                        err.Raise vbObjectError + 8003, "Compiler.ParsePrimary", "Expected ':' after object key"
                    End If
                    ' parse value expression
                    Dim valNode As Map
                    Set valNode = ParseTernaryNode(types, vals, n, idx)
                    ' store pair (key, node)
                    Set pair = New Collection
                    pair.Add keyTok
                    pair.Add valNode.Clone
                    objItems.Add pair
                    ' optional comma
                    If idx < n And types(idx) = "SEP" And vals(idx) = "," Then idx = idx + 1
                Loop
                If idx < n And types(idx) = "PAREN" And vals(idx) = "}" Then idx = idx + 1
                Dim onode As Map: Set onode = MakeNode("Object")
                onode.SetValue "items", objItems
                Set ParsePrimaryNode = onode.Clone
                Exit Function
            End If
    End Select

    Dim defN As Map: Set defN = MakeNode("Literal")
    defN.SetValue "value", Empty
    Set ParsePrimaryNode = defN
End Function

' ---------------------
' AST builders for control structures
' ---------------------

Private Function ParseIfAST(stmtTokens As Collection) As Map
    Dim node As Map: Set node = MakeNode("If")
    Dim i As Long: i = 2
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "(")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseIfAST = node: Exit Function
    i = i + 1
    Dim condTokens As Collection
    Set condTokens = New Collection
    Dim condDepth As Long: condDepth = 0
    Do While i <= stmtTokens.count
        If stmtTokens(i)(0) = "PAREN" Then
            If stmtTokens(i)(1) = "(" Then
                condDepth = condDepth + 1
            ElseIf stmtTokens(i)(1) = ")" Then
                If condDepth = 0 Then
                    Exit Do
                Else
                    condDepth = condDepth - 1
                End If
            End If
        End If
        condTokens.Add stmtTokens(i)
        i = i + 1
    Loop
    node.SetValue "cond", ParseExprTokensToNode(condTokens)

    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseIfAST = node.Clone: GoTo clean_
    Dim j As Long: j = i + 1
    Dim depth As Long: depth = 0
    Dim thenTokens As Collection
    Set thenTokens = New Collection
    Do While j <= stmtTokens.count
        If stmtTokens(j)(0) = "PAREN" Then
            If stmtTokens(j)(1) = "{" Then
                depth = depth + 1
            ElseIf stmtTokens(j)(1) = "}" Then
                If depth = 0 Then
                    Exit Do
                Else
                    depth = depth - 1
                End If
            End If
        End If
        thenTokens.Add stmtTokens(j)
        j = j + 1
    Loop
    node.SetValue "then", ParseTokensToAST(thenTokens)

    Dim pos As Long: pos = j + 1
    Dim elseifConds As Collection, elseifBlocks As Collection
    Dim hasElse As Boolean: hasElse = False
    Dim tName As String
    Dim eCondTok As Collection
    Dim eBlockTok As Collection
    Dim elseTok As Collection
    Dim eDepth As Long
    Set elseifConds = New Collection
    Set elseifBlocks = New Collection
    Do While pos <= stmtTokens.count
        If stmtTokens(pos)(0) = "COMMENT" Then
            pos = pos + 1
            GoTo IfParseNext
        End If
        If stmtTokens(pos)(0) = "IDENT" Then
            tName = LCase$(stmtTokens(pos)(1))
            If tName = "elseif" Then
                pos = pos + 1
                Do While pos <= stmtTokens.count And Not (stmtTokens(pos)(0) = "PAREN" And stmtTokens(pos)(1) = "(")
                    pos = pos + 1
                Loop
                If pos > stmtTokens.count Then Exit Do
                pos = pos + 1
                eDepth = 0
                Set eCondTok = New Collection
                Do While pos <= stmtTokens.count
                    If stmtTokens(pos)(0) = "PAREN" Then
                        If stmtTokens(pos)(1) = "(" Then
                            eDepth = eDepth + 1
                        ElseIf stmtTokens(pos)(1) = ")" Then
                            If eDepth = 0 Then
                                Exit Do
                            Else
                                eDepth = eDepth - 1
                            End If
                        End If
                    End If
                    eCondTok.Add stmtTokens(pos)
                    pos = pos + 1
                Loop
                Do While pos <= stmtTokens.count And Not (stmtTokens(pos)(0) = "PAREN" And stmtTokens(pos)(1) = "{")
                    pos = pos + 1
                Loop
                If pos > stmtTokens.count Then Exit Do
                pos = pos + 1
                Set eBlockTok = New Collection
                depth = 0
                Do While pos <= stmtTokens.count
                    If stmtTokens(pos)(0) = "PAREN" Then
                        If stmtTokens(pos)(1) = "{" Then
                            depth = depth + 1
                        ElseIf stmtTokens(pos)(1) = "}" Then
                            If depth = 0 Then
                                Exit Do
                            Else
                                depth = depth - 1
                            End If
                        End If
                    End If
                    eBlockTok.Add stmtTokens(pos)
                    pos = pos + 1
                Loop
                elseifConds.Add ParseExprTokensToNode(eCondTok)
                elseifBlocks.Add ParseTokensToAST(eBlockTok)
                pos = pos + 1
                GoTo IfParseNext
            ElseIf tName = "else" Then
                pos = pos + 1
                Do While pos <= stmtTokens.count And Not (stmtTokens(pos)(0) = "PAREN" And stmtTokens(pos)(1) = "{")
                    pos = pos + 1
                Loop
                If pos > stmtTokens.count Then Exit Do
                pos = pos + 1
                Set elseTok = New Collection
                depth = 0
                Do While pos <= stmtTokens.count
                    If stmtTokens(pos)(0) = "PAREN" Then
                        If stmtTokens(pos)(1) = "{" Then
                            depth = depth + 1
                        ElseIf stmtTokens(pos)(1) = "}" Then
                            If depth = 0 Then
                                Exit Do
                            Else
                                depth = depth - 1
                            End If
                        End If
                    End If
                    elseTok.Add stmtTokens(pos)
                    pos = pos + 1
                Loop
                hasElse = True
                node.SetValue "else", ParseTokensToAST(elseTok)
                Exit Do
            Else
                Exit Do
            End If
        Else
            Exit Do
        End If
IfParseNext:
    Loop

    node.SetValue "elseif_conds", CloneCollectionOfVariants(elseifConds)
    node.SetValue "elseif_blocks", CloneCollectionOfVariants(elseifBlocks)
    node.SetValue "hasElse", hasElse
    Set ParseIfAST = node
clean_:
    Set node = Nothing
    Set eCondTok = Nothing
    Set eBlockTok = Nothing
    Set elseTok = Nothing
    Set elseifConds = Nothing
    Set elseifBlocks = Nothing
End Function

Private Function ParseForAST(stmtTokens As Collection) As Map
    Dim node As Map: Set node = MakeNode("For")
    Dim initTok As Collection
    Dim condTok As Collection
    Dim stepTok As Collection
    Dim bodyToks As Collection
    Dim i As Long: i = 2
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "(")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseForAST = node: Exit Function
    i = i + 1
    Set initTok = New Collection
    Dim hdrParen As Long, hdrBracket As Long, hdrBrace As Long
    hdrParen = 0: hdrBracket = 0: hdrBrace = 0
    Do While i <= stmtTokens.count
        If stmtTokens(i)(0) = "PAREN" Then
            Select Case stmtTokens(i)(1)
                Case "("
                    hdrParen = hdrParen + 1
                Case ")"
                    If hdrParen > 0 Then
                        hdrParen = hdrParen - 1
                    Else
                        Exit Do
                    End If
                Case "["
                    hdrBracket = hdrBracket + 1
                Case "]"
                    If hdrBracket > 0 Then hdrBracket = hdrBracket - 1
                Case "{"
                    hdrBrace = hdrBrace + 1
                Case "}"
                    If hdrBrace > 0 Then hdrBrace = hdrBrace - 1
            End Select
        End If
        If hdrParen = 0 And hdrBracket = 0 And hdrBrace = 0 And stmtTokens(i)(0) = "SEP" And _
                        (stmtTokens(i)(1) = "," Or stmtTokens(i)(1) = ";") Then
            i = i + 1
            Exit Do
        End If
        initTok.Add stmtTokens(i)
        i = i + 1
    Loop
    node.SetValue "init", ParseExprTokensToNode(initTok)

    Set condTok = New Collection
    hdrParen = 0: hdrBracket = 0: hdrBrace = 0
    Do While i <= stmtTokens.count
        If stmtTokens(i)(0) = "PAREN" Then
            Select Case stmtTokens(i)(1)
                Case "("
                    hdrParen = hdrParen + 1
                Case ")"
                    If hdrParen > 0 Then
                        hdrParen = hdrParen - 1
                    Else
                        Exit Do
                    End If
                Case "["
                    hdrBracket = hdrBracket + 1
                Case "]"
                    If hdrBracket > 0 Then hdrBracket = hdrBracket - 1
                Case "{"
                    hdrBrace = hdrBrace + 1
                Case "}"
                    If hdrBrace > 0 Then hdrBrace = hdrBrace - 1
            End Select
        End If
        If hdrParen = 0 And hdrBracket = 0 And hdrBrace = 0 And stmtTokens(i)(0) = "SEP" And _
                        (stmtTokens(i)(1) = "," Or stmtTokens(i)(1) = ";") Then
            i = i + 1
            Exit Do
        End If
        condTok.Add stmtTokens(i)
        i = i + 1
    Loop
    node.SetValue "cond", ParseExprTokensToNode(condTok)

    Set stepTok = New Collection
    hdrParen = 0: hdrBracket = 0: hdrBrace = 0
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = ")")
        If stmtTokens(i)(0) = "PAREN" Then
            Select Case stmtTokens(i)(1)
                Case "("
                    hdrParen = hdrParen + 1
                Case ")"
                    If hdrParen > 0 Then hdrParen = hdrParen - 1
                Case "["
                    hdrBracket = hdrBracket + 1
                Case "]"
                    If hdrBracket > 0 Then hdrBracket = hdrBracket - 1
                Case "{"
                    hdrBrace = hdrBrace + 1
                Case "}"
                    If hdrBrace > 0 Then hdrBrace = hdrBrace - 1
            End Select
        End If
        stepTok.Add stmtTokens(i)
        i = i + 1
    Loop
    node.SetValue "step", ParseExprTokensToNode(stepTok)

    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseForAST = node.Clone: GoTo clean_
    Dim j As Long: j = i + 1
    Dim depth As Long: depth = 0
    Set bodyToks = New Collection
    Do While j <= stmtTokens.count
        If stmtTokens(j)(0) = "PAREN" Then
            If stmtTokens(j)(1) = "{" Then
                depth = depth + 1
            ElseIf stmtTokens(j)(1) = "}" Then
                If depth = 0 Then
                    Exit Do
                Else
                    depth = depth - 1
                End If
            End If
        End If
        bodyToks.Add stmtTokens(j)
        j = j + 1
    Loop
    node.SetValue "body", ParseTokensToAST(bodyToks)
    Set ParseForAST = node.Clone
clean_:
    Set node = Nothing
    Set bodyToks = Nothing
    Set stepTok = Nothing
    Set condTok = Nothing
    Set initTok = Nothing
End Function

Private Function ParseWhileAST(stmtTokens As Collection) As Map
    Dim node As Map: Set node = MakeNode("While")
    Dim i As Long: i = 2
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "(")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseWhileAST = node: Exit Function
    i = i + 1
    Dim condTok As Collection
    Set condTok = New Collection
    Dim depthP As Long: depthP = 0
    Do While i <= stmtTokens.count
        If stmtTokens(i)(0) = "PAREN" Then
            If stmtTokens(i)(1) = "(" Then
                depthP = depthP + 1
            ElseIf stmtTokens(i)(1) = ")" Then
                If depthP = 0 Then
                    Exit Do
                Else
                    depthP = depthP - 1
                End If
            End If
        End If
        condTok.Add stmtTokens(i)
        i = i + 1
    Loop
    node.SetValue "cond", ParseExprTokensToNode(condTok)

    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseWhileAST = node: Exit Function
    Dim j As Long: j = i + 1
    Dim depth As Long: depth = 0
    Dim bodyToks As Collection
    Set bodyToks = New Collection
    Do While j <= stmtTokens.count
        If stmtTokens(j)(0) = "PAREN" Then
            If stmtTokens(j)(1) = "{" Then
                depth = depth + 1
            ElseIf stmtTokens(j)(1) = "}" Then
                If depth = 0 Then
                    Exit Do
                Else
                    depth = depth - 1
                End If
            End If
        End If
        bodyToks.Add stmtTokens(j)
        j = j + 1
    Loop
    node.SetValue "body", ParseTokensToAST(bodyToks)
    Set ParseWhileAST = node
End Function

Private Function ParseTryCatchAST(stmtTokens As Collection) As Map
    Dim node As Map: Set node = MakeNode("TryCatch")
    Dim i As Long: i = 2
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseTryCatchAST = node: Exit Function
    Dim j As Long: j = i + 1
    Dim depth As Long: depth = 0
    Dim tryTok As Collection
    Set tryTok = New Collection
    Do While j <= stmtTokens.count
        If stmtTokens(j)(0) = "PAREN" Then
            If stmtTokens(j)(1) = "{" Then
                depth = depth + 1
            ElseIf stmtTokens(j)(1) = "}" Then
                If depth = 0 Then
                    Exit Do
                Else
                    depth = depth - 1
                End If
            End If
        End If
        tryTok.Add stmtTokens(j)
        j = j + 1
    Loop
    node.SetValue "try", ParseTokensToAST(tryTok)

    Dim k As Long: k = j + 1
    Dim catchTok As Collection
    Set catchTok = New Collection
    Do While k <= stmtTokens.count
        If stmtTokens(k)(0) = "IDENT" And LCase$(stmtTokens(k)(1)) = "catch" Then
            Dim kk As Long: kk = k + 1
            Do While kk <= stmtTokens.count And Not (stmtTokens(kk)(0) = "PAREN" And stmtTokens(kk)(1) = "{")
                kk = kk + 1
            Loop
            If kk <= stmtTokens.count Then
                kk = kk + 1
                Dim depth2 As Long: depth2 = 0
                Do While kk <= stmtTokens.count
                    If stmtTokens(kk)(0) = "PAREN" Then
                        If stmtTokens(kk)(1) = "{" Then
                            depth2 = depth2 + 1
                        ElseIf stmtTokens(kk)(1) = "}" Then
                            If depth2 = 0 Then
                                Exit Do
                            Else
                                depth2 = depth2 - 1
                            End If
                        End If
                    End If
                    catchTok.Add stmtTokens(kk)
                    kk = kk + 1
                Loop
            End If
            Exit Do
        End If
        k = k + 1
    Loop
    node.SetValue "catch", ParseTokensToAST(catchTok)
    Set ParseTryCatchAST = node
End Function

Private Function ParseSwitchAST(stmtTokens As Collection) As Map
    Dim node As Map: Set node = MakeNode("Switch")
    Dim i As Long: i = 2
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "(")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseSwitchAST = node: Exit Function
    i = i + 1
    Dim condTok As New Collection
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = ")")
        condTok.Add stmtTokens(i)
        i = i + 1
    Loop
    node.SetValue "expr", ParseExprTokensToNode(condTok)

    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{")
        i = i + 1
    Loop
    If i > stmtTokens.count Then Set ParseSwitchAST = node: Exit Function
    i = i + 1
    Dim cases As Collection
    Set cases = New Collection
    Dim defaultBlock As Collection
    Dim valTok As Collection
    Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "}")
        If stmtTokens(i)(0) = "IDENT" And LCase$(stmtTokens(i)(1)) = "case" Then
            i = i + 1
            Set valTok = New Collection
            Dim cvParen As Long: cvParen = 0
            Dim cvBracket As Long: cvBracket = 0
            Dim cvBrace As Long: cvBrace = 0
            Do While i <= stmtTokens.count
                If stmtTokens(i)(0) = "PAREN" Then
                    Select Case stmtTokens(i)(1)
                        Case "("
                            cvParen = cvParen + 1
                        Case ")"
                            If cvParen > 0 Then cvParen = cvParen - 1
                        Case "["
                            cvBracket = cvBracket + 1
                        Case "]"
                            If cvBracket > 0 Then cvBracket = cvBracket - 1
                        Case "{"
                            If cvParen = 0 And cvBracket = 0 Then
                                Exit Do
                            Else
                                cvBrace = cvBrace + 1
                            End If
                        Case "}"
                            If cvBrace > 0 Then cvBrace = cvBrace - 1
                    End Select
                End If
                valTok.Add stmtTokens(i)
                i = i + 1
            Loop
            Dim caseValNode As Map: Set caseValNode = ParseExprTokensToNode(valTok)
            If i <= stmtTokens.count And stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{" Then
                i = i + 1
                Dim depth As Long: depth = 0
                Dim blockTok As Collection
                Dim pair As Collection
                Dim caseBlock As Collection
                Set blockTok = New Collection
                Do While i <= stmtTokens.count
                    If stmtTokens(i)(0) = "PAREN" Then
                        If stmtTokens(i)(1) = "{" Then
                            depth = depth + 1
                        ElseIf stmtTokens(i)(1) = "}" Then
                            If depth = 0 Then
                                Exit Do
                            Else
                                depth = depth - 1
                            End If
                        End If
                    End If
                    blockTok.Add stmtTokens(i)
                    i = i + 1
                Loop
                Set caseBlock = ParseTokensToAST(blockTok)
                Set pair = New Collection
                pair.Add caseValNode
                pair.Add caseBlock
                cases.Add pair
                i = i + 1
            End If
        ElseIf stmtTokens(i)(0) = "IDENT" And LCase$(stmtTokens(i)(1)) = "default" Then
            i = i + 1
            Do While i <= stmtTokens.count And Not (stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{")
                i = i + 1
            Loop
            If i <= stmtTokens.count And stmtTokens(i)(0) = "PAREN" And stmtTokens(i)(1) = "{" Then
                i = i + 1
                Dim depth2 As Long: depth2 = 0
                Dim defTok As New Collection
                Do While i <= stmtTokens.count
                    If stmtTokens(i)(0) = "PAREN" Then
                        If stmtTokens(i)(1) = "{" Then
                            depth2 = depth2 + 1
                        ElseIf stmtTokens(i)(1) = "}" Then
                            If depth2 = 0 Then
                                Exit Do
                            Else
                                depth2 = depth2 - 1
                            End If
                        End If
                    End If
                    defTok.Add stmtTokens(i)
                    i = i + 1
                Loop
                Set defaultBlock = ParseTokensToAST(defTok)
                i = i + 1
            End If
        Else
            i = i + 1
        End If
    Loop
    node.SetValue "cases", cases
    node.SetValue "default", defaultBlock
    Set ParseSwitchAST = node
End Function


' Compiler AST normalization pass
' Converts expression statements like (Binary op "=" ...) into Assign nodes
' when the left-hand side is a valid assignment target (Variable or Index).
' Also normalizes `for` init/step and recursively visits blocks.
'
Private Function IsAssignableNode(n As Map) As Boolean
    If n Is Nothing Then
        IsAssignableNode = False: Exit Function
    End If
    Dim t As String: t = n.GetValue("type")
    ' Accept variable, indexed access (arr[i]) and member access (obj.prop)
    If t = "Variable" Or t = "Index" Or t = "Member" Then
        IsAssignableNode = True
    Else
        IsAssignableNode = False
    End If
End Function

Private Function NormalizeExprNodeRecursive(expr As Map) As Map
    ' Recursively walk expression nodes and normalize inner expressions as needed.
    If expr Is Nothing Then
        Set NormalizeExprNodeRecursive = Nothing: Exit Function
    End If
    Dim t As String: t = expr.GetValue("type")
    Select Case t
        Case "Binary"
            Dim left_ As Map: Set left_ = NormalizeExprNodeRecursive(expr.GetValue("left"))
            Dim right_ As Map: Set right_ = NormalizeExprNodeRecursive(expr.GetValue("right"))
            ' create new Binary node only if children changed, otherwise return original
            If (Not left_ Is expr.GetValue("left")) Or (Not right_ Is expr.GetValue("right")) Then
                Dim nb As New Map
                nb.Add "type", "Binary"
                nb.SetValue "op", expr.GetValue("op")
                nb.SetValue "left", IIf(left_ Is Nothing, expr.GetValue("left"), left_)
                nb.SetValue "right", IIf(right_ Is Nothing, expr.GetValue("right"), right_)
                Set NormalizeExprNodeRecursive = nb
                Exit Function
            End If
            Set NormalizeExprNodeRecursive = expr
            Exit Function
        Case "Unary"
            Dim rec As Map: Set rec = NormalizeExprNodeRecursive(expr.GetValue("expr"))
            If Not rec Is expr.GetValue("expr") Then
                Dim nu As New Map
                nu.Add "type", "Unary"
                nu.SetValue "op", expr.GetValue("op")
                nu.SetValue "expr", rec
                Set NormalizeExprNodeRecursive = nu
                Exit Function
            End If
            Set NormalizeExprNodeRecursive = expr
            Exit Function
        Case "Call"
            ' normalize args
            Dim args As Collection: Set args = expr.GetValue("args")
            If Not args Is Nothing Then
                Dim newArgs As New Collection
                Dim changed As Boolean: changed = False
                Dim i As Long
                For i = 1 To args.count
                    Dim ae As Map: Set ae = NormalizeExprNodeRecursive(args(i))
                    If Not ae Is args(i) Then changed = True: newArgs.Add ae Else newArgs.Add args(i)
                Next i
                If changed Then
                    Dim nc As New Map
                    nc.Add "type", "Call"
                    nc.SetValue "name", expr.GetValue("name")
                    nc.SetValue "args", newArgs
                    Set NormalizeExprNodeRecursive = nc
                    Exit Function
                End If
            End If
            Set NormalizeExprNodeRecursive = expr
            Exit Function
        Case "Index"
            Dim b As Map: Set b = NormalizeExprNodeRecursive(expr.GetValue("base"))
            Dim idx As Map: Set idx = NormalizeExprNodeRecursive(expr.GetValue("index"))
            If Not b Is expr.GetValue("base") Or Not idx Is expr.GetValue("index") Then
                Dim ni As New Map
                ni.Add "type", "Index"
                ni.SetValue "base", IIf(b Is Nothing, expr.GetValue("base"), b)
                ni.SetValue "index", IIf(idx Is Nothing, expr.GetValue("index"), idx)
                Set NormalizeExprNodeRecursive = ni
                Exit Function
            End If
            Set NormalizeExprNodeRecursive = expr
            Exit Function
        Case "Array"
            Dim items As Collection: Set items = expr.GetValue("items")
            If Not items Is Nothing Then
                Dim newit As New Collection
                Dim ch As Boolean: ch = False
                Dim ii As Long
                For ii = 1 To items.count
                    Dim ei As Map: Set ei = NormalizeExprNodeRecursive(items(ii))
                    If Not ei Is items(ii) Then ch = True: newit.Add ei Else newit.Add items(ii)
                Next ii
                If ch Then
                    Dim na As New Map
                    na.Add "type", "Array"
                    na.SetValue "items", newit
                    Set NormalizeExprNodeRecursive = na
                    Exit Function
                End If
            End If
            Set NormalizeExprNodeRecursive = expr
            Exit Function
        Case Else
            Set NormalizeExprNodeRecursive = expr
            Exit Function
    End Select
End Function

Private Function NormalizeNodeRecursive(node As Map) As Map
    ' Normalize a statement node and recursively process inner blocks.
    If node Is Nothing Then
        Set NormalizeNodeRecursive = Nothing: Exit Function
    End If
    Dim expr As Map
    Dim left_ As Map
    Dim a As Map
    Dim r As Map
    Dim newExpr As Map
    Dim ns As Map
    Dim cond As Map
    Dim thenBlk As Collection
    Dim outThen As Collection
    Dim elseifConds As Collection
    Dim elseifBlocks As Collection
    Dim outElseIfConds As Collection
    Dim outElseIfBlocks As Collection
    Dim eb As Collection
    Dim nb As Collection
    Dim elseBlk As Collection
    Dim outElse As Collection
    Dim nif As Map
    Dim initNode As Map
    Dim condNode As Map
    Dim stepNode As Map
    Dim body As Collection
    Dim nInit As Map, nCond As Map, nStep As Map
    Dim na As Map
    Dim l As Map
    Dim e As Map
    Dim L2 As Map
    Dim na2 As Map
    Dim SL As Map
    Dim na3 As Map
    Dim newBody As Collection
    Dim nf As Map
    Dim cnd As Map
    Dim bdy As Collection
    Dim nbdy As Collection
    Dim nw As Map
    Dim tryBlk As Collection
    Dim catchBlk As Collection
    Dim nt As Collection, nc As Collection
    Dim ntc As Map
    Dim cases As Collection
    Dim ncases As Collection
    Dim pair As Collection
    Dim caseExpr As Map
    Dim blockStmts As Collection
    Dim newPair As Collection
    Dim def As Collection
    Dim ndef As Collection
    Dim nsw As Map
    Dim leftA As Map
    Dim rightA As Map
    Dim naNode As Map
    Dim tp As String: tp = node.GetValue("type")
    Select Case tp
        Case "ExprStmt"
            Set expr = node.GetValue("expr")
            ' If expression is a Binary "=" with assignable LHS, convert to Assign node.
            If Not expr Is Nothing Then
                If expr.GetValue("type") = "Binary" Then
                    If CStr(expr.GetValue("op")) = "=" Then
                        Set left_ = expr.GetValue("left")
                        If Not left_ Is Nothing Then
                            If IsAssignableNode(left_) Then
                                a.Add "type", "Assign"
                                a.SetValue "left", left_
                                ' right: normalize recursively as expression
                                Set r = NormalizeExprNodeRecursive(expr.GetValue("right"))
                                If r Is Nothing Then Set r = expr.GetValue("right")
                                a.SetValue "right", r
                                Set NormalizeNodeRecursive = a
                                Exit Function
                            End If
                        End If
                    End If
                End If
            End If
            ' otherwise just normalize inner expression (if any)
            If Not expr Is Nothing Then
                Set newExpr = NormalizeExprNodeRecursive(expr)
                If Not newExpr Is expr Then
                    Set ns = New Map
                    ns.Add "type", "ExprStmt"
                    ns.SetValue "expr", newExpr
                    Set NormalizeNodeRecursive = ns
                    Exit Function
                End If
            End If
            Set NormalizeNodeRecursive = node
            Exit Function

        Case "If"
            Set cond = NormalizeExprNodeRecursive(node.GetValue("cond"))
            Set thenBlk = node.GetValue("then")
            Dim i As Long
            If Not thenBlk Is Nothing Then
                Set outThen = New Collection
                For i = 1 To thenBlk.count
                    outThen.Add NormalizeNodeRecursive(thenBlk(i))
                Next i
            End If
            Set elseifConds = node.GetValue("elseif_conds")
            Set elseifBlocks = node.GetValue("elseif_blocks")
            Set outElseIfConds = New Collection
            Set outElseIfBlocks = New Collection
            If Not elseifConds Is Nothing Then
                For i = 1 To elseifConds.count
                    outElseIfConds.Add NormalizeExprNodeRecursive(elseifConds(i))
                Next i
            End If
            If Not elseifBlocks Is Nothing Then
                For i = 1 To elseifBlocks.count
                    Set eb = elseifBlocks(i)
                    Set nb = New Collection
                    Dim j As Long
                    For j = 1 To eb.count
                        nb.Add NormalizeNodeRecursive(eb(j))
                    Next j
                    outElseIfBlocks.Add nb
                Next i
            End If
            Set elseBlk = node.GetValue("else")
            If Not elseBlk Is Nothing Then
                Set outElse = New Collection
                For i = 1 To elseBlk.count
                    outElse.Add NormalizeNodeRecursive(elseBlk(i))
                Next i
            End If
            Set nif = New Map
            nif.Add "type", "If"
            nif.SetValue "cond", IIf(cond Is Nothing, node.GetValue("cond"), cond)
            nif.SetValue "then", outThen
            nif.SetValue "elseif_conds", outElseIfConds
            nif.SetValue "elseif_blocks", outElseIfBlocks
            nif.SetValue "hasElse", node.GetValue("hasElse")
            If Not outElse Is Nothing Then nif.SetValue "else", outElse
            Set NormalizeNodeRecursive = nif
            Exit Function

        Case "For"
            ' normalize init/cond/step and body
            Set initNode = node.GetValue("init")
            Set condNode = node.GetValue("cond")
            Set stepNode = node.GetValue("step")
            Set body = node.GetValue("body")
            If Not initNode Is Nothing Then
                If initNode.GetValue("type") = "Binary" And CStr(initNode.GetValue("op")) = "=" Then
                    Set l = initNode.GetValue("left")
                    If Not l Is Nothing And IsAssignableNode(l) Then
                        Set na = New Map
                        na.Add "type", "Assign"
                        na.SetValue "left", l
                        na.SetValue "right", NormalizeExprNodeRecursive(initNode.GetValue("right"))
                        Set nInit = na
                    Else
                        Set nInit = NormalizeExprNodeRecursive(initNode)
                    End If
                ElseIf initNode.GetValue("type") = "ExprStmt" Then
                    ' exprstmt could wrap a binary expression
                    Set e = initNode.GetValue("expr")
                    If Not e Is Nothing And e.GetValue("type") = "Binary" And CStr(e.GetValue("op")) = "=" Then
                        Set L2 = e.GetValue("left")
                        If Not L2 Is Nothing And IsAssignableNode(L2) Then
                            Set na2 = New Map
                            na2.Add "type", "Assign"
                            na2.SetValue "left", L2
                            na2.SetValue "right", NormalizeExprNodeRecursive(e.GetValue("right"))
                            Set nInit = na2
                        Else
                            Set nInit = NormalizeExprNodeRecursive(e)
                        End If
                    Else
                        Set nInit = NormalizeExprNodeRecursive(e)
                    End If
                Else
                    Set nInit = NormalizeExprNodeRecursive(initNode)
                End If
            End If
            If Not condNode Is Nothing Then Set nCond = NormalizeExprNodeRecursive(condNode)
            If Not stepNode Is Nothing Then
                If stepNode.GetValue("type") = "Binary" And CStr(stepNode.GetValue("op")) = "=" Then
                    Set SL = stepNode.GetValue("left")
                    If Not SL Is Nothing And IsAssignableNode(SL) Then
                        Set na3 = New Map
                        na3.Add "type", "Assign"
                        na3.SetValue "left", SL
                        na3.SetValue "right", NormalizeExprNodeRecursive(stepNode.GetValue("right"))
                        Set nStep = na3
                    Else
                        Set nStep = NormalizeExprNodeRecursive(stepNode)
                    End If
                Else
                    Set nStep = NormalizeExprNodeRecursive(stepNode)
                End If
            End If
            Set newBody = New Collection
            If Not body Is Nothing Then
                Dim bidx As Long
                For bidx = 1 To body.count
                    newBody.Add NormalizeNodeRecursive(body(bidx))
                Next bidx
            End If
            Set nf = New Map
            nf.Add "type", "For"
            If Not nInit Is Nothing Then nf.SetValue "init", nInit
            If Not nCond Is Nothing Then nf.SetValue "cond", nCond
            If Not nStep Is Nothing Then nf.SetValue "step", nStep
            nf.SetValue "body", newBody
            Set NormalizeNodeRecursive = nf
            Exit Function

        Case "While"
            Set cnd = NormalizeExprNodeRecursive(node.GetValue("cond"))
            Set bdy = node.GetValue("body")
            Set nbdy = New Collection
            If Not bdy Is Nothing Then
                Dim bi As Long
                For bi = 1 To bdy.count
                    nbdy.Add NormalizeNodeRecursive(bdy(bi))
                Next bi
            End If
            Set nw = New Map
            nw.Add "type", "While"
            nw.SetValue "cond", IIf(cnd Is Nothing, node.GetValue("cond"), cnd)
            nw.SetValue "body", nbdy
            Set NormalizeNodeRecursive = nw
            Exit Function

        Case "TryCatch"
            Set tryBlk = node.GetValue("try")
            Set catchBlk = node.GetValue("catch")
            Set nt = New Collection: Set nc = New Collection
            Dim ti As Long
            If Not tryBlk Is Nothing Then
                For ti = 1 To tryBlk.count
                    nt.Add NormalizeNodeRecursive(tryBlk(ti))
                Next ti
            End If
            If Not catchBlk Is Nothing Then
                For ti = 1 To catchBlk.count
                    nc.Add NormalizeNodeRecursive(catchBlk(ti))
                Next ti
            End If
            Set ntc = New Map
            ntc.Add "type", "TryCatch"
            ntc.SetValue "try", nt
            ntc.SetValue "catch", nc
            Set NormalizeNodeRecursive = ntc
            Exit Function

        Case "Switch"
            Set cases = node.GetValue("cases")
            Set ncases = New Collection
            If Not cases Is Nothing Then
                Dim ci As Long
                For ci = 1 To cases.count
                    Set pair = cases(ci)
                    Set caseExpr = NormalizeExprNodeRecursive(pair(1))
                    Set blockStmts = pair(2)
                    Set nb = New Collection
                    Dim bi2 As Long
                    For bi2 = 1 To blockStmts.count
                        nb.Add NormalizeNodeRecursive(blockStmts(bi2))
                    Next bi2
                    Set newPair = New Collection
                    newPair.Add caseExpr
                    newPair.Add nb
                    ncases.Add newPair
                Next ci
            End If
            Set def = node.GetValue("default")
            If Not def Is Nothing Then
                Set ndef = New Collection
                Dim di As Long
                For di = 1 To def.count
                    ndef.Add NormalizeNodeRecursive(def(di))
                Next di
            End If
            Set nsw = New Map
            nsw.Add "type", "Switch"
            nsw.SetValue "expr", NormalizeExprNodeRecursive(node.GetValue("expr"))
            nsw.SetValue "cases", ncases
            If Not ndef Is Nothing Then nsw.SetValue "default", ndef
            Set NormalizeNodeRecursive = nsw
            Exit Function

        Case Else
            ' Assign, Print, Return, Break, Continue, etc. often have expr fields to normalize.
            If node.GetValue("type") = "Assign" Then
                Set leftA = node.GetValue("left")
                Set rightA = NormalizeExprNodeRecursive(node.GetValue("right"))
                Set naNode = New Map
                naNode.Add "type", "Assign"
                naNode.SetValue "left", leftA
                naNode.SetValue "right", IIf(rightA Is Nothing, node.GetValue("right"), rightA)
                Set NormalizeNodeRecursive = naNode
                Exit Function
            End If
            Set NormalizeNodeRecursive = node
            Exit Function
    End Select
End Function

Private Function NormalizeAssignsInStmts(stmts As Collection) As Collection
    Dim out As New Collection
    If stmts Is Nothing Then
        Set NormalizeAssignsInStmts = out: Exit Function
    End If
    Dim i As Long
    Dim n As Map
    For i = 1 To stmts.count
        Set n = stmts(i)
        out.Add NormalizeNodeRecursive(n)
    Next i
    Set NormalizeAssignsInStmts = out
End Function

' ---------------------
' Normalize collapsed identifiers into Member/Index AST nodes
' ---------------------

' Entry: apply collapsed-ident normalization for each stmt in a statements collection
Private Function NormalizeCollapsedIdentsInStmts(stmts As Collection) As Collection
    Dim out As New Collection
    If stmts Is Nothing Then
        Set NormalizeCollapsedIdentsInStmts = out: Exit Function
    End If
    Dim i As Long
    For i = 1 To stmts.count
        out.Add NormalizeCollapsedIdentsInNode(stmts(i))
    Next i
    Set NormalizeCollapsedIdentsInStmts = out
End Function

' Normalize any collapsed identifiers inside a statement node (recurses into expressions)
Private Function NormalizeCollapsedIdentsInNode(node As Map) As Map
    If node Is Nothing Then Set NormalizeCollapsedIdentsInNode = Nothing: Exit Function
    Dim tp As String: tp = CStr(node.GetValue("type"))
    Dim M As Map
    Set M = node.Clone

    Select Case tp
        Case "Assign"
            Dim leftN As Map: Set leftN = M.GetValue("left")
            Dim rightN As Map: Set rightN = M.GetValue("right")
            If Not leftN Is Nothing Then M.SetValue "left", NormalizeCollapsedIdentsInExpr(leftN)
            If Not rightN Is Nothing Then M.SetValue "right", NormalizeCollapsedIdentsInExpr(rightN)
            Set NormalizeCollapsedIdentsInNode = M
            Exit Function

        Case "Print"
            Dim argsP As Collection: Set argsP = M.GetValue("args")
            If Not argsP Is Nothing Then
                Dim outArgsP As New Collection, ai As Long
                For ai = 1 To argsP.count
                    outArgsP.Add NormalizeCollapsedIdentsInExpr(argsP(ai))
                Next ai
                M.SetValue "args", outArgsP
            End If
            Set NormalizeCollapsedIdentsInNode = M
            Exit Function

        Case "If"
            If M.Exists("cond") Then M.SetValue "cond", NormalizeCollapsedIdentsInExpr(M.GetValue("cond"))
            If M.Exists("thenStmts") Then
                Dim tcol As Collection: Set tcol = M.GetValue("thenStmts")
                M.SetValue "thenStmts", NormalizeCollapsedIdentsInStmts(tcol)
            End If
            If M.Exists("elseStmts") Then
                Dim ecol As Collection: Set ecol = M.GetValue("elseStmts")
                M.SetValue "elseStmts", NormalizeCollapsedIdentsInStmts(ecol)
            End If
            Set NormalizeCollapsedIdentsInNode = M
            Exit Function

        Case "While", "For"
            If M.Exists("cond") Then M.SetValue "cond", NormalizeCollapsedIdentsInExpr(M.GetValue("cond"))
            If M.Exists("init") Then
                If Not M.GetValue("init") Is Nothing Then M.SetValue "init", NormalizeCollapsedIdentsInNode(M.GetValue("init"))
            End If
            If M.Exists("step") Then
                If Not M.GetValue("step") Is Nothing Then M.SetValue "step", NormalizeCollapsedIdentsInExpr(M.GetValue("step"))
            End If
            If M.Exists("body") Then M.SetValue "body", NormalizeCollapsedIdentsInStmts(M.GetValue("body"))
            Set NormalizeCollapsedIdentsInNode = M
            Exit Function

        Case "Switch"
            If M.Exists("expr") Then M.SetValue "expr", NormalizeCollapsedIdentsInExpr(M.GetValue("expr"))
            If M.Exists("cases") Then
                Dim cs As Collection: Set cs = M.GetValue("cases")
                Dim nc As New Collection, ci As Long
                For ci = 1 To cs.count
                    Dim pair As Map: Set pair = cs(ci)
                    Dim caseVal As Map: Set caseVal = pair.GetValue(1)
                    Dim stmts As Collection: Set stmts = pair.GetValue(2)
                    Dim newPair As New Collection
                    newPair.Add NormalizeCollapsedIdentsInExpr(caseVal)
                    newPair.Add NormalizeCollapsedIdentsInStmts(stmts)
                    nc.Add newPair
                Next ci
                M.SetValue "cases", nc
            End If
            If M.Exists("default") Then M.SetValue "default", NormalizeCollapsedIdentsInStmts(M.GetValue("default"))
            Set NormalizeCollapsedIdentsInNode = M
            Exit Function

        Case "Return"
            If M.Exists("expr") Then M.SetValue "expr", NormalizeCollapsedIdentsInExpr(M.GetValue("expr"))
            Set NormalizeCollapsedIdentsInNode = M
            Exit Function

        Case Else
            ' Fallback: for statements carrying expression fields, attempt to normalize them conservatively:
            If M.Exists("expr") Then M.SetValue "expr", NormalizeCollapsedIdentsInExpr(M.GetValue("expr"))
            Set NormalizeCollapsedIdentsInNode = M
            Exit Function
    End Select
End Function

' Recursively normalize expression nodes (Variable -> Member/Index when collapsed)
Private Function NormalizeCollapsedIdentsInExpr(node As Map) As Map
    If node Is Nothing Then Set NormalizeCollapsedIdentsInExpr = Nothing: Exit Function
    Dim tp As String: tp = CStr(node.GetValue("type"))

    Select Case tp
        Case "Variable"
            Dim nm As String: nm = CStr(node.GetValue("name"))
            If InStr(nm, ".") > 0 Or InStr(nm, "[") > 0 Then
                ' convert collapsed name into nested AST (Member/Index) using helper
                Set NormalizeCollapsedIdentsInExpr = ParseCollapsedIdentToNode(nm)
            Else
                Set NormalizeCollapsedIdentsInExpr = node
            End If
            Exit Function

        Case "Binary"
            Dim l As Map: Set l = NormalizeCollapsedIdentsInExpr(node.GetValue("left"))
            Dim r As Map: Set r = NormalizeCollapsedIdentsInExpr(node.GetValue("right"))
            Dim b As Map: Set b = node.Clone
            If Not l Is Nothing Then b.SetValue "left", l
            If Not r Is Nothing Then b.SetValue "right", r
            Set NormalizeCollapsedIdentsInExpr = b
            Exit Function

        Case "Unary"
            Dim ue As Map: Set ue = NormalizeCollapsedIdentsInExpr(node.GetValue("expr"))
            Dim um As Map: Set um = node.Clone
            If Not ue Is Nothing Then um.SetValue "expr", ue
            Set NormalizeCollapsedIdentsInExpr = um
            Exit Function

        Case "Ternary"
            Dim c As Map: Set c = NormalizeCollapsedIdentsInExpr(node.GetValue("cond"))
            Dim t As Map: Set t = NormalizeCollapsedIdentsInExpr(node.GetValue("trueExpr"))
            Dim f As Map: Set f = NormalizeCollapsedIdentsInExpr(node.GetValue("falseExpr"))
            Dim tm As Map: Set tm = node.Clone
            If Not c Is Nothing Then tm.SetValue "cond", c
            If Not t Is Nothing Then tm.SetValue "trueExpr", t
            If Not f Is Nothing Then tm.SetValue "falseExpr", f
            Set NormalizeCollapsedIdentsInExpr = tm
            Exit Function

        Case "Call"
            Dim cal As Map: Set cal = Nothing
            If node.Exists("callee") Then Set cal = NormalizeCollapsedIdentsInExpr(node.GetValue("callee"))
            Dim args As New Collection
            If node.Exists("args") Then
                Dim ac As Collection: Set ac = node.GetValue("args")
                Dim ai As Long
                For ai = 1 To ac.count
                    args.Add NormalizeCollapsedIdentsInExpr(ac(ai))
                Next ai
            End If
            Dim cn As Map: Set cn = node.Clone
            If Not cal Is Nothing Then cn.SetValue "callee", cal
            If args.count > 0 Then cn.SetValue "args", args
            Set NormalizeCollapsedIdentsInExpr = cn
            Exit Function

        Case "Array"
            Dim items As Collection: Set items = node.GetValue("items")
            If Not items Is Nothing Then
                Dim outItems As New Collection, ii As Long
                For ii = 1 To items.count
                    outItems.Add NormalizeCollapsedIdentsInExpr(items(ii))
                Next ii
                Dim an As Map: Set an = node.Clone
                an.SetValue "items", outItems
                Set NormalizeCollapsedIdentsInExpr = an
            Else
                Set NormalizeCollapsedIdentsInExpr = node
            End If
            Exit Function

        Case "Index"
            Dim baseN As Map: Set baseN = NormalizeCollapsedIdentsInExpr(node.GetValue("base"))
            Dim idxn As Map: Set idxn = NormalizeCollapsedIdentsInExpr(node.GetValue("index"))
            Dim inn As Map: Set inn = node.Clone
            If Not baseN Is Nothing Then inn.SetValue "base", baseN
            If Not idxn Is Nothing Then inn.SetValue "index", idxn
            Set NormalizeCollapsedIdentsInExpr = inn
            Exit Function

        Case "Member"
            Dim bn As Map: Set bn = NormalizeCollapsedIdentsInExpr(node.GetValue("base"))
            Dim mm As Map: Set mm = node.Clone
            If Not bn Is Nothing Then mm.SetValue "base", bn
            Set NormalizeCollapsedIdentsInExpr = mm
            Exit Function

        Case Else
            Set NormalizeCollapsedIdentsInExpr = node
            Exit Function
    End Select
End Function

' Parse a collapsed identifier string like "o.x[2].y" into nested Member/Index/Variable AST nodes.
Private Function ParseCollapsedIdentToNode(path As String) As Map
    Dim pos As Long: pos = 1
    Dim nLen As Long: nLen = Len(path)
    Dim curName As String: curName = ""
    ' read first identifier/segment
    Do While pos <= nLen
        Dim ch As String: ch = Mid$(path, pos, 1)
        If ch = "." Or ch = "[" Then Exit Do
        curName = curName & ch
        pos = pos + 1
    Loop
    Dim baseNode As Map
    Set baseNode = MakeNode("Variable")
    baseNode.SetValue "name", Trim$(curName)
    Dim current As Map: Set current = baseNode

    Do While pos <= nLen
        Dim cch As String: cch = Mid$(path, pos, 1)
        If cch = "." Then
            ' property access
            pos = pos + 1
            Dim propName As String: propName = ""
            Do While pos <= nLen
                Dim c2 As String: c2 = Mid$(path, pos, 1)
                If c2 = "." Or c2 = "[" Then Exit Do
                propName = propName & c2
                pos = pos + 1
            Loop
            Dim mnode As Map: Set mnode = MakeNode("Member")
            mnode.SetValue "base", current
            mnode.SetValue "prop", Trim$(propName)
            Set current = mnode
        ElseIf cch = "[" Then
            ' bracket index: find closing ']'
            pos = pos + 1
            Dim startPos As Long: startPos = pos
            Dim depthB As Long: depthB = 1
            Dim inner As String: inner = ""
            Do While pos <= nLen And depthB > 0
                Dim cc As String: cc = Mid$(path, pos, 1)
                If cc = "[" Then
                    depthB = depthB + 1
                    inner = inner & cc
                    pos = pos + 1
                ElseIf cc = "]" Then
                    depthB = depthB - 1
                    If depthB = 0 Then
                        pos = pos + 1
                        Exit Do
                    Else
                        inner = inner & cc
                        pos = pos + 1
                    End If
                Else
                    inner = inner & cc
                    pos = pos + 1
                End If
            Loop
            ' parse inner expression into AST node
            Dim idxExpr As Map
            Set idxExpr = ParseExprFromStringToNode(inner)
            Dim inode As Map: Set inode = MakeNode("Index")
            inode.SetValue "base", current
            inode.SetValue "index", idxExpr
            Set current = inode
        Else
            ' unknown char: advance to avoid infinite loop
            pos = pos + 1
        End If
    Loop

    Set ParseCollapsedIdentToNode = current
End Function

' -------------------- emitter helpers --------------------
Private Sub EmitterInit()
    Set m_codesCol = New Collection
    Set m_argsCol = New Collection
    Set m_symbolMap = New Map
    m_nextSlot = 1
    m_progTempCounter = 0
    Set m_loopStack = New Collection
End Sub

Private Sub EnsureProgramsCollections()
    On Error Resume Next
    If (Not IsObject(GLOBALS_.gProgramsBytecode)) Then
        Dim tmpc As New Collection: Set GLOBALS_.gProgramsBytecode = tmpc
    End If
    If (Not IsObject(GLOBALS_.gProgramsSymbols)) Then
        Dim tmpc2 As New Collection: Set GLOBALS_.gProgramsSymbols = tmpc2
    End If
    On Error GoTo 0
End Sub

Private Sub EmitterFinishStore(progIdx As Long)
    Dim n As Long: n = 0
    If Not m_codesCol Is Nothing Then n = m_codesCol.count
    Dim codes() As Long
    If n = 0 Then
        ReDim codes(1 To 1)
        codes(1) = OP_RETURN
    Else
        ReDim codes(1 To n)
        Dim i As Long
        For i = 1 To n
            codes(i) = CLng(m_codesCol(i))
        Next i
    End If

    Dim M As Long: M = 0
    If Not m_argsCol Is Nothing Then M = m_argsCol.count
    Dim argsArr() As Variant
    If M = 0 Then
        ReDim argsArr(1 To 1)
        argsArr(1) = Empty
    Else
        ReDim argsArr(1 To M)
        For i = 1 To M
            vAssignment argsArr(i), m_argsCol(i)
        Next i
    End If

    ' Ensure we always have a Map for symbols (so VM can rely on it existing)
    If m_symbolMap Is Nothing Then
        Set m_symbolMap = New Map
    End If

    ' Compute slot count: number of reserved numeric slots (m_nextSlot - 1)
    Dim slotCount As Long
    If m_nextSlot <= 1 Then
        slotCount = 0
    Else
        slotCount = m_nextSlot - 1
    End If

    ' Write slot count into symbol map under a stable key (defensive)
    On Error Resume Next
    If m_symbolMap.Exists("__slot_count") Then
        m_symbolMap.SetValue "__slot_count", slotCount
    Else
        m_symbolMap.Add "__slot_count", slotCount
    End If
    On Error GoTo 0

    ' build a Map to hold compact bytecode for program
    Dim bcMap As New Map
    bcMap.Add "codes", codes
    bcMap.SetValue "args", argsArr
    bcMap.SetValue "symbols", m_symbolMap

    ' ensure globals collections exist and store program bytecode & symbols
    EnsureProgramsCollections
    GLOBALS_.gProgramsBytecode.Add bcMap
    GLOBALS_.gProgramsSymbols.Add m_symbolMap

    ' cleanup emitter state
    Set m_codesCol = Nothing
    Set m_argsCol = Nothing
    Set m_symbolMap = Nothing
    m_nextSlot = 0
    m_progTempCounter = 0
    Set m_loopStack = Nothing
' --- TEMP: human readable bytecode dump for debugging ---
If IsObject(GLOBALS_.gRuntimeLog) Then
    Dim opNames As Object: Set opNames = CreateObject("Scripting.Dictionary")
    opNames.Add 0, "OP_NOP": opNames.Add 1, "OP_PUSH_CONST": opNames.Add 2, "OP_LOAD_FAST"
    opNames.Add 3, "OP_STORE_FAST": opNames.Add 4, "OP_LOAD_NAME": opNames.Add 5, "OP_STORE_NAME"
    opNames.Add 6, "OP_BINARY": opNames.Add 7, "OP_MAKE_ARRAY": opNames.Add 8, "OP_PRINT"
    opNames.Add 9, "OP_POP": opNames.Add 10, "OP_JUMP": opNames.Add 11, "OP_JUMP_IF_FALSE"
    opNames.Add 12, "OP_PUSH_AST_NODE": opNames.Add 13, "OP_LOAD_MEMBER_KEEP_BASE": opNames.Add 14, "OP_MEMBER_SET"
    opNames.Add 15, "OP_INDEX_GET": opNames.Add 16, "OP_INDEX_SET": opNames.Add 17, "OP_BUILTIN_FAST"
    opNames.Add 18, "OP_CALL": opNames.Add 19, "OP_CALL_FUNC": opNames.Add 20, "OP_CALL_FUNC_WITH_THIS"
    opNames.Add 21, "OP_RETURN"
    ' include our optionally added ops if present
    On Error Resume Next
    opNames.Add 22, "OP_MEMBER_OF_VALUE": opNames.Add 23, "OP_LOAD_MEMBER_FROM_VALUE_KEEP_BASE"
    On Error GoTo 0

    Dim readable As String: readable = "BYTECODE_READABLE: "
    Dim iop As Long
    For iop = 1 To UBound(codes)
        Dim codeNum As Long: codeNum = CLng(codes(iop))
        Dim opname As String
        If opNames.Exists(codeNum) Then opname = opNames(codeNum) Else opname = "OP_" & CStr(codeNum)
        Dim opd As String
        If opname = "" Then
            opd = "?"
        Else
            opd = TypeName(argsArr(iop))
        End If
        If VarType(argsArr(iop)) = vbString Then
            opd = """" & CStr(argsArr(iop)) & """"
        ElseIf IsArray(argsArr(iop)) Then
            opd = "Array()"
        Else
            opd = CStr(argsArr(iop))
        End If
        readable = readable & opname & "(" & opd & ") "
    Next iop
    GLOBALS_.gRuntimeLog.Add readable
End If
' --- end TEMP dump ---
End Sub

Private Sub EmitOp(opcode As Long, operand As Variant)
    m_codesCol.Add opcode
    m_argsCol.Add operand
End Sub

' Patch the operand index i (1-based) with newOperand
Private Sub PatchOperandAt(idx As Long, newOperand As Variant)
    Dim tmp As New Collection, i As Long
    For i = 1 To m_argsCol.count
        If i = idx Then
            tmp.Add newOperand
        Else
            tmp.Add m_argsCol(i)
        End If
    Next i
    Do While m_argsCol.count > 0
        m_argsCol.Remove 1
    Loop
    For i = 1 To tmp.count
        m_argsCol.Add tmp(i)
    Next i
End Sub

' Symbol/slot helpers
Private Function RegisterSlotForName(name As String) As Long
    If m_symbolMap.Exists(name) Then
        RegisterSlotForName = CLng(m_symbolMap.GetValue(name))
    Else
        m_symbolMap.SetValue name, m_nextSlot
        RegisterSlotForName = m_nextSlot
        m_nextSlot = m_nextSlot + 1
    End If
End Function

Private Function GetSlotIfExists(name As String) As Long
    If m_symbolMap.Exists(name) Then GetSlotIfExists = CLng(m_symbolMap.GetValue(name)) Else GetSlotIfExists = 0
End Function

Private Function CreateTempSlot() As Long
    m_progTempCounter = m_progTempCounter + 1
    Dim tName As String: tName = "__switch_temp_" & CStr(m_progTempCounter)
    CreateTempSlot = RegisterSlotForName(tName)
End Function

' Loop stack functions (for break/continue patching)
Private Sub PushLoop(startOp As Long, continueOp As Long, endOp As Long)
    Dim M As New Map
    M.Add "start", startOp
    M.SetValue "continue", continueOp
    M.SetValue "end", endOp
    Dim breaks As New Collection, conts As New Collection
    M.SetValue "breaks", breaks
    M.SetValue "conts", conts
    m_loopStack.Add M
End Sub

Private Sub PopLoop()
    If m_loopStack.count > 0 Then m_loopStack.Remove m_loopStack.count
End Sub

Private Function TopLoop() As Map
    If m_loopStack.count = 0 Then
        Set TopLoop = Nothing
    Else
        Set TopLoop = m_loopStack(m_loopStack.count)
    End If
End Function
' Return True if the node represents an addressable base (a variable or a chain of Members
' ultimately rooted in a Variable). This excludes Index, Call, Literal, Array, Object, VBExpr, etc.
Private Function IsAddressableBase(node As Map) As Boolean
    If node Is Nothing Then
        IsAddressableBase = False
        Exit Function
    End If
    On Error GoTo err_
    Dim t As String: t = CStr(node.GetValue("type"))
    Select Case t
        Case "Variable"
            IsAddressableBase = True: Exit Function
        Case "Member"
            ' walk the base chain until we either find a Variable (addressable) or something else
            Dim cur As Map: Set cur = node
            Do While Not cur Is Nothing
                Dim ct As String: ct = CStr(cur.GetValue("type"))
                If ct = "Variable" Then
                    IsAddressableBase = True: Exit Function
                ElseIf ct = "Member" Then
                    Set cur = cur.GetValue("base")
                Else
                    ' any other kind of node breaks addressability
                    IsAddressableBase = False: Exit Function
                End If
            Loop
            IsAddressableBase = False
            Exit Function
        Case Else
            IsAddressableBase = False: Exit Function
    End Select
    Exit Function
err_:
    IsAddressableBase = False
End Function

' -------------------- conservative symbol scanner --------------------
Private Sub ScanNodeForSymbolsForEmit(node As Map)
    If node Is Nothing Then Exit Sub
    On Error Resume Next
    Dim t As String: t = CStr(node.GetValue("type"))
    Dim items As Collection
    Dim tmpMap As Map
    On Error GoTo 0
    Select Case t
        Case "Variable"
            Dim nm As String: nm = CStr(node.GetValue("name"))
            If Not m_symbolMap.Exists(nm) Then
                m_symbolMap.SetValue nm, m_nextSlot
                m_nextSlot = m_nextSlot + 1
            End If
        Case "Assign"
            ScanNodeForSymbolsForEmit node.GetValue("left")
            ScanNodeForSymbolsForEmit node.GetValue("right")
        Case "Call"
            ScanNodeForSymbolsForEmit node.GetValue("callee")
            Dim args As Collection: Set args = node.GetValue("args")
            If Not args Is Nothing Then
                Dim j As Long
                For j = 1 To args.count
                    ScanNodeForSymbolsForEmit args(j)
                Next j
            End If
        Case "Binary"
            ScanNodeForSymbolsForEmit node.GetValue("left")
            ScanNodeForSymbolsForEmit node.GetValue("right")
        Case "Unary"
            ScanNodeForSymbolsForEmit node.GetValue("expr")
        Case "Ternary"
            ScanNodeForSymbolsForEmit node.GetValue("cond")
            ScanNodeForSymbolsForEmit node.GetValue("trueExpr")
            ScanNodeForSymbolsForEmit node.GetValue("falseExpr")
        Case "Array"
            Set items = node.GetValue("items")
            If Not items Is Nothing Then
                Dim k As Long
                For k = 1 To items.count
                    ScanNodeForSymbolsForEmit items(k)
                Next k
            End If
        Case "Index"
            ScanNodeForSymbolsForEmit node.GetValue("base")
            ScanNodeForSymbolsForEmit node.GetValue("index")
        Case "Member"
            ScanNodeForSymbolsForEmit node.GetValue("base")
        Case "For"
            ScanNodeForSymbolsForEmit node.GetValue("init")
            ScanNodeForSymbolsForEmit node.GetValue("cond")
            ScanNodeForSymbolsForEmit node.GetValue("step")
            Dim bodyF As Collection: Set bodyF = node.GetValue("body")
            If Not bodyF Is Nothing Then
                Dim x As Long
                For x = 1 To bodyF.count
                    ScanNodeForSymbolsForEmit bodyF(x)
                Next x
            End If
        Case "While"
            ScanNodeForSymbolsForEmit node.GetValue("cond")
            Dim bodyW As Collection: Set bodyW = node.GetValue("body")
            If Not bodyW Is Nothing Then
                Dim y As Long
                For y = 1 To bodyW.count
                    ScanNodeForSymbolsForEmit bodyW(y)
                Next y
            End If
        Case "Switch"
            ScanNodeForSymbolsForEmit node.GetValue("expr")
            Dim cases As Collection: Set cases = node.GetValue("cases")
            If Not cases Is Nothing Then
                Dim z As Long
                For z = 1 To cases.count
                    Dim c As Map
                    Set c = cases(z)
                    ScanNodeForSymbolsForEmit c.GetValue("value")
                    Dim st As Collection: Set st = c.GetValue("stmts")
                    If Not st Is Nothing Then
                        Dim w As Long
                        For w = 1 To st.count
                            ScanNodeForSymbolsForEmit st(w)
                        Next w
                    End If
                Next z
            End If
        Case "Object"
            ' Object literal: visit each property's value (don't register property names as symbols)
            ' canonical shapes: "props", "pairs", "items"
            Dim propsCol As Collection
            On Error Resume Next
            If node.Exists("props") Then
                Set propsCol = node.GetValue("props")
            ElseIf node.Exists("pairs") Then
                Set propsCol = node.GetValue("pairs")
            ElseIf node.Exists("items") Then
                Set propsCol = node.GetValue("items")
            End If
            On Error GoTo 0

            If Not propsCol Is Nothing Then
                Dim pi As Long
                For pi = 1 To propsCol.count
                    Dim pair As Variant: vAssignment pair, propsCol(pi)
                    ' pair may be Map {key, value} or 2-element array/collection
                    If TypeName(pair) = "Map" Then
                        If pair.Exists("value") Then
                            ScanNodeForSymbolsForEmit pair.GetValue("value")
                        Else
                            ' try some common indices/fields
                            On Error Resume Next
                            ScanNodeForSymbolsForEmit pair.GetValue(2)
                            On Error GoTo 0
                        End If
                    ElseIf TypeName(pair) = "Collection" Then
                        ' assume (key, value)
                        vAssignment tmpMap, pair(2)
                        If pair.count >= 2 Then ScanNodeForSymbolsForEmit tmpMap
                    ElseIf IsArray(pair) Then
                        vAssignment tmpMap, pair(1)
                        On Error Resume Next
                        If UBound(pair) >= 1 Then ScanNodeForSymbolsForEmit tmpMap
                        On Error GoTo 0
                    End If
                Next pi
            End If
        Case Else
            ' conservative - ignore other nodes
    End Select
End Sub

' -------------------- expression emission --------------------
Private Sub EmitExprBytecode(node As Map)
    If node Is Nothing Then
        Exit Sub
    End If

    Dim baseNode As Map
    Dim propKey As String
    Dim propName As String
    Dim ai As Long
    Dim ci As Long
    Dim idxNode As Map
    Dim litVal As Variant
    Dim tVar As Variant
    tVar = Empty

    On Error Resume Next
    vAssignment tVar, node.GetValue("type")
    On Error GoTo 0

    If IsEmpty(tVar) Then
        Exit Sub
    End If

    Dim t As String
    t = CStr(tVar)

    Select Case t

        Case "Literal"
            litVal = Empty
            On Error Resume Next
            vAssignment litVal, node.GetValue("value")
            On Error GoTo 0
            EmitOp OP_PUSH_CONST, litVal

        Case "Variable"
            Dim vnameVar As Variant
            vnameVar = Empty
            On Error Resume Next
            vAssignment vnameVar, node.GetValue("name")
            On Error GoTo 0

            If Not IsEmpty(vnameVar) Then
                Dim vname As String
                vname = CStr(vnameVar)
                Dim slotIdx As Long
                slotIdx = GetSlotIfExists(vname)
                If slotIdx > 0 Then
                    EmitOp OP_LOAD_FAST, slotIdx
                Else
                    EmitOp OP_LOAD_NAME, vname
                End If
            Else
                EmitOp OP_LOAD_NAME, ""
            End If

        Case "Binary"
            Dim leftN As Map
            Dim rightN As Map
            Set leftN = Nothing
            Set rightN = Nothing
            On Error Resume Next
            vAssignment leftN, node.GetValue("left")
            vAssignment rightN, node.GetValue("right")
            On Error GoTo 0
            If Not leftN Is Nothing Then EmitExprBytecode leftN
            If Not rightN Is Nothing Then EmitExprBytecode rightN
            Dim opVar As Variant
            opVar = Empty
            On Error Resume Next
            vAssignment opVar, node.GetValue("op")
            On Error GoTo 0
            EmitOp OP_BINARY, CStr(opVar)

        Case "Unary"
            Dim opuVar As Variant
            opuVar = Empty
            On Error Resume Next
            vAssignment opuVar, node.GetValue("op")
            On Error GoTo 0
            If Not IsEmpty(opuVar) Then
                If CStr(opuVar) = "-" Then
                    EmitOp OP_PUSH_CONST, 0
                    Dim exprN As Map
                    Set exprN = Nothing
                    On Error Resume Next
                    vAssignment exprN, node.GetValue("expr")
                    On Error GoTo 0
                    If Not exprN Is Nothing Then EmitExprBytecode exprN
                    EmitOp OP_BINARY, "-"
                Else
                    Dim exprN2 As Map
                    Set exprN2 = Nothing
                    On Error Resume Next
                    vAssignment exprN2, node.GetValue("expr")
                    On Error GoTo 0
                    If Not exprN2 Is Nothing Then EmitExprBytecode exprN2
                End If
            End If

        Case "Array"
            Dim items As Collection
            Set items = Nothing
            On Error Resume Next
            vAssignment items, node.GetValue("items")
            On Error GoTo 0
            If Not items Is Nothing Then
                Dim ii As Long
                For ii = 1 To items.count
                    EmitExprBytecode items(ii)
                Next ii
                EmitOp OP_MAKE_ARRAY, items.count
            Else
                EmitOp OP_MAKE_ARRAY, 0
            End If

        Case "Ternary"
            Dim condN As Map
            Dim trueN As Map
            Dim falseN As Map
            Set condN = Nothing
            Set trueN = Nothing
            Set falseN = Nothing
            On Error Resume Next
            vAssignment condN, node.GetValue("cond")
            vAssignment trueN, node.GetValue("trueExpr")
            vAssignment falseN, node.GetValue("falseExpr")
            On Error GoTo 0

            If Not condN Is Nothing Then EmitExprBytecode condN
            EmitOp OP_JUMP_IF_FALSE, Empty
            Dim jfArgIdx As Long
            jfArgIdx = m_argsCol.count
            If Not trueN Is Nothing Then EmitExprBytecode trueN
            EmitOp OP_JUMP, Empty
            Dim jaArgIdx As Long
            jaArgIdx = m_argsCol.count
            PatchOperandAt jfArgIdx, m_codesCol.count + 1
            If Not falseN Is Nothing Then EmitExprBytecode falseN
            PatchOperandAt jaArgIdx, m_codesCol.count + 1

        Case "Call"
            ' Prepare callee info
            Dim calleeNode As Map
            Set calleeNode = Nothing
            On Error Resume Next
            vAssignment calleeNode, node.GetValue("callee")
            On Error GoTo 0

            Dim nameIsVar As Boolean
            nameIsVar = False
            Dim calleeVarName As String
            calleeVarName = ""

            If Not calleeNode Is Nothing Then
                Dim ctypeVar As Variant
                ctypeVar = Empty
                On Error Resume Next
                vAssignment ctypeVar, calleeNode.GetValue("type")
                On Error GoTo 0
                If Not IsEmpty(ctypeVar) Then
                    If CStr(ctypeVar) = "Variable" Then
                        Dim cnVar As Variant
                        cnVar = Empty
                        On Error Resume Next
                        vAssignment cnVar, calleeNode.GetValue("name")
                        On Error GoTo 0
                        If Not IsEmpty(cnVar) Then
                            nameIsVar = True
                            calleeVarName = CStr(cnVar)
                        End If
                    End If
                End If
            End If

            Dim argColl As Collection
            Set argColl = Nothing
            On Error Resume Next
            vAssignment argColl, node.GetValue("args")
            On Error GoTo 0
            Dim nArgs As Long
            nArgs = 0
            If Not argColl Is Nothing Then nArgs = argColl.count

            Dim cvals As Collection
            Set cvals = Nothing
            If node.Exists("const_args") Then
                On Error Resume Next
                vAssignment cvals, node.GetValue("const_args")
                On Error GoTo 0
                If Not cvals Is Nothing Then nArgs = cvals.count
            End If

            ' If callee is a Member -> this is a member-call. Emit base first, then load member keeping base.
            Dim calleeTypeChk As Variant
            calleeTypeChk = Empty
            If Not calleeNode Is Nothing Then
                On Error Resume Next
                vAssignment calleeTypeChk, calleeNode.GetValue("type")
                On Error GoTo 0
            End If

            If Not IsEmpty(calleeTypeChk) Then
                If CStr(calleeTypeChk) = "Member" Then
                    ' Emit base first (push base onto stack)
                    Dim baseN As Map
                    Set baseN = Nothing
                    On Error Resume Next
                    vAssignment baseN, calleeNode.GetValue("base")
                    On Error GoTo 0
                    If Not baseN Is Nothing Then
                        EmitExprBytecode baseN
                    End If

                    ' Build member operand (propName, rootSlot, path, indexVal)
                    Dim memOp As Variant
                    memOp = BuildMemberOperand(calleeNode)

                    ' Emit op that will pop the base-produced value and push [ base, methodVal ] (keeps base)
                    EmitOp OP_LOAD_MEMBER_FROM_VALUE_KEEP_BASE, memOp

                    ' Push arguments left->right (consts or evaluated)
                    If Not cvals Is Nothing Then
                        Dim cj As Long
                        For cj = 1 To cvals.count
                            EmitOp OP_PUSH_CONST, cvals(cj)
                        Next cj
                    ElseIf Not argColl Is Nothing Then
                        Dim bk As Long
                        For bk = 1 To argColl.count
                            EmitExprBytecode argColl(bk)
                        Next bk
                    End If

                    ' Emit CALL with member flag true (so VM will pop args, callee, then this)
                    EmitOp OP_CALL, Array(nArgs, node, True)
                    Exit Sub
                End If
            End If

            ' Non-member call generic logic (try fast-path compiled functions by variable name)
            On Error Resume Next
            If nameIsVar Then
                If IsObject(GLOBALS_.gFuncTable) Then
                    If GLOBALS_.gFuncTable.Exists(calleeVarName) Then
                        Dim fIdxVar As Variant
                        fIdxVar = GLOBALS_.gFuncTable.GetValue(calleeVarName)
                        If Not IsEmpty(fIdxVar) Then
                            If Not cvals Is Nothing Then
                                Dim cii As Long
                                For cii = 1 To cvals.count
                                    EmitOp OP_PUSH_CONST, cvals(cii)
                                Next cii
                            ElseIf Not argColl Is Nothing Then
                                Dim aii As Long
                                For aii = 1 To argColl.count
                                    EmitExprBytecode argColl(aii)
                                Next aii
                            End If
                            EmitOp OP_CALL_FUNC, Array(CLng(fIdxVar), nArgs)
                            Exit Sub
                        End If
                    End If
                End If
            End If
            On Error GoTo 0

            ' Generic fallback: emit callee then args then CALL (no member flag)
            If Not calleeNode Is Nothing Then EmitExprBytecode calleeNode

            If Not cvals Is Nothing Then
                Dim cxx As Long
                For cxx = 1 To cvals.count
                    EmitOp OP_PUSH_CONST, cvals(cxx)
                Next cxx
                EmitOp OP_CALL, Array(cvals.count, node)
            ElseIf Not argColl Is Nothing Then
                Dim bx2 As Long
                For bx2 = 1 To argColl.count
                    EmitExprBytecode argColl(bx2)
                Next bx2
                EmitOp OP_CALL, Array(argColl.count, node)
            Else
                EmitOp OP_CALL, Array(0, node)
            End If

        Case "Member"
            ' For simple member expressions (non-call) we want to evaluate base then produce only the property value.
            ' For member calls the Call() handler above takes care of base+method+args.
            Set baseNode = Nothing
            On Error Resume Next
            vAssignment baseNode, node.GetValue("base")
            On Error GoTo 0

            propKey = IIf(node.Exists("prop"), "prop", "property")

            Dim pval As Variant
            pval = Empty
            On Error Resume Next
            vAssignment pval, node.GetValue(propKey)
            On Error GoTo 0
            propName = ""
            If Not IsEmpty(pval) Then
                propName = CStr(pval)
            End If

            ' Build operand consistent shape
            Dim opnd As Variant
            opnd = BuildMemberOperand(node)

            ' Emit base first (always)
            If Not baseNode Is Nothing Then
                EmitExprBytecode baseNode
            Else
                If IsObject(GLOBALS_.gRuntimeLog) Then
                    GLOBALS_.gRuntimeLog.Add "EMIT-WARN: Member missing base for property " & propName
                End If
            End If

            ' For simple property read we only want the property value -> use OP_MEMBER_OF_VALUE (pops base and returns value)
            EmitOp OP_MEMBER_OF_VALUE, opnd

        Case "Index"
            Set baseNode = Nothing
            Set idxNode = Nothing
            On Error Resume Next
            vAssignment baseNode, node.GetValue("base")
            vAssignment idxNode, node.GetValue("index")
            On Error GoTo 0

            ' Emit base then index (preserve evaluation order)
            If Not baseNode Is Nothing Then EmitExprBytecode baseNode
            If Not idxNode Is Nothing Then EmitExprBytecode idxNode

            ' Build index operand metadata and always emit it (consistent operand shape)
            Dim idxOp As Variant
            idxOp = BuildIndexOperand(node)
            EmitOp OP_INDEX_GET, idxOp

        Case Else
            EmitOp OP_PUSH_AST_NODE, node

    End Select
End Sub

Private Sub EmitStmtBytecode(stmt As Map)
    If stmt Is Nothing Then
        Exit Sub
    End If

    Dim tVar As Variant
    tVar = Empty
    On Error Resume Next
    vAssignment tVar, stmt.GetValue("type")
    On Error GoTo 0
    If IsEmpty(tVar) Then
        Exit Sub
    End If
    Dim t As String
    t = CStr(tVar)

    Select Case t

        Case "ExprStmt"
            Dim exprE As Map
            Set exprE = Nothing
            On Error Resume Next
            vAssignment exprE, stmt.GetValue("expr")
            On Error GoTo 0
            If Not exprE Is Nothing Then EmitExprBytecode exprE
            EmitOp OP_POP, Empty

        Case "Print"
            Dim args As Collection
            Set args = Nothing
            On Error Resume Next
            vAssignment args, stmt.GetValue("args")
            On Error GoTo 0
            If Not args Is Nothing Then
                Dim ip As Long
                For ip = 1 To args.count
                    EmitExprBytecode args(ip)
                Next ip
                EmitOp OP_PRINT, args.count
            Else
                EmitOp OP_PRINT, 0
            End If

        Case "Assign"
            Dim leftN As Map
            Dim rightN As Map
            Set leftN = Nothing
            Set rightN = Nothing
            On Error Resume Next
            vAssignment leftN, stmt.GetValue("left")
            vAssignment rightN, stmt.GetValue("right")
            On Error GoTo 0

            Dim assignOp As String
            assignOp = "="
            If stmt.Exists("op") Then
                Dim tmpop As Variant
                tmpop = Empty
                On Error Resume Next
                vAssignment tmpop, stmt.GetValue("op")
                On Error GoTo 0
                If Not IsEmpty(tmpop) Then assignOp = CStr(tmpop)
            End If
            If stmt.Exists("compoundOp") Then
                Dim tmpc As Variant
                tmpc = Empty
                On Error Resume Next
                vAssignment tmpc, stmt.GetValue("compoundOp")
                On Error GoTo 0
                If Not IsEmpty(tmpc) Then assignOp = CStr(tmpc)
            End If

            Dim isCompound As Boolean
            isCompound = (assignOp <> "=")
            Dim binOp As String
            binOp = ""
            If isCompound Then
                If right$(assignOp, 1) = "=" Then
                    binOp = left$(assignOp, Len(assignOp) - 1)
                Else
                    binOp = assignOp
                End If
            End If

            ' Variable assignment
            If Not leftN Is Nothing Then
                Dim leftTypeVar As Variant
                leftTypeVar = Empty
                On Error Resume Next
                vAssignment leftTypeVar, leftN.GetValue("type")
                On Error GoTo 0

                If Not IsEmpty(leftTypeVar) Then
                    If CStr(leftTypeVar) = "Variable" Then
                        Dim leftNameVar As Variant
                        leftNameVar = Empty
                        On Error Resume Next
                        vAssignment leftNameVar, leftN.GetValue("name")
                        On Error GoTo 0
                        Dim leftName As String
                        leftName = ""
                        If Not IsEmpty(leftNameVar) Then leftName = CStr(leftNameVar)

                        Dim sidx As Long
                        sidx = GetSlotIfExists(leftName)

                        If Not isCompound Then
                            EmitExprBytecode rightN
                            If sidx > 0 Then
                                EmitOp OP_STORE_FAST, sidx
                            Else
                                EmitOp OP_STORE_NAME, leftName
                            End If
                        Else
                            If sidx > 0 Then
                                EmitOp OP_LOAD_FAST, sidx
                            Else
                                EmitOp OP_LOAD_NAME, leftName
                            End If
                            EmitExprBytecode rightN
                            EmitOp OP_BINARY, binOp
                            If sidx > 0 Then
                                EmitOp OP_STORE_FAST, sidx
                            Else
                                EmitOp OP_STORE_NAME, leftName
                            End If
                        End If

                    ElseIf CStr(leftTypeVar) = "Member" Then
                        ' Member assignment (simple or compound). Build rich operand.
                        Dim baseN As Map
                        Set baseN = Nothing
                        On Error Resume Next
                        vAssignment baseN, leftN.GetValue("base")
                        On Error GoTo 0

                        Dim memberOpSet As Variant
                        memberOpSet = BuildMemberOperand(leftN)

                        If Not isCompound Then
                            ' Evaluate base (push base), then RHS, then MEMBER_SET (VM will pop rhs, base and write)
                            If Not baseN Is Nothing Then EmitExprBytecode baseN
                            EmitExprBytecode rightN
                            EmitOp OP_MEMBER_SET, memberOpSet
                        Else
                            ' Compound: load member keeping base, eval RHS, binary, member_set
                            If Not baseN Is Nothing Then EmitExprBytecode baseN
                            EmitOp OP_LOAD_MEMBER_KEEP_BASE, memberOpSet   ' pushes [ base, memberValue ]
                            EmitExprBytecode rightN
                            EmitOp OP_BINARY, binOp
                            EmitOp OP_MEMBER_SET, memberOpSet
                        End If

                    ElseIf CStr(leftTypeVar) = "Index" Then
                        ' Index assignment (LValue)
                        Dim baseI As Map
                        Dim idxI As Map
                        Set baseI = Nothing
                        Set idxI = Nothing
                        On Error Resume Next
                        vAssignment baseI, leftN.GetValue("base")
                        vAssignment idxI, leftN.GetValue("index")
                        On Error GoTo 0

                        Dim rhsN As Map
                        Set rhsN = Nothing
                        vAssignment rhsN, rightN

                        Dim idxSetOp As Variant
                        idxSetOp = BuildIndexOperand(leftN)

                        ' compound detection (conservative)
                        isCompound = False
                        binOp = ""
                        On Error Resume Next
                        If stmt.Exists("isCompound") Then
                            Dim tmpb As Variant
                            tmpb = Empty
                            vAssignment tmpb, stmt.GetValue("isCompound")
                            isCompound = CBool(tmpb)
                        End If
                        If stmt.Exists("op") Then
                            Dim tmpo As Variant
                            tmpo = Empty
                            vAssignment tmpo, stmt.GetValue("op")
                            If Not IsEmpty(tmpo) Then binOp = CStr(tmpo)
                        End If
                        On Error GoTo 0

                        Dim baseSlot As Long
                        baseSlot = 0
                        If Not baseI Is Nothing Then
                            Dim btype As Variant
                            btype = Empty
                            On Error Resume Next
                            vAssignment btype, baseI.GetValue("type")
                            On Error GoTo 0
                            If Not IsEmpty(btype) Then
                                If CStr(btype) = "Variable" Then
                                    Dim bn As Variant
                                    bn = Empty
                                    On Error Resume Next
                                    vAssignment bn, baseI.GetValue("name")
                                    On Error GoTo 0
                                    If Not IsEmpty(bn) Then baseSlot = GetSlotIfExists(CStr(bn))
                                End If
                            End If
                        End If

                        If Not isCompound Then
                            ' SIMPLE assignment: eval base,index,rhs in order and emit INDEX_SET with rich operand
                            If Not baseI Is Nothing Then EmitExprBytecode baseI
                            If Not idxI Is Nothing Then EmitExprBytecode idxI
                            If Not rhsN Is Nothing Then EmitExprBytecode rhsN
                            EmitOp OP_INDEX_SET, idxSetOp
                        Else
                            ' COMPOUND assignment: create temps to preserve order and do index-get / compute / index-set
                            Dim idxTempSlot As Long
                            idxTempSlot = CreateTempSlot()
                            Dim valTempSlot As Long
                            valTempSlot = CreateTempSlot()
                            Dim effectiveBaseSlot As Long
                            effectiveBaseSlot = baseSlot

                            ' Evaluate index first and store into idxTempSlot
                            If Not idxI Is Nothing Then EmitExprBytecode idxI
                            EmitOp OP_STORE_FAST, idxTempSlot

                            ' Ensure base is in a slot for final write-back
                            If effectiveBaseSlot = 0 Then
                                Dim baseTempSlot As Long
                                baseTempSlot = CreateTempSlot()
                                If Not baseI Is Nothing Then EmitExprBytecode baseI
                                EmitOp OP_STORE_FAST, baseTempSlot
                                effectiveBaseSlot = baseTempSlot
                            End If

                            ' Load base and idx to perform INDEX_GET (currentValue)
                            EmitOp OP_LOAD_FAST, effectiveBaseSlot
                            EmitOp OP_LOAD_FAST, idxTempSlot
                            EmitOp OP_INDEX_GET, Empty

                            ' Evaluate RHS and compute new value
                            If Not rhsN Is Nothing Then EmitExprBytecode rhsN
                            If Len(binOp) = 0 Then binOp = "+"
                            EmitOp OP_BINARY, binOp

                            ' store computed new value into valTempSlot
                            EmitOp OP_STORE_FAST, valTempSlot

                            ' Now load base, index, and new value
                            EmitOp OP_LOAD_FAST, effectiveBaseSlot
                            EmitOp OP_LOAD_FAST, idxTempSlot
                            EmitOp OP_LOAD_FAST, valTempSlot

                            ' Emit INDEX_SET with rich operand so VM can write back into appropriate root slot/path
                            EmitOp OP_INDEX_SET, idxSetOp
                        End If

                    Else
                        ' unknown LHS type: fallback to AST eval
                        EmitOp OP_PUSH_AST_NODE, leftN
                        EmitOp OP_POP, Empty
                    End If
                End If
            End If

        Case "If"
            Dim condNode As Map
            Set condNode = Nothing
            On Error Resume Next
            vAssignment condNode, stmt.GetValue("cond")
            On Error GoTo 0
            If Not condNode Is Nothing Then EmitExprBytecode condNode
            EmitOp OP_JUMP_IF_FALSE, Null
            Dim jfIdx As Long
            jfIdx = m_codesCol.count
            Dim thenStmts As Collection
            Set thenStmts = Nothing
            On Error Resume Next
            vAssignment thenStmts, stmt.GetValue("thenStmts")
            On Error GoTo 0
            If Not thenStmts Is Nothing Then
                Dim i2 As Long
                For i2 = 1 To thenStmts.count
                    EmitStmtBytecode thenStmts(i2)
                Next i2
            End If
            EmitOp OP_JUMP, Null
            Dim jaIdx As Long
            jaIdx = m_codesCol.count
            PatchOperandAt jfIdx + 1, m_codesCol.count + 1
            Dim elseStmts As Collection
            Set elseStmts = Nothing
            On Error Resume Next
            vAssignment elseStmts, stmt.GetValue("elseStmts")
            On Error GoTo 0
            If Not elseStmts Is Nothing Then
                Dim j2 As Long
                For j2 = 1 To elseStmts.count
                    EmitStmtBytecode elseStmts(j2)
                Next j2
            End If
            PatchOperandAt jaIdx + 1, m_codesCol.count + 1

        Case "While"
            Dim startPc As Long
            startPc = m_codesCol.count + 1
            Dim condW As Map
            Set condW = Nothing
            On Error Resume Next
            vAssignment condW, stmt.GetValue("cond")
            On Error GoTo 0
            If Not condW Is Nothing Then EmitExprBytecode condW
            EmitOp OP_JUMP_IF_FALSE, Null
            Dim whileJfIdx As Long
            whileJfIdx = m_codesCol.count
            PushLoop m_codesCol.count + 1, -1, -1
            Dim bodyStmts As Collection
            Set bodyStmts = Nothing
            On Error Resume Next
            vAssignment bodyStmts, stmt.GetValue("body")
            On Error GoTo 0
            If Not bodyStmts Is Nothing Then
                Dim bsi As Long
                For bsi = 1 To bodyStmts.count
                    EmitStmtBytecode bodyStmts(bsi)
                Next bsi
            End If
            EmitOp OP_JUMP, startPc
            PatchOperandAt whileJfIdx + 1, m_codesCol.count + 1
            Dim topL As Map
            Set topL = TopLoop()
            If Not topL Is Nothing Then
                topL.SetValue "end", m_codesCol.count + 1
                Dim brk As Collection
                Dim bi As Long
                Set brk = topL.GetValue("breaks")
                For bi = 1 To brk.count
                    PatchOperandAt brk(bi), topL.GetValue("end")
                Next bi
            End If
            PopLoop

        Case "For"
            If Not stmt.GetValue("init") Is Nothing Then EmitStmtBytecode stmt.GetValue("init")
            Dim startPcF As Long
            startPcF = m_codesCol.count + 1
            Dim condF As Map
            Set condF = Nothing
            On Error Resume Next
            vAssignment condF, stmt.GetValue("cond")
            On Error GoTo 0
            If Not condF Is Nothing Then EmitExprBytecode condF
            EmitOp OP_JUMP_IF_FALSE, Null
            Dim forJfIdx As Long
            forJfIdx = m_codesCol.count
            PushLoop startPcF, -1, -1
            Dim bodyF As Collection
            Set bodyF = Nothing
            On Error Resume Next
            vAssignment bodyF, stmt.GetValue("body")
            On Error GoTo 0
            If Not bodyF Is Nothing Then
                Dim fbi As Long
                For fbi = 1 To bodyF.count
                    EmitStmtBytecode bodyF(fbi)
                Next fbi
            End If
            If Not stmt.GetValue("step") Is Nothing Then EmitExprBytecode stmt.GetValue("step")
            EmitOp OP_JUMP, startPcF
            PatchOperandAt forJfIdx + 1, m_codesCol.count + 1
            Dim topF As Map
            Set topF = TopLoop()
            If Not topF Is Nothing Then
                topF.SetValue "end", m_codesCol.count + 1
                Dim brs As Collection
                Dim bix As Long
                Set brs = topF.GetValue("breaks")
                For bix = 1 To brs.count
                    PatchOperandAt brs(bix), topF.GetValue("end")
                Next bix
            End If
            PopLoop

        Case "Break"
            If m_loopStack.count = 0 Then
                EmitOp OP_PUSH_AST_NODE, stmt
                EmitOp OP_POP, Empty
            Else
                EmitOp OP_JUMP, Null
                Dim idxJumpPos As Long
                idxJumpPos = m_codesCol.count
                Dim topL2 As Map
                Set topL2 = TopLoop()
                Dim brc As Collection
                Set brc = topL2.GetValue("breaks")
                brc.Add idxJumpPos + 1
                topL2.SetValue "breaks", brc
            End If

        Case "Continue"
            If m_loopStack.count = 0 Then
                EmitOp OP_PUSH_AST_NODE, stmt
                EmitOp OP_POP, Empty
            Else
                EmitOp OP_JUMP, Null
                Dim idxContPos As Long
                idxContPos = m_codesCol.count
                Dim topL3 As Map
                Set topL3 = TopLoop()
                Dim conts As Collection
                Set conts = topL3.GetValue("conts")
                conts.Add idxContPos + 1
                topL3.SetValue "conts", conts
            End If

        Case "Switch"
            Dim exprNode As Map
            Set exprNode = Nothing
            On Error Resume Next
            vAssignment exprNode, stmt.GetValue("expr")
            On Error GoTo 0

            Dim tempSlot As Long
            tempSlot = CreateTempSlot()
            If Not exprNode Is Nothing Then EmitExprBytecode exprNode
            EmitOp OP_STORE_FAST, tempSlot

            Dim cases As Collection
            Set cases = Nothing
            On Error Resume Next
            vAssignment cases, stmt.GetValue("cases")
            On Error GoTo 0

            Dim defaultStmts As Collection
            Set defaultStmts = Nothing

            Dim caseJumpPlaceholders As Collection
            Set caseJumpPlaceholders = New Collection

            If Not cases Is Nothing Then
                Dim ic As Long
                For ic = 1 To cases.count
                    Dim c As Map
                    Set c = cases(ic)
                    Dim isDef As Variant
                    isDef = Empty
                    On Error Resume Next
                    vAssignment isDef, c.GetValue("isDefault")
                    On Error GoTo 0
                    If Not IsEmpty(isDef) Then
                        If CBool(isDef) Then
                            vAssignment defaultStmts, c.GetValue("stmts")
                            GoTo ContinueForLabel
                        End If
                    End If

                    EmitOp OP_LOAD_FAST, tempSlot
                    Dim valueNode As Map
                    Set valueNode = Nothing
                    On Error Resume Next
                    vAssignment valueNode, c.GetValue("value")
                    On Error GoTo 0
                    If Not valueNode Is Nothing Then EmitExprBytecode valueNode
                    EmitOp OP_BINARY, "=="
                    EmitOp OP_JUMP_IF_FALSE, Null
                    Dim thisCaseJumpIdx As Long
                    thisCaseJumpIdx = m_codesCol.count
                    Dim st As Collection
                    Set st = Nothing
                    On Error Resume Next
                    vAssignment st, c.GetValue("stmts")
                    On Error GoTo 0
                    If Not st Is Nothing Then
                        Dim si As Long
                        For si = 1 To st.count
                            EmitStmtBytecode st(si)
                        Next si
                    End If
                    EmitOp OP_JUMP, Null
                    caseJumpPlaceholders.Add thisCaseJumpIdx + 1
ContinueForLabel:
                Next ic
            End If

            If Not defaultStmts Is Nothing Then
                Dim di As Long
                For di = 1 To defaultStmts.count
                    EmitStmtBytecode defaultStmts(di)
                Next di
            End If

            Dim endPos As Long
            endPos = m_codesCol.count + 1
            Dim cpi As Long
            For cpi = 1 To caseJumpPlaceholders.count
                PatchOperandAt caseJumpPlaceholders(cpi), endPos
            Next cpi

        Case "TryCatch"
            EmitOp OP_PUSH_AST_NODE, stmt
            EmitOp OP_POP, Empty

        Case "Return"
            If Not stmt.GetValue("expr") Is Nothing Then EmitExprBytecode stmt.GetValue("expr")
            EmitOp OP_RETURN, Empty

        Case Else
            EmitOp OP_PUSH_AST_NODE, stmt
            EmitOp OP_POP, Empty

    End Select
End Sub



' -------------------- public emission entry --------------------
Public Sub EmitCompactBytecodeForProgram(progIdx As Long, stmts As Collection)
    EmitterInit
    ' build conservative symbol table
    Dim i As Long
    For i = 1 To stmts.count
        ScanNodeForSymbolsForEmit stmts(i)
    Next i
    ' emit program statements
    For i = 1 To stmts.count
        EmitStmtBytecode stmts(i)
    Next i
    EmitOp OP_RETURN, Empty
    EmitterFinishStore progIdx
End Sub

Private Sub vAssignment(ByRef var As Variant, ByRef vValue As Variant)
    If IsObject(vValue) Then
        Set var = vValue
    Else
        var = vValue
    End If
End Sub
' Emit arguments in left->right order: either const_args (cvals) or argColl
Private Sub EmitPushArgs(argColl As Collection, cvals As Collection)
    Dim i As Long
    If Not cvals Is Nothing Then
        For i = 1 To cvals.count
            EmitOp OP_PUSH_CONST, cvals(i)
        Next i
    ElseIf Not argColl Is Nothing Then
        For i = 1 To argColl.count
            EmitExprBytecode argColl(i)
        Next i
    End If
End Sub
' Return Collection of property names from root->parent for a Member node.
' For a.b.c => returns Collection {"b"} (path from root to parent).
Private Function GetMemberPathToParent(node As Map) As Collection
    Dim parts As New Collection
    Dim cur As Map: Set cur = node
    On Error GoTo err_Handler
    Do While Not cur Is Nothing And CStr(cur.GetValue("type")) = "Member"
        Dim pk As String: pk = IIf(cur.Exists("prop"), "prop", "property")
        parts.Add CStr(cur.GetValue(pk))
        Set cur = cur.GetValue("base")
    Loop
    ' parts now [leaf, parent, ...] from leaf -> root; reverse it
    Dim rev As New Collection
    Dim i As Long
    For i = parts.count To 1 Step -1: rev.Add parts(i): Next i
    ' path to parent: exclude last element (the leaf property)
    If rev.count <= 1 Then
        Set GetMemberPathToParent = New Collection
        Exit Function
    End If
    Dim res As New Collection
    For i = 1 To rev.count - 1: res.Add rev(i): Next i
    Set GetMemberPathToParent = res
    Exit Function
err_Handler:
    Set GetMemberPathToParent = New Collection
End Function

' Walk member chain to find root variable slot (0 if none)
Private Function GetRootSlotForMember(node As Map) As Long
    On Error GoTo err_Handler
    Dim cur As Map: Set cur = node
    Do While Not cur Is Nothing
        Dim t As String: t = CStr(cur.GetValue("type"))
        If t = "Variable" Then
            Dim nm As String: nm = CStr(cur.GetValue("name"))
            GetRootSlotForMember = GetSlotIfExists(nm)
            Exit Function
        ElseIf t = "Member" Then
            Set cur = cur.GetValue("base")
        Else
            Exit Do
        End If
    Loop
    GetRootSlotForMember = 0
    Exit Function
err_Handler:
    GetRootSlotForMember = 0
End Function
' Return either Empty or Array(rootSlot As Long, rootName As String)
Private Function BuildIndexOperand(node As Map) As Variant
    Dim baseNode As Map
    Set baseNode = Nothing
    On Error Resume Next
    vAssignment baseNode, node.GetValue("base")
    On Error GoTo 0

    If baseNode Is Nothing Then
        BuildIndexOperand = Empty
        Exit Function
    End If

    Dim btypeVar As Variant
    btypeVar = Empty
    On Error Resume Next
    vAssignment btypeVar, baseNode.GetValue("type")
    On Error GoTo 0
    If IsEmpty(btypeVar) Then
        BuildIndexOperand = Empty
        Exit Function
    End If

    Dim rootSlot As Long
    rootSlot = 0
    Dim rootName As String
    rootName = ""

    If CStr(btypeVar) = "Variable" Then
        Dim bnVar As Variant
        bnVar = Empty
        On Error Resume Next
        vAssignment bnVar, baseNode.GetValue("name")
        On Error GoTo 0
        If Not IsEmpty(bnVar) Then
            rootName = CStr(bnVar)
            rootSlot = GetSlotIfExists(rootName)
        End If
    ElseIf CStr(btypeVar) = "Index" Then
        ' if inner base is a variable, capture its slot & name
        Dim innerBase As Map
        Set innerBase = Nothing
        On Error Resume Next
        vAssignment innerBase, baseNode.GetValue("base")
        On Error GoTo 0
        If Not innerBase Is Nothing Then
            Dim ibt As Variant
            ibt = Empty
            On Error Resume Next
            vAssignment ibt, innerBase.GetValue("type")
            On Error GoTo 0
            If Not IsEmpty(ibt) And CStr(ibt) = "Variable" Then
                Dim inVar As Variant
                inVar = Empty
                On Error Resume Next
                vAssignment inVar, innerBase.GetValue("name")
                On Error GoTo 0
                If Not IsEmpty(inVar) Then
                    rootName = CStr(inVar)
                    rootSlot = GetSlotIfExists(rootName)
                End If
            End If
        End If
    End If

    If rootSlot > 0 Or Len(rootName) > 0 Then
        BuildIndexOperand = Array(rootSlot, rootName)
    Else
        BuildIndexOperand = Empty
    End If
End Function

' Return either propName (String) or Array(propName, rootSlot, pathColl, indexValueOrEmpty)
Private Function BuildMemberOperand(node As Map) As Variant
    Dim propKey As String
    propKey = "prop"
    If Not node Is Nothing Then
        If Not node.Exists("prop") And node.Exists("property") Then propKey = "property"
    End If

    Dim propVal As Variant
    propVal = Empty
    On Error Resume Next
    vAssignment propVal, node.GetValue(propKey)
    On Error GoTo 0
    Dim propName As String
    propName = ""
    If Not IsEmpty(propVal) Then propName = CStr(propVal)

    ' find root slot (variable that roots the member chain) and path to parent
    Dim rootSlot As Long
    rootSlot = 0
    On Error Resume Next
    rootSlot = GetRootSlotForMember(node)
    On Error GoTo 0

    Dim pathColl As Collection
    Set pathColl = Nothing
    On Error Resume Next
    vAssignment pathColl, GetMemberPathToParent(node)
    On Error GoTo 0

    ' detect index literal under base (indexValue)
    Dim indexValue As Variant
    indexValue = Empty
    On Error Resume Next
    Dim baseNode As Map
    Set baseNode = Nothing
    vAssignment baseNode, node.GetValue("base")
    If Not baseNode Is Nothing Then
        Dim bt As Variant
        bt = Empty
        vAssignment bt, baseNode.GetValue("type")
        If Not IsEmpty(bt) Then
            If CStr(bt) = "Index" Then
                Dim idxNode As Map
                Set idxNode = Nothing
                vAssignment idxNode, baseNode.GetValue("index")
                If Not idxNode Is Nothing Then
                    Dim idxType As Variant
                    idxType = Empty
                    vAssignment idxType, idxNode.GetValue("type")
                    If Not IsEmpty(idxType) Then
                        If CStr(idxType) = "Literal" Then
                            Dim litVal As Variant
                            litVal = Empty
                            vAssignment litVal, idxNode.GetValue("value")
                            If IsNumeric(litVal) Then
                                indexValue = CLng(litVal)
                            End If
                        End If
                    End If
                End If
            End If
        End If
    End If
    On Error GoTo 0

    ' Decide return shape:
    ' - if we have *no* useful metadata, return the simple propName string (so emitter emits a string, not an empty Array)
    ' - otherwise return a 4-tuple array as expected by the VM
    Dim haveMeta As Boolean
    haveMeta = (rootSlot > 0) Or (Not pathColl Is Nothing) Or (Not IsEmpty(indexValue))

    If Len(propName) = 0 And Not haveMeta Then
        ' nothing meaningful
        BuildMemberOperand = Empty
    ElseIf Not haveMeta Then
        ' only name is meaningful -> return plain string
        BuildMemberOperand = CStr(propName)
    Else
        BuildMemberOperand = Array(CStr(propName), CLng(rootSlot), pathColl, indexValue)
    End If
End Function

' ---------------------
' End Compiler class
' ---------------------
