VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "VM"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
' Class Module: VM (AST executor)
Option Explicit
Private Const VTP_MAX_DEPTH As Long = 8    ' safety depth limit
Private Const VTP_MAX_ITEMS_INLINE As Long = 8 ' prefer inline for small containers
Private VERBOSE_ As Boolean
Private GLOBALS_ As Globals
Private OUTPUT__ As Variant

' Executes AST nodes produced by Compiler (AST).
' Uses Map node types and ScopeStack. Logs to gRuntimeLog.

Public Sub SetGlobals(aGlobals As Globals)
    Set GLOBALS_ = aGlobals
End Sub
Public Property Get OUTPUT_() As Variant
    vAssignment OUTPUT_, OUTPUT__
End Property
Public Property Get Verbose() As Boolean
    Verbose = VERBOSE_
End Property
Public Property Let Verbose(aValue As Boolean)
    VERBOSE_ = aValue
End Property

' Node helpers (Map-based)
Private Function MakeNode(nodeType As String) As Map
    Dim m As New Map
    m.Add "type", nodeType
    Set MakeNode = m
End Function

Public Sub RunProgramByIndex(idx As Long)
    GLOBALS_.ASF_InitGlobals
    If idx < 1 Or idx > GLOBALS_.gPrograms.Count Then Exit Sub
    Dim p As Variant: p = GLOBALS_.gPrograms(idx)
    Dim progName As String: progName = p(0)
    Dim stmts As Collection: Set stmts = p(1)
    Dim rawScope As Collection: Set rawScope = p(2)
    Dim progScope As New ScopeStack
    progScope.LoadRaw rawScope
    progScope.Push
    If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "RUN Program: " & progName
    Dim i As Long
    For i = 1 To stmts.Count
        Dim ctrl As String
        ctrl = ExecuteStmtNode(stmts(i), progScope)
        If ctrl = "RETURN" Then
            vAssignment OUTPUT__, progScope.GetValue("__return")
            Exit For
        End If
        If ctrl = "ERR" Then Exit For
    Next i
    progScope.Pop
End Sub

' Execute a statement node (Map). Return control signals: "", "BREAK", "CONTINUE", "RETURN", "ERR"
Private Function ExecuteStmtNode(node As Map, progScope As ScopeStack) As String
    On Error GoTo ErrHandler
    Dim tp As String: tp = node.GetValue("type")
    Dim rval As Variant
    Select Case tp
        Case "Print"
            Dim args As Collection: Set args = node.GetValue("args")
            Dim outParts As New Collection
            Dim i As Long
            For i = 1 To args.Count
                Dim v As Variant: vAssignment v, EvalExprNode(args(i), progScope)
                outParts.Add ValueToStringForPrint(v)
            Next i
            Dim sb As String: sb = ""
            For i = 1 To outParts.Count
                If i > 1 Then sb = sb & ", "
                sb = sb & outParts(i)
            Next i
            If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "PRINT:" & sb
            Debug.Print sb
            ExecuteStmtNode = ""
            Exit Function

        Case "Assign"
            Dim left As Map: Set left = node.GetValue("left")
            Dim right As Map: Set right = node.GetValue("right")
            vAssignment rval, EvalExprNode(right, progScope)
            HandleAssignment left, rval, progScope
            ExecuteStmtNode = ""
            Exit Function

        Case "ExprStmt"
            Dim res As Variant: res = EvalExprNode(node.GetValue("expr"), progScope)
            ExecuteStmtNode = ""
            Exit Function

        Case "If"
            ExecuteStmtNode = ExecIfNode(node, progScope)
            Exit Function

        Case "For"
            ExecuteStmtNode = ExecForNode(node, progScope)
            Exit Function

        Case "While"
            ExecuteStmtNode = ExecWhileNode(node, progScope)
            Exit Function

        Case "Break"
            ExecuteStmtNode = "BREAK": Exit Function
        Case "Continue"
            ExecuteStmtNode = "CONTINUE": Exit Function

        Case "Return"
            Dim rex As Map: Set rex = node.GetValue("expr")
            If Not rex Is Nothing Then vAssignment rval, EvalExprNode(rex, progScope) Else rval = Empty
            progScope.SetValue "__return", rval
            ExecuteStmtNode = "RETURN": Exit Function

        Case "TryCatch"
            ExecuteStmtNode = ExecTryCatchNode(node, progScope)
            Exit Function

        Case "Switch"
            ExecuteStmtNode = ExecSwitchNode(node, progScope)
            Exit Function

        Case Else
            ' unknown node type
            If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "Unknown statement node: " & tp
            ExecuteStmtNode = ""
            Exit Function
    End Select

ErrHandler:
    If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "VM statement error: " & err.Description
    err.Clear
    ExecuteStmtNode = "ERR"
End Function

' ---------------------
' Assignment helper (left node may be Variable or Index)
' ---------------------
Private Sub HandleAssignment(left As Map, rval As Variant, progScope As ScopeStack)
    Dim ltype As String: ltype = left.GetValue("type")
    If ltype = "Variable" Then
        ' store object/value in scope map (no Set here; vAssignment is used when moving to VB variables)
        progScope.SetValue left.GetValue("name"), rval
    ElseIf ltype = "Index" Then
        ' Evaluate base (should be variable) and index
        Dim baseNode As Map: Set baseNode = left.GetValue("base")
        Dim idxNode As Map: Set idxNode = left.GetValue("index")
        If baseNode.GetValue("type") = "Variable" Then
            Dim arrName As String: arrName = baseNode.GetValue("name")
            Dim idxV As Variant: idxV = EvalExprNode(idxNode, progScope)
            AssignToArray arrName, idxV, rval, progScope
        Else
            err.Raise vbObjectError + 6001, "VM.HandleAssignment", "Unsupported index assignment"
        End If
    ElseIf ltype = "Member" Then
        ' Member assignment: base.prop = value
        Dim baseNodeM As Map: Set baseNodeM = left.GetValue("base")
        Dim propName As String: propName = CStr(left.GetValue("prop"))
        ' Evaluate base to get the object (Map) instance
        Dim baseVal As Variant
        baseVal = EvalExprNode(baseNodeM, progScope)
        If TypeName(baseVal) = "Map" Then
            Dim baseMap As Map: Set baseMap = baseVal
            baseMap.SetValue propName, rval
        ElseIf IsEmpty(baseVal) Then
            ' If base is empty and baseNode is a Variable, create a new Map and assign
            If baseNodeM.GetValue("type") = "Variable" Then
                Dim newMap As New Map
                newMap.Add propName, rval
                progScope.SetValue baseNodeM.GetValue("name"), newMap
            Else
                err.Raise vbObjectError + 6003, "VM.HandleAssignment", "Cannot assign property to non-object base"
            End If
        Else
            err.Raise vbObjectError + 6004, "VM.HandleAssignment", "Cannot assign property to non-object base"
        End If
    Else
        err.Raise vbObjectError + 6002, "VM.HandleAssignment", "Invalid assignment target"
    End If
End Sub

' Reuse your AssignToArray logic
Private Sub AssignToArray(arrName As String, idxV As Variant, val As Variant, progScope As ScopeStack)
    Dim arr As Variant
    Dim pos As Long
    Dim UB As Long
    Dim lb As Long

    arr = progScope.GetValue(arrName)
    pos = CLng(idxV)
    If pos < 1 Then
        err.Raise vbObjectError + 5001, "VM.AssignToArray", "Invalid array index (must be >=1)"
    End If
    If Not IsArray(arr) Then
        If IsEmpty(arr) Then
            arr = Array()
        Else
            err.Raise vbObjectError + 5002, "VM.AssignToArray", "Not an array"
        End If
    End If
    UB = -1
    If IsArray(arr) Then
        UB = UBound(arr)
    End If
    If UB < 0 Then
        ReDim arr(1 To pos)
    Else
        lb = LBound(arr)
        If pos > (UB - lb + 1) Then
            ReDim Preserve arr(lb To lb + pos - 1)
        End If
    End If
    arr(LBound(arr) + pos - 1) = val
    progScope.SetValue arrName, arr
End Sub

' ---------------------
' ExecIfNode: Evaluate condition, then execute proper block
' ---------------------
Private Function ExecIfNode(node As Map, progScope As ScopeStack) As String
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    If IsTruthy(EvalExprNode(condNode, progScope)) Then
        Dim thenStmts As Collection: Set thenStmts = node.GetValue("then")
        Dim si As Long
        For si = 1 To thenStmts.Count
            Dim ctrl As String: ctrl = ExecuteStmtNode(thenStmts(si), progScope)
            If ctrl <> "" Then ExecIfNode = ctrl: Exit Function
        Next si
        ExecIfNode = ""
        Exit Function
    End If
    Dim elseifConds As Collection: Set elseifConds = node.GetValue("elseif_conds")
    Dim elseifBlocks As Collection: Set elseifBlocks = node.GetValue("elseif_blocks")
    Dim idx As Long
    For idx = 1 To elseifConds.Count
        If IsTruthy(EvalExprNode(elseifConds(idx), progScope)) Then
            Dim bl As Collection: Set bl = elseifBlocks(idx)
            Dim si2 As Long
            For si2 = 1 To bl.Count
                Dim ctrl2 As String: ctrl2 = ExecuteStmtNode(bl(si2), progScope)
                If ctrl2 <> "" Then ExecIfNode = ctrl2: Exit Function
            Next si2
            ExecIfNode = ""
            Exit Function
        End If
    Next idx
    If node.GetValue("hasElse") Then
        Dim els As Collection: Set els = node.GetValue("else")
        Dim ee As Long
        For ee = 1 To els.Count
            Dim ctrl3 As String: ctrl3 = ExecuteStmtNode(els(ee), progScope)
            If ctrl3 <> "" Then ExecIfNode = ctrl3: Exit Function
        Next ee
    End If
    ExecIfNode = ""
End Function

' ---------------------
' ExecForNode
' ---------------------
Private Function ExecForNode(node As Map, progScope As ScopeStack) As String
    Dim initNode As Map: Set initNode = node.GetValue("init")
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    Dim stepNode As Map: Set stepNode = node.GetValue("step")
    Dim body As Collection: Set body = node.GetValue("body")
    Dim condOk As Boolean
    
    If Not initNode Is Nothing Then
        Dim initType As String
        initType = initNode.GetValue("type")
        Select Case initType
            Case "Assign", "Print", "If", "For", "While", "TryCatch", "Switch", "Return", "Break", "Continue", "ExprStmt"
                ' Already a statement node  execute directly so side-effects happen.
                ExecuteStmtNode initNode, progScope
            Case Else
                ' Expression node  wrap into ExprStmt for side-effect evaluation.
                ExecuteStmtNode MakeNodeExprStmt(initNode), progScope
        End Select
    End If

ForStart:
    condOk = True
    If Not condNode Is Nothing Then
        condOk = IsTruthy(EvalExprNode(condNode, progScope))
    End If
    If Not condOk Then GoTo ForEnd

    Dim s As Long
    For s = 1 To body.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(body(s), progScope)
        If ctrl = "BREAK" Then GoTo ForEnd
        If ctrl = "CONTINUE" Then Exit For
        If ctrl = "RETURN" Or ctrl = "ERR" Then ExecForNode = ctrl: Exit Function
    Next s

    If Not stepNode Is Nothing Then
        Dim stepType As String
        stepType = stepNode.GetValue("type")
        Select Case stepType
            Case "Assign", "Print", "If", "For", "While", "TryCatch", "Switch", "Return", "Break", "Continue", "ExprStmt"
                ExecuteStmtNode stepNode, progScope
            Case Else
                ExecuteStmtNode MakeNodeExprStmt(stepNode), progScope
        End Select
    End If
    GoTo ForStart

ForEnd:
    ExecForNode = ""
End Function

' Helper to wrap an expression node into an ExprStmt node
Private Function MakeNodeExprStmt(expr As Map) As Map
    Dim m As Map: Set m = MakeNode("ExprStmt")
    m.SetValue "expr", expr
    Set MakeNodeExprStmt = m
End Function

' ---------------------
' ExecWhileNode
' ---------------------
Private Function ExecWhileNode(node As Map, progScope As ScopeStack) As String
    Dim condNode As Map: Set condNode = node.GetValue("cond")
    Dim body As Collection: Set body = node.GetValue("body")

WhileStart:
    If Not IsTruthy(EvalExprNode(condNode, progScope)) Then GoTo WhileEnd
    Dim i As Long
    For i = 1 To body.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(body(i), progScope)
        If ctrl = "BREAK" Then GoTo WhileEnd
        If ctrl = "CONTINUE" Then Exit For
        If ctrl = "RETURN" Or ctrl = "ERR" Then ExecWhileNode = ctrl: Exit Function
    Next i
    GoTo WhileStart

WhileEnd:
    ExecWhileNode = ""
End Function

' ---------------------
' ExecTryCatchNode
' ---------------------
Private Function ExecTryCatchNode(node As Map, progScope As ScopeStack) As String
    On Error GoTo TryErr
    Dim tryStmts As Collection: Set tryStmts = node.GetValue("try")
    Dim i As Long
    For i = 1 To tryStmts.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(tryStmts(i), progScope)
        If ctrl = "RETURN" Or ctrl = "ERR" Then
            ExecTryCatchNode = ctrl
            If ctrl = "ERR" Then GoTo TryErr
            Exit Function
        End If
    Next i
    ExecTryCatchNode = ""
    Exit Function

TryErr:
    err.Clear
    Dim catchStmts As Collection: Set catchStmts = node.GetValue("catch")
    If Not catchStmts Is Nothing Then
        Dim j As Long
        For j = 1 To catchStmts.Count
            Dim cctrl As String: cctrl = ExecuteStmtNode(catchStmts(j), progScope)
            If cctrl = "RETURN" Or cctrl = "ERR" Then ExecTryCatchNode = cctrl: Exit Function
        Next j
    End If
    ExecTryCatchNode = ""
End Function

' ---------------------
' ExecSwitchNode
' ---------------------
Private Function ExecSwitchNode(node As Map, progScope As ScopeStack) As String
    Dim switchVal As Variant: switchVal = EvalExprNode(node.GetValue("expr"), progScope)
    Dim cases As Collection: Set cases = node.GetValue("cases")
    Dim i As Long
    Dim match As Boolean
    For i = 1 To cases.Count
        Dim pair As Collection: Set pair = cases(i)
        Dim caseExpr As Map: Set caseExpr = pair(1)
        Dim blockStmts As Collection: Set blockStmts = pair(2)
        match = (EvalExprNode(caseExpr, progScope) = switchVal)
        If match Then
            Dim s As Long
            For s = 1 To blockStmts.Count
                Dim ctrl As String: ctrl = ExecuteStmtNode(blockStmts(s), progScope)
                If ctrl = "BREAK" Then ExecSwitchNode = "": Exit Function
                If ctrl = "RETURN" Or ctrl = "ERR" Then ExecSwitchNode = ctrl: Exit Function
            Next s
        End If
    Next i
    If Not match Then
        Dim defBlk As Collection: Set defBlk = node.GetValue("default")
        If Not defBlk Is Nothing Then
            Dim d As Long
            For d = 1 To defBlk.Count
                Dim ctrl2 As String: ctrl2 = ExecuteStmtNode(defBlk(d), progScope)
                If ctrl2 = "BREAK" Then ExecSwitchNode = "": Exit Function
                If ctrl2 = "RETURN" Or ctrl2 = "ERR" Then ExecSwitchNode = ctrl2: Exit Function
            Next d
        End If
    End If
    ExecSwitchNode = ""
End Function

Private Sub vAssignment(ByRef var As Variant, ByRef vValue As Variant)
    If IsObject(vValue) Then
        Set var = vValue
    Else
        var = vValue
    End If
End Sub
' ---------------------
' Expression evaluator: Evaluate Expr AST nodes to runtime values
' ---------------------
Private Function EvalExprNode(node As Map, progScope As ScopeStack) As Variant
    If node Is Nothing Then EvalExprNode = Empty: Exit Function
    Dim tp As String: tp = node.GetValue("type")
    Dim items As Collection
    Dim tmpResult As Variant
    Dim pi As Long
    Dim funcIdx As Long
    
    Select Case tp
        Case "FuncLiteral", "AnonFunc"
            ' Create closure (capture env by reference for shared-write closures)
            Dim cparams As Collection: vAssignment cparams, node.GetValue("params")
            Dim cbody As Collection: vAssignment cbody, node.GetValue("body")
            Dim cmap As New Map
            Dim envCopy As ScopeStack
            cmap.Add "type", "Closure"
            cmap.SetValue "params", cparams
            cmap.SetValue "body", cbody
            ' capture current scope reference (shared-write)
            Set envCopy = New ScopeStack
            envCopy.LoadRawByRef progScope.RawByRef
            cmap.SetValue "env", envCopy
            vAssignment tmpResult, cmap
            GoTo exitfun
        Case "VBEXPR"
            ' Forced VBAexpression node (from @(...)). The node stores the raw VB expression string in "expr".
            Dim rawVB As String: rawVB = node.GetValue("expr")
            vAssignment tmpResult, EvalVBExpressionWithScope(rawVB, progScope)
            GoTo exitfun
        Case "Object"
            ' Build and return a Map containing the evaluated properties
            Set items = node.GetValue("items")
            Dim om As New Map
            Dim valNode As Map
            Dim pair As Collection
            Dim key As String
            For pi = 1 To items.Count
                Set pair = items(pi)
                key = CStr(pair(1))
                Set valNode = pair(2)
                om.SetValue key, EvalExprNode(valNode, progScope)
            Next pi
            ' Return Map object (as Variant holding the object)
            vAssignment tmpResult, om
            GoTo exitfun
        Case "Literal"
            vAssignment tmpResult, node.GetValue("value")
            GoTo exitfun
        Case "Variable"
            ' Robust variable resolution:
            '  - return actual value from scope (covers closures stored as Map AST nodes)
            '  - if scope has no value, fallback to named functions table (gFuncTable)
            '  - optional fallback to gFuncObjects registry
            Dim vName As String: vName = CStr(node.GetValue("name"))
            Dim vVal As Variant
            vAssignment vVal, progScope.GetValue(vName)

            ' If scope contains a non-empty value, return it  this covers closures
            ' stored as Map/AST nodes (FuncLiteral/Closure/etc.).
            If Not IsEmpty(vVal) Then
                ' If it's a Map and looks like a function node, return as callable
                On Error Resume Next
                If TypeName(vVal) = "Map" Then
                    Dim maybeType As Variant
                    maybeType = Empty
                    On Error Resume Next
                    maybeType = vVal.GetValue("type")
                    On Error GoTo 0
                    If Not IsEmpty(maybeType) Then
                        Dim tt As String: tt = CStr(maybeType)
                        ' Common names for function-like AST nodes / closures:
                        If tt = "FuncLiteral" Or tt = "Function" Or tt = "Closure" Or tt = "AnonFunction" Then
                            vAssignment tmpResult, vVal
                            GoTo exitfun
                        End If
                    End If
                End If
                ' Not necessarily a function-like Map  still return stored value.
                vAssignment tmpResult, vVal
                GoTo exitfun
            End If

            ' Not in scope (or Empty). Fallback: named compiled function table.
            On Error Resume Next
            If GLOBALS_.gFuncTable.Exists(vName) Then
                Dim fIdxVal As Variant: fIdxVal = GLOBALS_.gFuncTable.GetValue(vName)
                On Error GoTo 0
                If Not IsEmpty(fIdxVal) Then
                    funcIdx = CLng(fIdxVal)

                    ' Build a Closure map with the shape CallClosure expects:
                    ' "type" = "Closure", "params" = Collection, "body" = Collection, "env" = ScopeStack
                    Dim closureMap As New Map
                    closureMap.Add "type", "Closure"

                    ' params: convert stored gFuncParams (likely an array) into a Collection
                    Dim paramsCol As Collection
                    Set paramsCol = New Collection
                    If GLOBALS_.gFuncParams.Exists(vName) Then
                        Dim paVar As Variant: paVar = GLOBALS_.gFuncParams.GetValue(vName)
                        If IsArray(paVar) Then
                            If ArrayIsInit(paVar) Then
                                For pi = LBound(paVar) To UBound(paVar)
                                    paramsCol.Add CStr(paVar(pi))
                                Next pi
                            Else
                                paramsCol.Add vbNullString
                            End If
                        ElseIf TypeName(paVar) = "Collection" Then
                            ' already a collection  copy it
                            Dim it As Variant
                            For Each it In paVar
                                paramsCol.Add it
                            Next it
                        End If
                    End If
                    closureMap.SetValue "params", paramsCol

                    ' body and env come from gPrograms(funcIdx)
                    Dim pinfo As Variant
                    On Error Resume Next
                    pinfo = GLOBALS_.gPrograms(funcIdx)
                    If err.Number <> 0 Then
                        err.Clear
                        ' fallback: no program info  return Empty
                        EvalExprNode = Empty
                        Exit Function
                    End If
                    On Error GoTo 0

                    ' pinfo layout: Array(name, stmtsCollection, rawScopeCollection)
                    Dim bodyStmts As Collection
                    Set bodyStmts = pinfo(1)
                    closureMap.SetValue "body", bodyStmts

                    ' env: create ScopeStack and LoadRaw with stored raw scope (so closure has env object)
                    Dim envScope As ScopeStack
                    Set envScope = New ScopeStack
                    envScope.LoadRawByRef progScope.RawByRef
                    Set pinfo(2) = envScope.RawByRef
                    closureMap.SetValue "env", envScope

                    ' optionally store a name/funcIdx for debugging
                    closureMap.SetValue "name", vName
                    closureMap.SetValue "funcIdx", funcIdx

                    vAssignment tmpResult, closureMap
                    GoTo exitfun
                End If
            End If
            On Error GoTo 0

            ' Defensive fallback: optional function-objects registry (NOT IMPLEMENTED YET).
'            On Error Resume Next
'            If Not (gFuncObjects Is Nothing) Then
'                If gFuncObjects.Exists(vName) Then
'                    EvalExprNode = gFuncObjects.GetValue(vName)
'                    On Error GoTo 0
'                    GoTo exitfun
'                End If
'            End If
'            On Error GoTo 0

            ' Not found  log to runtime log and return Empty
            If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "VM: Variable '" & vName & "' is undefined or not callable (returned Empty)."
            vAssignment tmpResult, Empty
            GoTo exitfun
        Case "Member"
            ' Member(base, prop)  evaluate base, then property access
            Dim baseExpr As Map: Set baseExpr = node.GetValue("base")
            Dim propStr As String: propStr = CStr(node.GetValue("prop"))
            Dim baseEvaluated As Variant
            baseEvaluated = EvalExprNode(baseExpr, progScope)
            ' special-case array length: if prop == "length" and base is array, return length
            If propStr = "length" Then
                If IsArray(baseEvaluated) Then
                    Dim ub2 As Long
                    ub2 = UBound(baseEvaluated)
                    If ub2 < LBound(baseEvaluated) Then
                        vAssignment tmpResult, 0
                    Else
                        vAssignment tmpResult, ub2 - LBound(baseEvaluated) + 1
                    End If
                    GoTo exitfun
                End If
            End If
            ' if base is Map, return stored property
            If TypeName(baseEvaluated) = "Map" Then
                Dim bm As Map: Set bm = baseEvaluated
                vAssignment tmpResult, bm.GetValue(propStr)
                GoTo exitfun
            End If
            ' otherwise no property -> Empty
            vAssignment tmpResult, Empty
            GoTo exitfun
        Case "Array"
            Set items = node.GetValue("items")
            If items.Count = 0 Then
                vAssignment tmpResult, Array()
                GoTo exitfun
            End If
            Dim a() As Variant
            ReDim a(1 To items.Count)
            Dim ii As Long
            For ii = 1 To items.Count
                a(ii) = EvalExprNode(items(ii), progScope)
            Next ii
            vAssignment tmpResult, a
            GoTo exitfun
        Case "Index"
            Dim base As Map: Set base = node.GetValue("base")
            Dim idxNode As Map: Set idxNode = node.GetValue("index")
            If base.GetValue("type") = "Variable" Then
                Dim arr As Variant: arr = progScope.GetValue(base.GetValue("name"))
                If Not IsArray(arr) Then vAssignment tmpResult, Empty: GoTo exitfun
                Dim pos As Long: pos = CLng(EvalExprNode(idxNode, progScope))
                vAssignment tmpResult, arr(LBound(arr) + pos - 1)
                GoTo exitfun
            Else
                vAssignment tmpResult, Empty: GoTo exitfun
            End If
        Case "Call"
            ' Call can be either:
            '  - Call with "name" (string) and args (legacy)
            '  - Call with "callee" (an expression node) and args
            '       (new: allows variable holding closures)
            Dim hasCalleeExpr As Boolean: hasCalleeExpr = False
            Dim calleeExpr As Map
            If node.Exists("callee") Then
                hasCalleeExpr = True
                Set calleeExpr = node.GetValue("callee")
            End If
            Dim fname As String: fname = vbNullString
            If Not hasCalleeExpr Then
                fname = node.GetValue("name")
            End If
            ' builtin length function
            If fname = ".__len__" Then
                Dim argn As Collection: Set argn = node.GetValue("args")
                Dim av As Variant: av = EvalExprNode(argn(1), progScope)
                If Not IsArray(av) Then
                    vAssignment tmpResult, 0
                Else
                    vAssignment tmpResult, UBound(av) - LBound(av) + 1
                End If
                GoTo exitfun
            End If

            Dim argsColl As Collection: Set argsColl = node.GetValue("args")
            Dim evaluated As Collection
            Set evaluated = New Collection
            Dim k As Long
            For k = 1 To argsColl.Count
                evaluated.Add EvalExprNode(argsColl(k), progScope)
            Next k

            If Not hasCalleeExpr Then
                ' named call (existing behavior + fallback to VBAexpressions)
                If GLOBALS_.gFuncTable.Exists(fname) Then
                    funcIdx = CLng(GLOBALS_.gFuncTable.GetValue(fname))
                    vAssignment tmpResult, CallFuncByIndex_AST(funcIdx, evaluated)
                Else
                    ' named but not internal -> try VBAexpressions function call
                    vAssignment tmpResult, EvalVBFunctionCall(fname, evaluated, progScope)
                End If
            Else
                ' dynamic callee: evaluate callee expression -> it must yield a closure map or call via VB
                Dim calleeVal As Variant: vAssignment calleeVal, EvalExprNode(calleeExpr, progScope)
                If TypeName(calleeVal) = "Map" Then
                    Dim cM As Map: Set cM = calleeVal
                    If cM.GetValue("type") = "Closure" Then
                        vAssignment tmpResult, CallClosure(cM, evaluated)
                    Else
                        ' not a closure -> fail gracefully
                        vAssignment tmpResult, Empty
                    End If
                Else
                    ' if calleeVal is string -> call via VBAexpressions
                    If VarType(calleeVal) = vbString Then
                        vAssignment tmpResult, EvalVBFunctionCall(CStr(calleeVal), evaluated, progScope)
                    Else
                        vAssignment tmpResult, Empty
                    End If
                End If
            End If
            GoTo exitfun

        Case "Unary"
            Dim op As String: op = node.GetValue("op")
            Dim ev As Variant: ev = EvalExprNode(node.GetValue("expr"), progScope)
            If op = "!" Then
                vAssignment tmpResult, Not IsTruthy(ev)
            ElseIf op = "-" Then
                vAssignment tmpResult, -CDbl(ev)
            Else
                vAssignment tmpResult, ev
            End If
            GoTo exitfun
        Case "Ternary"
            Dim cnd As Variant: cnd = EvalExprNode(node.GetValue("cond"), progScope)
            If IsTruthy(cnd) Then
                vAssignment tmpResult, EvalExprNode(node.GetValue("trueExpr"), progScope)
            Else
                vAssignment tmpResult, EvalExprNode(node.GetValue("falseExpr"), progScope)
            End If
            GoTo exitfun
        Case "Binary"
            Dim lop As Variant: lop = EvalExprNode(node.GetValue("left"), progScope)
            Dim rop As Variant
            Dim op2 As String: op2 = node.GetValue("op")
            If op2 = "&&" Then
                If Not IsTruthy(lop) Then vAssignment tmpResult, False: GoTo exitfun
                rop = EvalExprNode(node.GetValue("right"), progScope)
                vAssignment tmpResult, (IsTruthy(lop) And IsTruthy(rop))
                GoTo exitfun
            ElseIf op2 = "||" Then
                If IsTruthy(lop) Then vAssignment tmpResult, True: GoTo exitfun
                rop = EvalExprNode(node.GetValue("right"), progScope)
                vAssignment tmpResult, (IsTruthy(lop) Or IsTruthy(rop))
                GoTo exitfun
            Else
                rop = EvalExprNode(node.GetValue("right"), progScope)
                Select Case op2
                    Case "+"
                        vAssignment tmpResult, SafeAdd(lop, rop)
                    Case "-": vAssignment tmpResult, lop - rop
                    Case "*": vAssignment tmpResult, lop * rop
                    Case "/"
                        If rop = 0 Then err.Raise vbObjectError + 2001, "VM.EvalExprNode", "Division by zero" Else vAssignment tmpResult, lop / rop
                    Case "%": vAssignment tmpResult, lop Mod rop
                    Case "^": vAssignment tmpResult, lop ^ rop
                    Case "==", "=": vAssignment tmpResult, (lop = rop)
                    Case "!=": vAssignment tmpResult, (lop <> rop)
                    Case "<": vAssignment tmpResult, (lop < rop)
                    Case ">": vAssignment tmpResult, (lop > rop)
                    Case "<=": vAssignment tmpResult, (lop <= rop)
                    Case ">=": vAssignment tmpResult, (lop >= rop)
                    Case Else
                        vAssignment tmpResult, Empty
                End Select
                GoTo exitfun
            End If
    End Select

    vAssignment tmpResult, Empty
exitfun:
    vAssignment EvalExprNode, tmpResult
End Function

Private Function ReturnCollection(ByRef aColl As Variant) As Collection
    Set ReturnCollection = aColl
End Function
Private Function ArrayIsInit(aArray As Variant) As Boolean
    Dim UB As Long
    ArrayIsInit = True
    On Error GoTo err_handler
    UB = UBound(aArray)
    Exit Function
err_handler:
    err.Clear
    ArrayIsInit = False
End Function
' Call function program by index (AST). "args" is Collection of evaluated arg values.
Private Function CallFuncByIndex_AST(funcIdx As Long, args As Collection) As Variant
    Dim p As Variant: p = GLOBALS_.gPrograms(funcIdx)
    Dim rawScope As Collection: Set rawScope = p(2)
    Dim callScope As New ScopeStack
    Dim i As Long
    callScope.LoadRaw rawScope
    callScope.Push
    Dim fname As String: fname = p(0)
    ' set params from gFuncParams
    If GLOBALS_.gFuncParams.Exists(fname) Then
        Dim pa As Variant: pa = GLOBALS_.gFuncParams.GetValue(fname)
        For i = LBound(pa) To UBound(pa)
            If i - LBound(pa) + 1 <= args.Count Then
                callScope.SetValue CStr(pa(i)), args(i - LBound(pa) + 1)
            Else
                callScope.SetValue CStr(pa(i)), Empty
            End If
        Next i
    End If

    Dim stmts As Collection: Set stmts = p(1)
    For i = 1 To stmts.Count
        Dim ctrl As String: ctrl = ExecuteStmtNode(stmts(i), callScope)
        If ctrl = "RETURN" Then
            CallFuncByIndex_AST = callScope.GetValue("__return")
            callScope.Pop
            Exit Function
        ElseIf ctrl = "ERR" Then
            err.Raise vbObjectError + 3000, "VM.CallFunc", "Error during function execution"
        End If
    Next i
    CallFuncByIndex_AST = Empty
    callScope.Pop
End Function

' ---------------------
' Utilities adapted from your previous VM
' ---------------------
Private Function IsTruthy(v As Variant) As Boolean
    If IsObject(v) Then IsTruthy = Not v Is Nothing: Exit Function
    If IsNull(v) Then IsTruthy = False: Exit Function
    If IsEmpty(v) Then IsTruthy = False: Exit Function
    If VarType(v) = vbBoolean Then IsTruthy = CBool(v): Exit Function
    If IsNumeric(v) Then IsTruthy = (CDbl(v) <> 0): Exit Function
    If VarType(v) = vbString Then
        If IsBoolean(CStr(v)) Then IsTruthy = CBool(v) Else IsTruthy = (CStr(v) <> "")
        Exit Function
    End If
    IsTruthy = True
End Function

Private Function IsBoolean(ByRef expression As String) As Boolean
    IsBoolean = (LCase(expression) = "true")
    If Not IsBoolean Then IsBoolean = (LCase(expression) = "false")
End Function

Private Function SafeAdd(a As Variant, b As Variant) As Variant
    If IsNumeric(a) And IsNumeric(b) Then SafeAdd = a + b Else SafeAdd = CStr(a) & CStr(b)
End Function

'Private Function ValueToStringForPrint(v As Variant) As String
'    Dim ub As Long, s As String, i As Long
'    If Not IsArray(v) Then
'        If IsNull(v) Then ValueToStringForPrint = "NULL": Exit Function
'        If IsEmpty(v) Then ValueToStringForPrint = "": Exit Function
'        ' pretty-print Map objects as {k: v, ...}
'        If TypeName(v) = "Map" Then
'            Dim outMap As String: outMap = "{"
'            Dim keysCol As Collection
'            Set keysCol = v.keys
'            Dim kk As Long
'            For kk = 1 To keysCol.Count
'                If kk > 1 Then outMap = outMap & ", "
'                Dim kname As String: kname = CStr(keysCol(kk))
'                Dim kval As Variant: kval = v.GetValue(kname)
'                outMap = outMap & kname & ": " & ValueToStringForPrint(kval)
'            Next kk
'            outMap = outMap & "}"
'            ValueToStringForPrint = outMap
'            Exit Function
'        End If
'        ValueToStringForPrint = CStr(v): Exit Function
'    End If
'    ub = UBound(v)
'    If ub < 0 Then ValueToStringForPrint = "[]": Exit Function
'    s = "["
'    For i = LBound(v) To ub
'        If i > LBound(v) Then s = s & ", "
'        s = s & CStr(v(i))
'    Next i
'    ValueToStringForPrint = s & "]"
'End Function
Private Function ValueToStringForPrint(v As Variant) As String
    Dim visited As New Collection
    ValueToStringForPrint = ValueToStringWithCtx(v, visited, 0)
End Function
' core recursive printer with context
Private Function ValueToStringWithCtx(v As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler

    ' Depth guard
    If depth > VTP_MAX_DEPTH Then
        ValueToStringWithCtx = "..."
        Exit Function
    End If

    ' Null / Empty
    If IsNull(v) Then
        ValueToStringWithCtx = "NULL": Exit Function
    End If
    If IsEmpty(v) Then
        ValueToStringWithCtx = "": Exit Function
    End If

    ' Scalars
    If VarType(v) = vbString Then
        ValueToStringWithCtx = CStr(v): Exit Function
    End If
    If VarType(v) = vbBoolean Then
        If CBool(v) Then ValueToStringWithCtx = "True" Else ValueToStringWithCtx = "False"
        Exit Function
    End If
    If IsNumeric(v) Then
        ValueToStringWithCtx = CStr(v): Exit Function
    End If

    ' Arrays (native VBA arrays)
    If IsArray(v) Then
        ValueToStringWithCtx = ArrayToString(v, visited, depth)
        Exit Function
    End If

    ' Objects
    If IsObject(v) Then
        Dim tn As String: tn = TypeName(v)
        Select Case tn
            Case "Map"
                ' cycle detection by object identity
                Dim i As Long
                For i = 1 To visited.Count
                    If visited(i) Is v Then
                        ValueToStringWithCtx = "[Circular]": Exit Function
                    End If
                Next i
                visited.Add v
                ValueToStringWithCtx = MapToString(v, visited, depth + 1)
                visited.Remove visited.Count
                Exit Function

            Case "Collection"
                ' cycle detection
                Dim j As Long
                For j = 1 To visited.Count
                    If visited(j) Is v Then
                        ValueToStringWithCtx = "[Circular]": Exit Function
                    End If
                Next j
                visited.Add v
                ValueToStringWithCtx = CollectionToString(v, visited, depth + 1)
                visited.Remove visited.Count
                Exit Function

            Case Else
                ' generic objects: try to call a ToString-like property if present, else fallback
                ValueToStringWithCtx = ObjectToString(v, visited, depth + 1)
                Exit Function
        End Select
    End If

    ' Fallback
    ValueToStringWithCtx = CStr(v)
    Exit Function

ErrHandler:
    ' On any unexpected error, return a safe placeholder and continue
    On Error Resume Next
    ValueToStringWithCtx = "[error: " & err.Number & "]"
    err.Clear
End Function

' Convert Map -> string
Private Function MapToString(m As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler
    Dim keys As Collection: Set keys = m.keys
    Dim kcnt As Long: kcnt = keys.Count

    If kcnt = 0 Then
        MapToString = "{}": Exit Function
    End If

    ' For small maps and shallow depth prefer inline representation
    If kcnt <= VTP_MAX_ITEMS_INLINE And depth <= 2 Then
        Dim parts() As String
        ReDim parts(1 To kcnt)
        Dim i As Long
        For i = 1 To kcnt
            Dim key As String: key = CStr(keys(i))
            Dim val As Variant: val = m.GetValue(key)
            parts(i) = CStr(key) & ": " & ValueToStringWithCtx(val, visited, depth)
        Next i
        MapToString = "{ " & Join(parts, ", ") & " }"
        Exit Function
    End If

    ' Multi-line pretty print
    Dim sb As String
    Dim indent As String: indent = String(depth * 2, " ")
    Dim innerIndent As String: innerIndent = String((depth + 1) * 2, " ")
    sb = "{"
    Dim first As Boolean: first = True
    Dim kk As Variant
    For Each kk In keys
        If Not first Then sb = sb & vbCrLf
        sb = sb & innerIndent & CStr(kk) & ": " & ValueToStringWithCtx(m.GetValue(CStr(kk)), visited, depth + 1)
        first = False
    Next kk
    sb = sb & vbCrLf & indent & "}"
    MapToString = sb
    Exit Function

ErrHandler:
    MapToString = "{<error>}"
    err.Clear
End Function

' Convert Collection -> string (treat as list)
Private Function CollectionToString(col As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler
    Dim n As Long: n = col.Count
    If n = 0 Then CollectionToString = "[]": Exit Function
    If n <= VTP_MAX_ITEMS_INLINE And depth <= 2 Then
        Dim tmp() As String: ReDim tmp(1 To n)
        Dim ii As Long
        For ii = 1 To n
            tmp(ii) = ValueToStringWithCtx(col(ii), visited, depth)
        Next ii
        CollectionToString = "[ " & Join(tmp, ", ") & " ]"
        Exit Function
    End If

    Dim sb As String: sb = "["
    Dim i As Long
    Dim indent As String: indent = String((depth + 1) * 2, " ")
    For i = 1 To n
        If i > 1 Then sb = sb & vbCrLf
        sb = sb & indent & ValueToStringWithCtx(col(i), visited, depth + 1)
    Next i
    sb = sb & vbCrLf & String(depth * 2, " ") & "]"
    CollectionToString = sb
    Exit Function

ErrHandler:
    CollectionToString = "[<error>]"
    err.Clear
End Function

' Convert native VBA array -> string
Private Function ArrayToString(arr As Variant, visited As Collection, depth As Long) As String
    On Error GoTo ErrHandler
    Dim lb As Long, UB As Long
    lb = LBound(arr): UB = UBound(arr)
    Dim n As Long: n = UB - lb + 1
    If n <= 0 Then ArrayToString = "[]": Exit Function
    If n <= VTP_MAX_ITEMS_INLINE And depth <= 2 Then
        Dim tmp() As String: ReDim tmp(1 To n)
        Dim i As Long
        For i = lb To UB
            tmp(i - lb + 1) = ValueToStringWithCtx(arr(i), visited, depth)
        Next i
        ArrayToString = "[ " & Join(tmp, ", ") & " ]"
        Exit Function
    End If

    Dim sb As String: sb = "["
    Dim indent As String: indent = String((depth + 1) * 2, " ")
    Dim ii As Long
    For ii = lb To UB
        If ii > lb Then sb = sb & vbCrLf
        sb = sb & indent & ValueToStringWithCtx(arr(ii), visited, depth + 1)
    Next ii
    sb = sb & vbCrLf & String(depth * 2, " ") & "]"
    ArrayToString = sb
    Exit Function

ErrHandler:
    ArrayToString = "[<error>]"
    err.Clear
End Function

' Generic object to string fallback:
' - If the object is a Map-like (has Keys and GetValue), will attempt to treat it as Map.
' - Else TypeName + simple to-string
Private Function ObjectToString(obj As Variant, visited As Collection, depth As Long) As String
    On Error GoTo Fallback
    Dim tn As String: tn = TypeName(obj)

    ' Attempt Map-like duck typing: presence of Keys and GetValue
    ' (use On Error to bail out if methods missing)
    Dim dummy As Collection
    Dim tryKeys As Collection
    On Error GoTo Fallback2
    Set tryKeys = obj.keys
    ' if successful, treat as Map
    Dim i As Long
    For i = 1 To visited.Count
        If visited(i) Is obj Then
            ObjectToString = "[Circular]": Exit Function
        End If
    Next i
    visited.Add obj
    ObjectToString = MapToString(obj, visited, depth)
    visited.Remove visited.Count
    Exit Function

Fallback2:
    ' Not a Map-like object: try default string
    On Error GoTo Fallback
    ObjectToString = "<" & tn & ">"
    Exit Function

Fallback:
    ObjectToString = "<object>"
    err.Clear
End Function

' Utility to escape short strings for printing if you want (optional)
Private Function EscapeStringForPrint(s As String) As String
    ' currently returns s raw; adapt if you want quoted output
    EscapeStringForPrint = s
End Function
 ' VBAexpressions integration helpers
 ' ---------------------
 ' Evaluate a raw VBAexpressions expression string using a VBAexpressions instance,
 ' seeding it with the current ASF scope variables so VB expressions can reference ASF variables.
Private Function EvalVBExpressionWithScope(expr As String, progScope As ScopeStack) As Variant
     On Error GoTo ErrHandler
     Dim exprEval As VBAexpressions
     Set exprEval = New VBAexpressions

     ' Create expression in evaluator
     exprEval.Create expr

     ' Inject variables from progScope (shadowing: global frames first, then locals)
     Dim frame As Variant
     Dim m As Map
     Dim keyCol As Collection
     Dim key As Variant
     For Each frame In progScope.Raw
         Set m = frame
         Set keyCol = m.keys
         For Each key In keyCol
             exprEval.VarValue(CStr(key)) = m.GetValue(CStr(key))
         Next key
     Next frame

     ' Evaluate
     exprEval.Eval
     If exprEval.ErrorType = 0 Then
         EvalVBExpressionWithScope = exprEval.result
     Else
         ' On error, raise to caller; the try/catch at Exec layer can handle it
         err.Raise vbObjectError + 7001, "VM.EvalVBExpressionWithScope", "VBAexpressions eval error"
     End If
     Exit Function
ErrHandler:
     ' convert to runtime log and return Empty
     If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "VBAexpr error: " & err.Description
     err.Clear
     EvalVBExpressionWithScope = Empty
End Function

 ' Evaluate a function call in VBAexpressions. Args is a Collection of evaluated values.
 ' We create a temporary variable for each argument inside the VBAexpressions environment
 ' to avoid needing to serialize complex values into textual literals.
Private Function EvalVBFunctionCall(fname As String, args As Collection, progScope As ScopeStack) As Variant
     On Error GoTo ErrHandler
     Dim exprEval As VBAexpressions
     Set exprEval = New VBAexpressions

     ' Seed evaluator with ASF scope variables
     Dim frame As Variant
     Dim m As Map
     Dim keyCol As Collection
     Dim key As Variant
     For Each frame In progScope.Raw
         Set m = frame
         Set keyCol = m.keys
         For Each key In keyCol
             exprEval.VarValue(CStr(key)) = m.GetValue(CStr(key))
         Next key
     Next frame

     ' Inject arguments as temporary variables: __asf_vbarg_1, __asf_vbarg_2, ...
     Dim i As Long
     Dim tmpNames As New Collection
     For i = 1 To args.Count
         Dim tname As String: tname = "__asf_vbarg_" & CStr(i)
         tmpNames.Add tname
         exprEval.VarValue(tname) = args(i)
     Next i

     ' build call string referencing temp names
     Dim callStr As String: callStr = fname & "("
     For i = 1 To tmpNames.Count
         If i > 1 Then callStr = callStr & ","
         callStr = callStr & tmpNames(i)
     Next i
     callStr = callStr & ")"

     ' Evaluate
     exprEval.Create callStr
     exprEval.Eval
     If exprEval.ErrorType = 0 Then
         EvalVBFunctionCall = exprEval.result
     Else
         err.Raise vbObjectError + 7002, "VM.EvalVBFunctionCall", "VBAexpressions function call error"
     End If
     Exit Function
ErrHandler:
     If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "VBAexpr function-call error: " & err.Description
     err.Clear
     EvalVBFunctionCall = Empty
End Function

 ' ---------------------
 ' Closure / function-value support (runtime helpers)
 ' ---------------------

 ' Create and call closures (closureMap is a Map with keys:
 '  "type" = "Closure", "params" = Collection, "body" = Collection (stmts), "env" = ScopeStack)
 Private Function CallClosure(closureMap As Map, evaluatedArgs As Collection, Optional thisVal As Variant) As Variant
     On Error GoTo ErrHandler
     Dim env As ScopeStack
     Set env = closureMap.GetValue("env") ' shared reference (shared-write semantics)

     ' push a new frame for this call
     env.Push
     Dim i As Long
     Dim pa As Variant
     Dim elm As Variant
     Dim fc As Boolean
     
     vAssignment pa, closureMap.GetValue("params")
     If IsObject(pa) Then
        fc = (Not pa Is Nothing)
     Else
        fc = Not IsEmpty(pa)
     End If
     If fc Then
         For Each elm In pa
             i = i + 1
             If i <= evaluatedArgs.Count Then
                 env.SetValue CStr(elm), evaluatedArgs(i)
             Else
                 env.SetValue CStr(elm), Empty
             End If
         Next elm
     End If

     ' set 'this' if provided
     If Not IsMissing(thisVal) Then
         env.SetValue "this", thisVal
     End If

     ' execute body
     Dim stmts As Collection: Set stmts = closureMap.GetValue("body")
     Dim ctrl As String
     Dim stmtIdx As Long
     For stmtIdx = 1 To stmts.Count
         ctrl = ExecuteStmtNode(stmts(stmtIdx), env)
         If ctrl = "RETURN" Then
             vAssignment CallClosure, env.GetValue("__return")
             env.Pop
             Exit Function
         ElseIf ctrl = "ERR" Then
             err.Raise vbObjectError + 8001, "VM.CallClosure", "Error during closure execution"
         End If
     Next stmtIdx

     ' normal return -> Empty
     env.Pop
     CallClosure = Empty
     Exit Function
ErrHandler:
     If VERBOSE_ Then GLOBALS_.gRuntimeLog.Add "CallClosure error: " & err.Description
     err.Clear
     CallClosure = Empty
 End Function
